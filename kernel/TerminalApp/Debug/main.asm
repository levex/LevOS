; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\TerminalApp\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?buf@@3PADA					; buf
PUBLIC	?num@@3DA					; num
PUBLIC	?c@@3DA						; c
PUBLIC	?cmdlist@@3PAU__COMMAND@@A			; cmdlist
PUBLIC	?currentCmd@@3DA				; currentCmd
_BSS	SEGMENT
?buf@@3PADA DB	020H DUP (?)				; buf
?num@@3DA DB	01H DUP (?)				; num
	ALIGN	4

?c@@3DA	DB	01H DUP (?)				; c
	ALIGN	4

?cmdlist@@3PAU__COMMAND@@A DB 0180H DUP (?)		; cmdlist
?currentCmd@@3DA DB 01H DUP (?)				; currentCmd
_BSS	ENDS
PUBLIC	?createCommand@@YAXPAD0P6AX0@Z@Z		; createCommand
; Function compile flags: /Odtp /ZI
; File c:\dev\levos\kernel\terminalapp\main.cpp
;	COMDAT ?createCommand@@YAXPAD0P6AX0@Z@Z
_TEXT	SEGMENT
_text$ = 8						; size = 4
_helptext$ = 12						; size = 4
_f$ = 16						; size = 4
?createCommand@@YAXPAD0P6AX0@Z@Z PROC			; createCommand, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 36   : 	cmdlist[currentCmd].func = f;

	movsx	eax, BYTE PTR ?currentCmd@@3DA		; currentCmd
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _f$[ebp]
	mov	DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax+8], ecx

; 37   : 	cmdlist[currentCmd].text = text;

	movsx	eax, BYTE PTR ?currentCmd@@3DA		; currentCmd
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _text$[ebp]
	mov	DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax], ecx

; 38   : 	cmdlist[currentCmd].helptext = helptext;

	movsx	eax, BYTE PTR ?currentCmd@@3DA		; currentCmd
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _helptext$[ebp]
	mov	DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax+4], ecx

; 39   : 	currentCmd++;

	mov	al, BYTE PTR ?currentCmd@@3DA		; currentCmd
	add	al, 1
	mov	BYTE PTR ?currentCmd@@3DA, al		; currentCmd

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?createCommand@@YAXPAD0P6AX0@Z@Z ENDP			; createCommand
_TEXT	ENDS
PUBLIC	??_C@_0L@GLAHGLNA@?6?$FLLevOS?$FN?$HO?5?$AA@	; `string'
PUBLIC	??_C@_0FG@KODAIHEC@Welcome?5to?5LevOS?52?40?6This?5is?5a?5b@ ; `string'
PUBLIC	??_C@_03ELCKCFOI@pci?$AA@			; `string'
PUBLIC	??_C@_0L@DODJAOBJ@?6Tests?5PCI?$AA@		; `string'
PUBLIC	?cmd_pci@@YAXPAD@Z				; cmd_pci
PUBLIC	??_C@_04GGLOKIEE@dump?$AA@			; `string'
PUBLIC	??_C@_0CB@HEGMHNBI@?6Dumps?5a?5PE32?5application?5or?5DLL@ ; `string'
PUBLIC	?cmd_dump@@YAXPAD@Z				; cmd_dump
PUBLIC	??_C@_04NLJIDCGO@bios?$AA@			; `string'
PUBLIC	??_C@_0BE@BNGHPFHM@?6Jumps?5back?5to?5BIOS?$AA@	; `string'
PUBLIC	?cmd_dobios@@YAXPAD@Z				; cmd_dobios
PUBLIC	??_C@_03DAPAKLGM@dir?$AA@			; `string'
PUBLIC	??_C@_0BP@OKJIHFLC@?6Lists?5files?5in?5root?5directory?$AA@ ; `string'
PUBLIC	?cmd_dir@@YAXPAD@Z				; cmd_dir
PUBLIC	??_C@_04CLCEDBPF@time?$AA@			; `string'
PUBLIC	??_C@_0N@DNDEBHMJ@?6Shows?5time?$CB?$AA@	; `string'
PUBLIC	?cmd_time@@YAXPAD@Z				; cmd_time
PUBLIC	??_C@_04OFDNEFMC@echo?$AA@			; `string'
PUBLIC	??_C@_0CN@FFHNKIIF@?6Syntax?3?5echo?5?$DMstring?$DO?6Echoes?5th@ ; `string'
PUBLIC	?cmd_echo@@YAXPAD@Z				; cmd_echo
PUBLIC	??_C@_03LCPHGAHP@cls?$AA@			; `string'
PUBLIC	??_C@_0BK@KIOFNDBH@?6Clears?5the?5screen?5?$CI0x17?$CJ?$AA@ ; `string'
PUBLIC	?cmd_cls@@YAXPAD@Z				; cmd_cls
PUBLIC	??_C@_05FAGFPHJG@start?$AA@			; `string'
PUBLIC	??_C@_0EM@LIPFLACD@?6Syntax?3?5start?5?$DMfilename?$DO?6Starts@ ; `string'
PUBLIC	?cmd_start@@YAXPAD@Z				; cmd_start
PUBLIC	??_C@_05BEELFHJC@about?$AA@			; `string'
PUBLIC	??_C@_0BJ@LBMBLBLG@?6Opens?5up?5an?5about?5text?$CB?$AA@ ; `string'
PUBLIC	?cmd_about@@YAXPAD@Z				; cmd_about
PUBLIC	??_C@_07PHNAGKJK@readtxt?$AA@			; `string'
PUBLIC	??_C@_0DM@EBHOHFFC@?6Syntax?3?5readtxt?5?$DMfilename?$DO?6Read@ ; `string'
PUBLIC	?cmd_test@@YAXPAD@Z				; cmd_test
PUBLIC	??_C@_04PCJFHION@help?$AA@			; `string'
PUBLIC	??_C@_0HG@PPKLFMOH@?6Syntax?3?5help?5?$DMcommand?$DO?6Opens?5up@ ; `string'
PUBLIC	?cmd_help@@YAXPAD@Z				; cmd_help
PUBLIC	??_C@_0BI@PCFEALJK@Terminal?5is?5executing?4?4?$AA@ ; `string'
PUBLIC	_main
EXTRN	__imp__printchar:PROC
EXTRN	__imp__moveCursorRelative:PROC
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
EXTRN	__imp__getInputChar:PROC
EXTRN	__imp__clearScreen:PROC
EXTRN	__imp__print:PROC
;	COMDAT ??_C@_0L@GLAHGLNA@?6?$FLLevOS?$FN?$HO?5?$AA@
CONST	SEGMENT
??_C@_0L@GLAHGLNA@?6?$FLLevOS?$FN?$HO?5?$AA@ DB 0aH, '[LevOS]~ ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@KODAIHEC@Welcome?5to?5LevOS?52?40?6This?5is?5a?5b@
CONST	SEGMENT
??_C@_0FG@KODAIHEC@Welcome?5to?5LevOS?52?40?6This?5is?5a?5b@ DB 'Welcome '
	DB	'to LevOS 2.0', 0aH, 'This is a basic CLI, use ''help'' for mo'
	DB	're information.', 0aH, 'Have fun!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELCKCFOI@pci?$AA@
CONST	SEGMENT
??_C@_03ELCKCFOI@pci?$AA@ DB 'pci', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DODJAOBJ@?6Tests?5PCI?$AA@
CONST	SEGMENT
??_C@_0L@DODJAOBJ@?6Tests?5PCI?$AA@ DB 0aH, 'Tests PCI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGLOKIEE@dump?$AA@
CONST	SEGMENT
??_C@_04GGLOKIEE@dump?$AA@ DB 'dump', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HEGMHNBI@?6Dumps?5a?5PE32?5application?5or?5DLL@
CONST	SEGMENT
??_C@_0CB@HEGMHNBI@?6Dumps?5a?5PE32?5application?5or?5DLL@ DB 0aH, 'Dumps'
	DB	' a PE32 application or DLL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NLJIDCGO@bios?$AA@
CONST	SEGMENT
??_C@_04NLJIDCGO@bios?$AA@ DB 'bios', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BNGHPFHM@?6Jumps?5back?5to?5BIOS?$AA@
CONST	SEGMENT
??_C@_0BE@BNGHPFHM@?6Jumps?5back?5to?5BIOS?$AA@ DB 0aH, 'Jumps back to BI'
	DB	'OS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAPAKLGM@dir?$AA@
CONST	SEGMENT
??_C@_03DAPAKLGM@dir?$AA@ DB 'dir', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OKJIHFLC@?6Lists?5files?5in?5root?5directory?$AA@
CONST	SEGMENT
??_C@_0BP@OKJIHFLC@?6Lists?5files?5in?5root?5directory?$AA@ DB 0aH, 'List'
	DB	's files in root directory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLCEDBPF@time?$AA@
CONST	SEGMENT
??_C@_04CLCEDBPF@time?$AA@ DB 'time', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DNDEBHMJ@?6Shows?5time?$CB?$AA@
CONST	SEGMENT
??_C@_0N@DNDEBHMJ@?6Shows?5time?$CB?$AA@ DB 0aH, 'Shows time!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFDNEFMC@echo?$AA@
CONST	SEGMENT
??_C@_04OFDNEFMC@echo?$AA@ DB 'echo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FFHNKIIF@?6Syntax?3?5echo?5?$DMstring?$DO?6Echoes?5th@
CONST	SEGMENT
??_C@_0CN@FFHNKIIF@?6Syntax?3?5echo?5?$DMstring?$DO?6Echoes?5th@ DB 0aH, 'S'
	DB	'yntax: echo <string>', 0aH, 'Echoes the arguments.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCPHGAHP@cls?$AA@
CONST	SEGMENT
??_C@_03LCPHGAHP@cls?$AA@ DB 'cls', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KIOFNDBH@?6Clears?5the?5screen?5?$CI0x17?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@KIOFNDBH@?6Clears?5the?5screen?5?$CI0x17?$CJ?$AA@ DB 0aH, 'Clea'
	DB	'rs the screen (0x17)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAGFPHJG@start?$AA@
CONST	SEGMENT
??_C@_05FAGFPHJG@start?$AA@ DB 'start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@LIPFLACD@?6Syntax?3?5start?5?$DMfilename?$DO?6Starts@
CONST	SEGMENT
??_C@_0EM@LIPFLACD@?6Syntax?3?5start?5?$DMfilename?$DO?6Starts@ DB 0aH, 'S'
	DB	'yntax: start <filename>', 0aH, 'Starts a PE32 application of '
	DB	'filename <filename>.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BEELFHJC@about?$AA@
CONST	SEGMENT
??_C@_05BEELFHJC@about?$AA@ DB 'about', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LBMBLBLG@?6Opens?5up?5an?5about?5text?$CB?$AA@
CONST	SEGMENT
??_C@_0BJ@LBMBLBLG@?6Opens?5up?5an?5about?5text?$CB?$AA@ DB 0aH, 'Opens u'
	DB	'p an about text!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07PHNAGKJK@readtxt?$AA@
CONST	SEGMENT
??_C@_07PHNAGKJK@readtxt?$AA@ DB 'readtxt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EBHOHFFC@?6Syntax?3?5readtxt?5?$DMfilename?$DO?6Read@
CONST	SEGMENT
??_C@_0DM@EBHOHFFC@?6Syntax?3?5readtxt?5?$DMfilename?$DO?6Read@ DB 0aH, 'S'
	DB	'yntax: readtxt <filename>', 0aH, 'Reads a .txt file from the '
	DB	'disk', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help?$AA@
CONST	SEGMENT
??_C@_04PCJFHION@help?$AA@ DB 'help', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@PPKLFMOH@?6Syntax?3?5help?5?$DMcommand?$DO?6Opens?5up@
CONST	SEGMENT
??_C@_0HG@PPKLFMOH@?6Syntax?3?5help?5?$DMcommand?$DO?6Opens?5up@ DB 0aH, 'S'
	DB	'yntax: help <command>', 0aH, 'Opens up a help text!', 0aH, 'I'
	DB	'f <command> is provided, provides extra information about the'
	DB	' command.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PCFEALJK@Terminal?5is?5executing?4?4?$AA@
CONST	SEGMENT
??_C@_0BI@PCFEALJK@Terminal?5is?5executing?4?4?$AA@ DB 'Terminal is execu'
	DB	'ting..', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_i$2698 = -12						; size = 4
_match$2697 = -5					; size = 1
_j$2693 = -4						; size = 4
_baseaddr$ = 8						; size = 4
_main	PROC						; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 44   : 	print("Terminal is executing..");

	push	OFFSET ??_C@_0BI@PCFEALJK@Terminal?5is?5executing?4?4?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 45   : 	//rtc_data = (RTC_DATA*)(baseaddr+0x8000);
; 46   : 	//fillRTC(rtc_data);
; 47   : 	clearScreen();

	call	DWORD PTR __imp__clearScreen

; 48   : 
; 49   : 	createCommand("help", "\nSyntax: help <command>\nOpens up a help text!\nIf <command> is provided, provides extra information about the command.", cmd_help);

	push	OFFSET ?cmd_help@@YAXPAD@Z		; cmd_help
	push	OFFSET ??_C@_0HG@PPKLFMOH@?6Syntax?3?5help?5?$DMcommand?$DO?6Opens?5up@
	push	OFFSET ??_C@_04PCJFHION@help?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 50   : 	createCommand("readtxt", "\nSyntax: readtxt <filename>\nReads a .txt file from the disk", cmd_test);

	push	OFFSET ?cmd_test@@YAXPAD@Z		; cmd_test
	push	OFFSET ??_C@_0DM@EBHOHFFC@?6Syntax?3?5readtxt?5?$DMfilename?$DO?6Read@
	push	OFFSET ??_C@_07PHNAGKJK@readtxt?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 51   : 	createCommand("about", "\nOpens up an about text!", cmd_about);

	push	OFFSET ?cmd_about@@YAXPAD@Z		; cmd_about
	push	OFFSET ??_C@_0BJ@LBMBLBLG@?6Opens?5up?5an?5about?5text?$CB?$AA@
	push	OFFSET ??_C@_05BEELFHJC@about?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 52   : 	createCommand("start", "\nSyntax: start <filename>\nStarts a PE32 application of filename <filename>.", cmd_start);

	push	OFFSET ?cmd_start@@YAXPAD@Z		; cmd_start
	push	OFFSET ??_C@_0EM@LIPFLACD@?6Syntax?3?5start?5?$DMfilename?$DO?6Starts@
	push	OFFSET ??_C@_05FAGFPHJG@start?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 53   : 	createCommand("cls", "\nClears the screen (0x17)", cmd_cls);

	push	OFFSET ?cmd_cls@@YAXPAD@Z		; cmd_cls
	push	OFFSET ??_C@_0BK@KIOFNDBH@?6Clears?5the?5screen?5?$CI0x17?$CJ?$AA@
	push	OFFSET ??_C@_03LCPHGAHP@cls?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 54   : 	createCommand("echo", "\nSyntax: echo <string>\nEchoes the arguments.", cmd_echo);

	push	OFFSET ?cmd_echo@@YAXPAD@Z		; cmd_echo
	push	OFFSET ??_C@_0CN@FFHNKIIF@?6Syntax?3?5echo?5?$DMstring?$DO?6Echoes?5th@
	push	OFFSET ??_C@_04OFDNEFMC@echo?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 55   : 	createCommand("time", "\nShows time!", cmd_time);

	push	OFFSET ?cmd_time@@YAXPAD@Z		; cmd_time
	push	OFFSET ??_C@_0N@DNDEBHMJ@?6Shows?5time?$CB?$AA@
	push	OFFSET ??_C@_04CLCEDBPF@time?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 56   : 	createCommand("dir", "\nLists files in root directory", cmd_dir);

	push	OFFSET ?cmd_dir@@YAXPAD@Z		; cmd_dir
	push	OFFSET ??_C@_0BP@OKJIHFLC@?6Lists?5files?5in?5root?5directory?$AA@
	push	OFFSET ??_C@_03DAPAKLGM@dir?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 57   : 	createCommand("bios", "\nJumps back to BIOS", cmd_dobios);

	push	OFFSET ?cmd_dobios@@YAXPAD@Z		; cmd_dobios
	push	OFFSET ??_C@_0BE@BNGHPFHM@?6Jumps?5back?5to?5BIOS?$AA@
	push	OFFSET ??_C@_04NLJIDCGO@bios?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 58   : 	createCommand("dump", "\nDumps a PE32 application or DLL", cmd_dump);

	push	OFFSET ?cmd_dump@@YAXPAD@Z		; cmd_dump
	push	OFFSET ??_C@_0CB@HEGMHNBI@?6Dumps?5a?5PE32?5application?5or?5DLL@
	push	OFFSET ??_C@_04GGLOKIEE@dump?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 59   : 	createCommand("pci", "\nTests PCI", cmd_pci);

	push	OFFSET ?cmd_pci@@YAXPAD@Z		; cmd_pci
	push	OFFSET ??_C@_0L@DODJAOBJ@?6Tests?5PCI?$AA@
	push	OFFSET ??_C@_03ELCKCFOI@pci?$AA@
	call	?createCommand@@YAXPAD0P6AX0@Z@Z	; createCommand
	add	esp, 12					; 0000000cH

; 60   : 
; 61   : 	//moveCursorRelative(0, -1);
; 62   : 	print("Welcome to LevOS 2.0\nThis is a basic CLI, use 'help' for more information.\nHave fun!\n");

	push	OFFSET ??_C@_0FG@KODAIHEC@Welcome?5to?5LevOS?52?40?6This?5is?5a?5b@
	call	DWORD PTR __imp__print
	add	esp, 4

; 63   : 	print("\n[LevOS]~ ");

	push	OFFSET ??_C@_0L@GLAHGLNA@?6?$FLLevOS?$FN?$HO?5?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
$LN17@main:

; 64   : 	while(true)

	mov	eax, 1
	test	eax, eax
	je	$LN18@main

; 65   : 	{
; 66   : 		c = getInputChar();

	call	DWORD PTR __imp__getInputChar
	mov	BYTE PTR ?c@@3DA, al			; c

; 67   : 		if(c == 0) continue;

	movsx	eax, BYTE PTR ?c@@3DA			; c
	test	eax, eax
	jne	SHORT $LN15@main
	jmp	SHORT $LN17@main
$LN15@main:

; 68   : 		if(c == 0xD)

	movsx	eax, BYTE PTR ?c@@3DA			; c
	cmp	eax, 13					; 0000000dH
	jne	$LN14@main

; 69   : 		{
; 70   : 			buf[num] = '\0';

	movsx	eax, BYTE PTR ?num@@3DA			; num
	mov	BYTE PTR ?buf@@3PADA[eax], 0

; 71   : 			for(int j = 0; j < currentCmd; j++)

	mov	DWORD PTR _j$2693[ebp], 0
	jmp	SHORT $LN13@main
$LN12@main:
	mov	eax, DWORD PTR _j$2693[ebp]
	add	eax, 1
	mov	DWORD PTR _j$2693[ebp], eax
$LN13@main:
	movsx	eax, BYTE PTR ?currentCmd@@3DA		; currentCmd
	cmp	DWORD PTR _j$2693[ebp], eax
	jge	$LN11@main

; 72   : 			{
; 73   : 				/*if(strcmp(buf, cmdlist[i].text) == 0) { cmdlist[i].func(buf); break;}*/
; 74   : 				bool match = true;

	mov	BYTE PTR _match$2697[ebp], 1

; 75   : 				for(int i = 0; i < strlen(buf); i++)

	mov	DWORD PTR _i$2698[ebp], 0
	jmp	SHORT $LN10@main
$LN9@main:
	mov	eax, DWORD PTR _i$2698[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2698[ebp], eax
$LN10@main:
	push	OFFSET ?buf@@3PADA			; buf
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	DWORD PTR _i$2698[ebp], eax
	jae	SHORT $LN8@main

; 76   : 				{
; 77   : 					if(cmdlist[j].text[i] == buf[i] || buf[i] == ' ')

	mov	eax, DWORD PTR _j$2693[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax]
	mov	edx, DWORD PTR _i$2698[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR _i$2698[ebp]
	movsx	edx, BYTE PTR ?buf@@3PADA[ecx]
	cmp	eax, edx
	je	SHORT $LN6@main
	mov	eax, DWORD PTR _i$2698[ebp]
	movsx	ecx, BYTE PTR ?buf@@3PADA[eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN7@main
$LN6@main:

; 78   : 					{
; 79   : 						if(cmdlist[j].text[i] == '\0' || buf[i] == ' ')

	mov	eax, DWORD PTR _j$2693[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax]
	mov	edx, DWORD PTR _i$2698[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN4@main
	mov	eax, DWORD PTR _i$2698[ebp]
	movsx	ecx, BYTE PTR ?buf@@3PADA[eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN5@main
$LN4@main:

; 80   : 						{
; 81   : 							match = true;

	mov	BYTE PTR _match$2697[ebp], 1

; 82   : 							break;

	jmp	SHORT $LN8@main
$LN5@main:

; 83   : 						}
; 84   : 						continue;

	jmp	SHORT $LN9@main

; 85   : 					} else {

	jmp	SHORT $LN3@main
$LN7@main:

; 86   : 						match = false;

	mov	BYTE PTR _match$2697[ebp], 0

; 87   : 						break;

	jmp	SHORT $LN8@main
$LN3@main:

; 88   : 					}
; 89   : 				}

	jmp	$LN9@main
$LN8@main:

; 90   : 				if(match) cmdlist[j].func(buf);

	movzx	eax, BYTE PTR _match$2697[ebp]
	test	eax, eax
	je	SHORT $LN2@main
	push	OFFSET ?buf@@3PADA			; buf
	mov	eax, DWORD PTR _j$2693[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax+8]
	call	ecx
	add	esp, 4
$LN2@main:

; 91   : 			}

	jmp	$LN12@main
$LN11@main:

; 92   : 			/*handle_cmd("help", cmd_help);
; 93   : 			handle_cmd("readtxt", cmd_test);
; 94   : 			handle_cmd("about", cmd_about);
; 95   : 			handle_cmd("start", cmd_start);
; 96   : 			handle_cmd("cls", cmd_cls);
; 97   : 			handle_cmd("echo", cmd_echo);*/
; 98   : 			num = 0;

	mov	BYTE PTR ?num@@3DA, 0			; num

; 99   : 			print("\n[LevOS]~ ");

	push	OFFSET ??_C@_0L@GLAHGLNA@?6?$FLLevOS?$FN?$HO?5?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 100  : 			continue;

	jmp	$LN17@main
$LN14@main:

; 101  : 		}
; 102  : 		if(c == 0x08)

	movsx	eax, BYTE PTR ?c@@3DA			; c
	cmp	eax, 8
	jne	SHORT $LN1@main

; 103  : 		{
; 104  : 			num --;

	mov	al, BYTE PTR ?num@@3DA			; num
	sub	al, 1
	mov	BYTE PTR ?num@@3DA, al			; num

; 105  : 			moveCursorRelative(-1, 0);

	push	0
	push	-1
	call	DWORD PTR __imp__moveCursorRelative
	add	esp, 8

; 106  : 			printchar(' ');

	push	32					; 00000020H
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 107  : 			moveCursorRelative(-1, 0);

	push	0
	push	-1
	call	DWORD PTR __imp__moveCursorRelative
	add	esp, 8

; 108  : 			continue;

	jmp	$LN17@main
$LN1@main:

; 109  : 		}
; 110  : 		buf[num] = c;

	movsx	eax, BYTE PTR ?num@@3DA			; num
	mov	cl, BYTE PTR ?c@@3DA			; c
	mov	BYTE PTR ?buf@@3PADA[eax], cl

; 111  : 		num++;

	mov	al, BYTE PTR ?num@@3DA			; num
	add	al, 1
	mov	BYTE PTR ?num@@3DA, al			; num

; 112  : 		printchar(c);

	movzx	eax, BYTE PTR ?c@@3DA			; c
	push	eax
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 113  : 	}

	jmp	$LN17@main
$LN18@main:

; 114  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
PUBLIC	?handle_cmd@@YAXPADP6AX0@Z@Z			; handle_cmd
; Function compile flags: /Odtp /ZI
;	COMDAT ?handle_cmd@@YAXPADP6AX0@Z@Z
_TEXT	SEGMENT
_i$2714 = -8						; size = 4
_match$ = -1						; size = 1
_text$ = 8						; size = 4
_f$ = 12						; size = 4
?handle_cmd@@YAXPADP6AX0@Z@Z PROC			; handle_cmd, COMDAT

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 118  : 	/*if(strlen(text) == strlen(buf)) 
; 119  : 	{*/
; 120  : 		bool match = true;

	mov	BYTE PTR _match$[ebp], 1

; 121  : 		for(int i = 0; i < strlen(buf); i++)

	mov	DWORD PTR _i$2714[ebp], 0
	jmp	SHORT $LN9@handle_cmd
$LN8@handle_cmd:
	mov	eax, DWORD PTR _i$2714[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2714[ebp], eax
$LN9@handle_cmd:
	push	OFFSET ?buf@@3PADA			; buf
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	DWORD PTR _i$2714[ebp], eax
	jae	SHORT $LN7@handle_cmd

; 122  : 		{
; 123  : 			if(text[i] == buf[i] || buf[i] == ' ')

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$2714[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _i$2714[ebp]
	movsx	eax, BYTE PTR ?buf@@3PADA[edx]
	cmp	ecx, eax
	je	SHORT $LN5@handle_cmd
	mov	eax, DWORD PTR _i$2714[ebp]
	movsx	ecx, BYTE PTR ?buf@@3PADA[eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN6@handle_cmd
$LN5@handle_cmd:

; 124  : 			{
; 125  : 				if(text[i] == '\0' || buf[i] == ' ')

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$2714[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@handle_cmd
	mov	eax, DWORD PTR _i$2714[ebp]
	movsx	ecx, BYTE PTR ?buf@@3PADA[eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN4@handle_cmd
$LN3@handle_cmd:

; 126  : 				{
; 127  : 					match = true;

	mov	BYTE PTR _match$[ebp], 1

; 128  : 					break;

	jmp	SHORT $LN7@handle_cmd
$LN4@handle_cmd:

; 129  : 				}
; 130  : 				continue;

	jmp	SHORT $LN8@handle_cmd

; 131  : 			} else {

	jmp	SHORT $LN2@handle_cmd
$LN6@handle_cmd:

; 132  : 				match = false;

	mov	BYTE PTR _match$[ebp], 0

; 133  : 				break;

	jmp	SHORT $LN7@handle_cmd
$LN2@handle_cmd:

; 134  : 			}
; 135  : 		}

	jmp	SHORT $LN8@handle_cmd
$LN7@handle_cmd:

; 136  : 		if(match) f(buf);

	movzx	eax, BYTE PTR _match$[ebp]
	test	eax, eax
	je	SHORT $LN10@handle_cmd
	push	OFFSET ?buf@@3PADA			; buf
	call	DWORD PTR _f$[ebp]
	add	esp, 4
$LN10@handle_cmd:

; 137  : 	//}
; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?handle_cmd@@YAXPADP6AX0@Z@Z ENDP			; handle_cmd
_TEXT	ENDS
PUBLIC	??_C@_0DH@KHANMGIM@?6Use?5help?5?$DMcommand?$DO?5to?5get?5bette@ ; `string'
PUBLIC	??_C@_02LNAEAIDO@?$DL?5?$AA@			; `string'
PUBLIC	??_C@_0BG@DMKKJMII@?6Commands?5available?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@PIOLICDL@?6Welcome?5to?5LevOS2?40?$CB?$AA@ ; `string'
EXTRN	?strcmp@@YAHPBD0@Z:PROC				; strcmp
EXTRN	?strchr@@YAPADPADH@Z:PROC			; strchr
;	COMDAT ??_C@_0DH@KHANMGIM@?6Use?5help?5?$DMcommand?$DO?5to?5get?5bette@
CONST	SEGMENT
??_C@_0DH@KHANMGIM@?6Use?5help?5?$DMcommand?$DO?5to?5get?5bette@ DB 0aH, 'U'
	DB	'se help <command> to get better help on the commands', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LNAEAIDO@?$DL?5?$AA@
CONST	SEGMENT
??_C@_02LNAEAIDO@?$DL?5?$AA@ DB '; ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DMKKJMII@?6Commands?5available?3?5?$AA@
CONST	SEGMENT
??_C@_0BG@DMKKJMII@?6Commands?5available?3?5?$AA@ DB 0aH, 'Commands avail'
	DB	'able: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PIOLICDL@?6Welcome?5to?5LevOS2?40?$CB?$AA@
CONST	SEGMENT
??_C@_0BG@PIOLICDL@?6Welcome?5to?5LevOS2?40?$CB?$AA@ DB 0aH, 'Welcome to '
	DB	'LevOS2.0!', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?cmd_help@@YAXPAD@Z
_TEXT	SEGMENT
_i$2735 = -12						; size = 4
_i$2728 = -8						; size = 4
_arg$ = -4						; size = 4
_buf$ = 8						; size = 4
?cmd_help@@YAXPAD@Z PROC				; cmd_help, COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 142  : 	char* arg = strchr(buf, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _arg$[ebp], eax

; 143  : 	arg++;

	mov	eax, DWORD PTR _arg$[ebp]
	add	eax, 1
	mov	DWORD PTR _arg$[ebp], eax

; 144  : 	//if(strlen(arg) != 0)
; 145  : 	//if(*arg != '\0')
; 146  : 		for(int i = 0; i < currentCmd; i++)

	mov	DWORD PTR _i$2728[ebp], 0
	jmp	SHORT $LN8@cmd_help
$LN7@cmd_help:
	mov	eax, DWORD PTR _i$2728[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2728[ebp], eax
$LN8@cmd_help:
	movsx	eax, BYTE PTR ?currentCmd@@3DA		; currentCmd
	cmp	DWORD PTR _i$2728[ebp], eax
	jge	SHORT $LN6@cmd_help

; 147  : 		{
; 148  : 			if(strcmp(arg, cmdlist[i].text) == 0) {print(cmdlist[i].helptext);return;}

	mov	eax, DWORD PTR _i$2728[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax]
	push	ecx
	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@cmd_help
	mov	eax, DWORD PTR _i$2728[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax+4]
	push	ecx
	call	DWORD PTR __imp__print
	add	esp, 4
	jmp	SHORT $LN9@cmd_help
$LN5@cmd_help:

; 149  : 		}

	jmp	SHORT $LN7@cmd_help
$LN6@cmd_help:

; 150  : 	/*if(strcmp(arg, "readtxt") == 0)
; 151  : 	{
; 152  : 		print("\nreadtxt <filename>");
; 153  : 		print("\nRead a .txt file from the disk");
; 154  : 		return;
; 155  : 	} else if(strcmp(arg, "help") == 0)
; 156  : 	{
; 157  : 		print("\nhelp");
; 158  : 		print("\nOpens up a help text!");
; 159  : 		return;
; 160  : 	}
; 161  : 	else if(strcmp(arg, "about") == 0)
; 162  : 	{
; 163  : 		print("\nabout");
; 164  : 		print("\nOpens up an about text!");
; 165  : 		return;
; 166  : 	}
; 167  : 	else if(strcmp(arg, "start") == 0)
; 168  : 	{
; 169  : 		print("\nstart <filename>");
; 170  : 		print("\nLoads and parses a PE32 application");
; 171  : 		return;
; 172  : 	}
; 173  : 	else if(strcmp(arg, "cls") == 0)
; 174  : 	{
; 175  : 		print("\ncls");
; 176  : 		print("\nClears the screen. (0x17)");
; 177  : 		return;
; 178  : 	}
; 179  : 	else if(strcmp(arg, "echo") == 0)
; 180  : 	{
; 181  : 		print("\necho <string>");
; 182  : 		print("\nEchoes a string!");
; 183  : 		return;
; 184  : 	}*/
; 185  : 	print("\nWelcome to LevOS2.0!");

	push	OFFSET ??_C@_0BG@PIOLICDL@?6Welcome?5to?5LevOS2?40?$CB?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 186  : 	print("\nCommands available: ");//help; readtxt; about; start; cls; echo");

	push	OFFSET ??_C@_0BG@DMKKJMII@?6Commands?5available?3?5?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 187  : 	for(int i = 0; i < currentCmd; i++)

	mov	DWORD PTR _i$2735[ebp], 0
	jmp	SHORT $LN4@cmd_help
$LN3@cmd_help:
	mov	eax, DWORD PTR _i$2735[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2735[ebp], eax
$LN4@cmd_help:
	movsx	eax, BYTE PTR ?currentCmd@@3DA		; currentCmd
	cmp	DWORD PTR _i$2735[ebp], eax
	jge	SHORT $LN2@cmd_help

; 188  : 	{
; 189  : 		print(cmdlist[i].text);

	mov	eax, DWORD PTR _i$2735[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?cmdlist@@3PAU__COMMAND@@A[eax]
	push	ecx
	call	DWORD PTR __imp__print
	add	esp, 4

; 190  : 		if(i != currentCmd - 1) {

	movsx	eax, BYTE PTR ?currentCmd@@3DA		; currentCmd
	sub	eax, 1
	cmp	DWORD PTR _i$2735[ebp], eax
	je	SHORT $LN1@cmd_help

; 191  : 			print("; ");

	push	OFFSET ??_C@_02LNAEAIDO@?$DL?5?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
$LN1@cmd_help:

; 192  : 		}
; 193  : 	}

	jmp	SHORT $LN3@cmd_help
$LN2@cmd_help:

; 194  : 	//printchar('\n');
; 195  : 	print("\nUse help <command> to get better help on the commands");

	push	OFFSET ??_C@_0DH@KHANMGIM@?6Use?5help?5?$DMcommand?$DO?5to?5get?5bette@
	call	DWORD PTR __imp__print
	add	esp, 4
$LN9@cmd_help:

; 196  : 	return;
; 197  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_help@@YAXPAD@Z ENDP				; cmd_help
_TEXT	ENDS
PUBLIC	??_C@_0BI@FJMAFFGJ@?6ERROR?3?5File?5not?5found?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JLLABHCE@?6Please?5give?5a?5filename?$CB?$AA@ ; `string'
EXTRN	__imp__loadFileToLoc:PROC
;	COMDAT ??_C@_0BI@FJMAFFGJ@?6ERROR?3?5File?5not?5found?$CB?$AA@
CONST	SEGMENT
??_C@_0BI@FJMAFFGJ@?6ERROR?3?5File?5not?5found?$CB?$AA@ DB 0aH, 'ERROR: F'
	DB	'ile not found!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JLLABHCE@?6Please?5give?5a?5filename?$CB?$AA@
CONST	SEGMENT
??_C@_0BJ@JLLABHCE@?6Please?5give?5a?5filename?$CB?$AA@ DB 0aH, 'Please g'
	DB	'ive a filename!', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?cmd_test@@YAXPAD@Z
_TEXT	SEGMENT
_c$ = -5						; size = 1
_arg$ = -4						; size = 4
_buf$ = 8						; size = 4
?cmd_test@@YAXPAD@Z PROC				; cmd_test, COMDAT

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 200  : 	char* arg = strchr(buf, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _arg$[ebp], eax

; 201  : 	arg++;

	mov	eax, DWORD PTR _arg$[ebp]
	add	eax, 1
	mov	DWORD PTR _arg$[ebp], eax

; 202  : 	if(*arg == '\0') {print("\nPlease give a filename!");return;}

	mov	eax, DWORD PTR _arg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@cmd_test
	push	OFFSET ??_C@_0BJ@JLLABHCE@?6Please?5give?5a?5filename?$CB?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
	jmp	SHORT $LN3@cmd_test
$LN2@cmd_test:

; 203  : 	bool c = loadFileToLoc(arg, (char*)0xC10000);

	push	12648448				; 00c10000H
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	DWORD PTR __imp__loadFileToLoc
	add	esp, 8
	mov	BYTE PTR _c$[ebp], al

; 204  : 	if(!c){print("\nERROR: File not found!");return;}

	movzx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	jne	SHORT $LN1@cmd_test
	push	OFFSET ??_C@_0BI@FJMAFFGJ@?6ERROR?3?5File?5not?5found?$CB?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
	jmp	SHORT $LN3@cmd_test
$LN1@cmd_test:

; 205  : 	printchar('\n');

	push	10					; 0000000aH
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 206  : 	print((char*)0xC10000);

	push	12648448				; 00c10000H
	call	DWORD PTR __imp__print
	add	esp, 4
$LN3@cmd_test:

; 207  : 	return;
; 208  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_test@@YAXPAD@Z ENDP				; cmd_test
_TEXT	ENDS
PUBLIC	??_C@_0GO@GBIKKDFG@?6LevOS2?40?5is?5a?5rewrite?5of?5the?5no@ ; `string'
;	COMDAT ??_C@_0GO@GBIKKDFG@?6LevOS2?40?5is?5a?5rewrite?5of?5the?5no@
CONST	SEGMENT
??_C@_0GO@GBIKKDFG@?6LevOS2?40?5is?5a?5rewrite?5of?5the?5no@ DB 0aH, 'Lev'
	DB	'OS2.0 is a rewrite of the not-so-famous LevOS1.0,', 0aH, 'whi'
	DB	'ch failed when paging was about to be implemented :/', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?cmd_about@@YAXPAD@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
?cmd_about@@YAXPAD@Z PROC				; cmd_about, COMDAT

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 211  : 	print("\nLevOS2.0 is a rewrite of the not-so-famous LevOS1.0,\nwhich failed when paging was about to be implemented :/");

	push	OFFSET ??_C@_0GO@GBIKKDFG@?6LevOS2?40?5is?5a?5rewrite?5of?5the?5no@
	call	DWORD PTR __imp__print
	add	esp, 4

; 212  : 	return;
; 213  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_about@@YAXPAD@Z ENDP				; cmd_about
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?cmd_dobios@@YAXPAD@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
?cmd_dobios@@YAXPAD@Z PROC				; cmd_dobios, COMDAT

; 215  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 216  : 	_asm mov eax, 0x01

	mov	eax, 1

; 217  : 	_asm mov ebx, 0x01

	mov	ebx, 1

; 218  : 	_asm int 0x2F

	int	47					; 0000002fH

; 219  : 	return;
; 220  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_dobios@@YAXPAD@Z ENDP				; cmd_dobios
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?cmd_pci@@YAXPAD@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
?cmd_pci@@YAXPAD@Z PROC					; cmd_pci, COMDAT

; 222  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 223  : 	_asm mov eax, 0x01

	mov	eax, 1

; 224  : 	_asm mov ebx, 0x02

	mov	ebx, 2

; 225  : 	_asm int 0x2F

	int	47					; 0000002fH

; 226  : 	return;
; 227  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_pci@@YAXPAD@Z ENDP					; cmd_pci
_TEXT	ENDS
PUBLIC	??_C@_0BM@CLBJFCLJ@?6No?5extra?5terminals?5yet?$CB?5?3?$CI?$AA@ ; `string'
PUBLIC	??_C@_07INNMNHPJ@cmd?4exe?$AA@			; `string'
PUBLIC	??_C@_0BM@MGEKPPCA@?6Kernel?5can?8t?5be?5loaded?$CB?5?3?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0L@FEMKKAMN@KRNL32?4exe?$AA@		; `string'
PUBLIC	??_C@_0BO@BBHHJJJP@?6Please?5give?5a?5software?5name?$CB?$AA@ ; `string'
EXTRN	__imp__executePE32:PROC
;	COMDAT ??_C@_0BM@CLBJFCLJ@?6No?5extra?5terminals?5yet?$CB?5?3?$CI?$AA@
CONST	SEGMENT
??_C@_0BM@CLBJFCLJ@?6No?5extra?5terminals?5yet?$CB?5?3?$CI?$AA@ DB 0aH, 'N'
	DB	'o extra terminals yet! :(', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07INNMNHPJ@cmd?4exe?$AA@
CONST	SEGMENT
??_C@_07INNMNHPJ@cmd?4exe?$AA@ DB 'cmd.exe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MGEKPPCA@?6Kernel?5can?8t?5be?5loaded?$CB?5?3?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@MGEKPPCA@?6Kernel?5can?8t?5be?5loaded?$CB?5?3?$CJ?$AA@ DB 0aH, 'K'
	DB	'ernel can''t be loaded! :)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEMKKAMN@KRNL32?4exe?$AA@
CONST	SEGMENT
??_C@_0L@FEMKKAMN@KRNL32?4exe?$AA@ DB 'KRNL32.exe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BBHHJJJP@?6Please?5give?5a?5software?5name?$CB?$AA@
CONST	SEGMENT
??_C@_0BO@BBHHJJJP@?6Please?5give?5a?5software?5name?$CB?$AA@ DB 0aH, 'Pl'
	DB	'ease give a software name!', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?cmd_start@@YAXPAD@Z
_TEXT	SEGMENT
_arg$ = -4						; size = 4
_buf$ = 8						; size = 4
?cmd_start@@YAXPAD@Z PROC				; cmd_start, COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 230  : 	char* arg = strchr(buf, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _arg$[ebp], eax

; 231  : 	arg++;

	mov	eax, DWORD PTR _arg$[ebp]
	add	eax, 1
	mov	DWORD PTR _arg$[ebp], eax

; 232  : 	if(*arg == '\0') {print("\nPlease give a software name!");return;}

	mov	eax, DWORD PTR _arg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@cmd_start
	push	OFFSET ??_C@_0BO@BBHHJJJP@?6Please?5give?5a?5software?5name?$CB?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
	jmp	SHORT $LN5@cmd_start
$LN4@cmd_start:

; 233  : 	if(strcmp(arg, "KRNL32.exe") == 0){print("\nKernel can't be loaded! :)");return;}

	push	OFFSET ??_C@_0L@FEMKKAMN@KRNL32?4exe?$AA@
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@cmd_start
	push	OFFSET ??_C@_0BM@MGEKPPCA@?6Kernel?5can?8t?5be?5loaded?$CB?5?3?$CJ?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
	jmp	SHORT $LN5@cmd_start
$LN3@cmd_start:

; 234  : 	if(strcmp(arg, "cmd.exe") == 0){print("\nNo extra terminals yet! :(");return;}

	push	OFFSET ??_C@_07INNMNHPJ@cmd?4exe?$AA@
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@cmd_start
	push	OFFSET ??_C@_0BM@CLBJFCLJ@?6No?5extra?5terminals?5yet?$CB?5?3?$CI?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
	jmp	SHORT $LN5@cmd_start
$LN2@cmd_start:

; 235  : 	if(!executePE32(arg)) print("\nERROR: File not found!");

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	DWORD PTR __imp__executePE32
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@cmd_start
	push	OFFSET ??_C@_0BI@FJMAFFGJ@?6ERROR?3?5File?5not?5found?$CB?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
$LN5@cmd_start:

; 236  : 	return;
; 237  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_start@@YAXPAD@Z ENDP				; cmd_start
_TEXT	ENDS
EXTRN	__imp__dumpPE32:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?cmd_dump@@YAXPAD@Z
_TEXT	SEGMENT
_arg$ = -4						; size = 4
_buf$ = 8						; size = 4
?cmd_dump@@YAXPAD@Z PROC				; cmd_dump, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 240  : 	char* arg = strchr(buf, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _arg$[ebp], eax

; 241  : 	arg++;

	mov	eax, DWORD PTR _arg$[ebp]
	add	eax, 1
	mov	DWORD PTR _arg$[ebp], eax

; 242  : 	if(*arg == '\0') {print("\nPlease give a software name!");return;}

	mov	eax, DWORD PTR _arg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@cmd_dump
	push	OFFSET ??_C@_0BO@BBHHJJJP@?6Please?5give?5a?5software?5name?$CB?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
	jmp	SHORT $LN3@cmd_dump
$LN2@cmd_dump:

; 243  : 	/*if(strcmp(arg, "KRNL32.exe") == 0){print("\nKernel can't be loaded! :)");return;}
; 244  : 	if(strcmp(arg, "cmd.exe") == 0){print("\nNo extra terminals yet! :(");return;}*/
; 245  : 	if(!dumpPE32(arg)) print("\nERROR: File not found!");

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	DWORD PTR __imp__dumpPE32
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@cmd_dump
	push	OFFSET ??_C@_0BI@FJMAFFGJ@?6ERROR?3?5File?5not?5found?$CB?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4
$LN3@cmd_dump:

; 246  : 	return;
; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_dump@@YAXPAD@Z ENDP				; cmd_dump
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?cmd_cls@@YAXPAD@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
?cmd_cls@@YAXPAD@Z PROC					; cmd_cls, COMDAT

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 250  : 	clearScreen();

	call	DWORD PTR __imp__clearScreen

; 251  : 	return;
; 252  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_cls@@YAXPAD@Z ENDP					; cmd_cls
_TEXT	ENDS
PUBLIC	??_C@_06LJBKCCFA@Fails?$CB?$AA@			; `string'
EXTRN	__imp__getNumberOfFilesInRoot:PROC
EXTRN	__imp__getFilesInRoot:PROC
;	COMDAT ??_C@_06LJBKCCFA@Fails?$CB?$AA@
CONST	SEGMENT
??_C@_06LJBKCCFA@Fails?$CB?$AA@ DB 'Fails!', 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?cmd_dir@@YAXPAD@Z
_TEXT	SEGMENT
_j$2796 = -28						; size = 4
_i$2792 = -24						; size = 4
_num$ = -5						; size = 1
_files$ = -4						; size = 4
_buf$ = 8						; size = 4
?cmd_dir@@YAXPAD@Z PROC					; cmd_dir, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 255  : 	print("Fails!");

	push	OFFSET ??_C@_06LJBKCCFA@Fails?$CB?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 256  : 	return;

	jmp	$LN8@cmd_dir

; 257  : 	printchar('\n');

	push	10					; 0000000aH
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 258  : 	char* files = getFilesInRoot();

	call	DWORD PTR __imp__getFilesInRoot
	mov	DWORD PTR _files$[ebp], eax

; 259  : 	char num = getNumberOfFilesInRoot();

	call	DWORD PTR __imp__getNumberOfFilesInRoot
	mov	BYTE PTR _num$[ebp], al

; 260  : 	char name[11];
; 261  : 	for(int i = 0; i < num; i++)

	mov	DWORD PTR _i$2792[ebp], 0
	jmp	SHORT $LN7@cmd_dir
$LN6@cmd_dir:
	mov	eax, DWORD PTR _i$2792[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2792[ebp], eax
$LN7@cmd_dir:
	movsx	eax, BYTE PTR _num$[ebp]
	cmp	DWORD PTR _i$2792[ebp], eax
	jge	SHORT $LN8@cmd_dir

; 262  : 	{
; 263  : 			for(int j = 0; j < 11; j++)

	mov	DWORD PTR _j$2796[ebp], 0
	jmp	SHORT $LN4@cmd_dir
$LN3@cmd_dir:
	mov	eax, DWORD PTR _j$2796[ebp]
	add	eax, 1
	mov	DWORD PTR _j$2796[ebp], eax
$LN4@cmd_dir:
	cmp	DWORD PTR _j$2796[ebp], 11		; 0000000bH
	jge	SHORT $LN2@cmd_dir

; 264  : 			{
; 265  : 				printchar(*(files + j + i *11));

	mov	eax, DWORD PTR _files$[ebp]
	add	eax, DWORD PTR _j$2796[ebp]
	mov	ecx, DWORD PTR _i$2792[ebp]
	imul	ecx, 11					; 0000000bH
	movzx	edx, BYTE PTR [eax+ecx]
	push	edx
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 266  : 			}

	jmp	SHORT $LN3@cmd_dir
$LN2@cmd_dir:

; 267  : 			if(i != num-1)printchar('\n');

	movsx	eax, BYTE PTR _num$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$2792[ebp], eax
	je	SHORT $LN1@cmd_dir
	push	10					; 0000000aH
	call	DWORD PTR __imp__printchar
	add	esp, 4
$LN1@cmd_dir:

; 268  : 	}

	jmp	SHORT $LN6@cmd_dir
$LN8@cmd_dir:

; 269  : 	return;
; 270  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_dir@@YAXPAD@Z ENDP					; cmd_dir
_TEXT	ENDS
PUBLIC	??_C@_02KHOJGJKF@?4?5?$AA@			; `string'
PUBLIC	??_C@_02PIBHCBOA@20?$AA@			; `string'
EXTRN	__imp__printHexa:PROC
EXTRN	__imp__fillRTC:PROC
_BSS	SEGMENT
	ALIGN	4

_rtc_data DB	01cH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_02KHOJGJKF@?4?5?$AA@
CONST	SEGMENT
??_C@_02KHOJGJKF@?4?5?$AA@ DB '. ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHCBOA@20?$AA@
CONST	SEGMENT
??_C@_02PIBHCBOA@20?$AA@ DB '20', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?cmd_time@@YAXPAD@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
?cmd_time@@YAXPAD@Z PROC				; cmd_time, COMDAT

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 273  : 	fillRTC((unsigned int)&rtc_data);

	push	OFFSET _rtc_data
	call	DWORD PTR __imp__fillRTC
	add	esp, 4

; 274  : 	printchar('\n');

	push	10					; 0000000aH
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 275  : 	print("20");

	push	OFFSET ??_C@_02PIBHCBOA@20?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 276  : 	printHexa((&rtc_data)->Year);

	mov	eax, DWORD PTR _rtc_data
	push	eax
	call	DWORD PTR __imp__printHexa
	add	esp, 4

; 277  : 	print(". ");

	push	OFFSET ??_C@_02KHOJGJKF@?4?5?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 278  : 	printHexa(rtc_data.Month);

	mov	eax, DWORD PTR _rtc_data+4
	push	eax
	call	DWORD PTR __imp__printHexa
	add	esp, 4

; 279  : 	print(". ");

	push	OFFSET ??_C@_02KHOJGJKF@?4?5?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 280  : 	printHexa(rtc_data.DayOfMonth);

	mov	eax, DWORD PTR _rtc_data+8
	push	eax
	call	DWORD PTR __imp__printHexa
	add	esp, 4

; 281  : 	print(". ");

	push	OFFSET ??_C@_02KHOJGJKF@?4?5?$AA@
	call	DWORD PTR __imp__print
	add	esp, 4

; 282  : 	printHexa(rtc_data.Hour);

	mov	eax, DWORD PTR _rtc_data+16
	push	eax
	call	DWORD PTR __imp__printHexa
	add	esp, 4

; 283  : 	printchar(':');

	push	58					; 0000003aH
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 284  : 	printHexa(rtc_data.Minute);

	mov	eax, DWORD PTR _rtc_data+20
	push	eax
	call	DWORD PTR __imp__printHexa
	add	esp, 4

; 285  : 	printchar(':');

	push	58					; 0000003aH
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 286  : 	printHexa(rtc_data.Second);

	mov	eax, DWORD PTR _rtc_data+24
	push	eax
	call	DWORD PTR __imp__printHexa
	add	esp, 4

; 287  : 	return;
; 288  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_time@@YAXPAD@Z ENDP				; cmd_time
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT ?cmd_echo@@YAXPAD@Z
_TEXT	SEGMENT
_arg$ = -4						; size = 4
_b$ = 8							; size = 4
?cmd_echo@@YAXPAD@Z PROC				; cmd_echo, COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 291  : 	char* arg = strchr(b, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _arg$[ebp], eax

; 292  : 	arg++;

	mov	eax, DWORD PTR _arg$[ebp]
	add	eax, 1
	mov	DWORD PTR _arg$[ebp], eax

; 293  : 	if(*arg == '\0') return;

	mov	eax, DWORD PTR _arg$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@cmd_echo
	jmp	SHORT $LN2@cmd_echo
$LN1@cmd_echo:

; 294  : 	printchar('\n');

	push	10					; 0000000aH
	call	DWORD PTR __imp__printchar
	add	esp, 4

; 295  : 	print(arg);

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	DWORD PTR __imp__print
	add	esp, 4
$LN2@cmd_echo:

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?cmd_echo@@YAXPAD@Z ENDP				; cmd_echo
_TEXT	ENDS
END
