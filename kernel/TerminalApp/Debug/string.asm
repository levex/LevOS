; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\TerminalApp\string.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?strcmp@@YAHPBD0@Z				; strcmp
; Function compile flags: /Odtp /ZI
; File c:\dev\levos\kernel\terminalapp\string.cpp
;	COMDAT ?strcmp@@YAHPBD0@Z
_TEXT	SEGMENT
_res$ = -4						; size = 4
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
?strcmp@@YAHPBD0@Z PROC					; strcmp, COMDAT

; 44   : int strcmp (const char* str1, const char* str2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 45   : 
; 46   : 	int res=0;

	mov	DWORD PTR _res$[ebp], 0
$LN4@strcmp:

; 47   : 	while (!(res = *(unsigned char*)str1 - *(unsigned char*)str2) && *str2) {

	mov	eax, DWORD PTR _str1$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _str2$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	ecx, eax
	mov	DWORD PTR _res$[ebp], ecx
	jne	SHORT $LN3@strcmp
	mov	eax, DWORD PTR _str2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@strcmp

; 48   : 		//print(".");
; 49   : 		//printchar(*(char*)str1);
; 50   : 		//printchar(*(char*)str2);
; 51   : 		++str1, ++str2;

	mov	eax, DWORD PTR _str1$[ebp]
	add	eax, 1
	mov	DWORD PTR _str1$[ebp], eax
	mov	ecx, DWORD PTR _str2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str2$[ebp], ecx

; 52   : 	}

	jmp	SHORT $LN4@strcmp
$LN3@strcmp:

; 53   : 
; 54   : 	if (res < 0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN2@strcmp

; 55   : 		res = -1;

	mov	DWORD PTR _res$[ebp], -1
$LN2@strcmp:

; 56   : 	if (res > 0)

	cmp	DWORD PTR _res$[ebp], 0
	jle	SHORT $LN1@strcmp

; 57   : 		res = 1;

	mov	DWORD PTR _res$[ebp], 1
$LN1@strcmp:

; 58   : 
; 59   : 	return res;

	mov	eax, DWORD PTR _res$[ebp]

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?strcmp@@YAHPBD0@Z ENDP					; strcmp
_TEXT	ENDS
PUBLIC	?strlcmp@@YA_NPAD0H@Z				; strlcmp
; Function compile flags: /Odtp /ZI
;	COMDAT ?strlcmp@@YA_NPAD0H@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_len$ = 16						; size = 4
?strlcmp@@YA_NPAD0H@Z PROC				; strlcmp, COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$LN2@strlcmp:

; 63   : 	while(*str1++ == *str2++)

	mov	eax, DWORD PTR _str2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _str1$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	edx, DWORD PTR _str2$[ebp]
	add	edx, 1
	mov	DWORD PTR _str2$[ebp], edx
	mov	edx, DWORD PTR _str1$[ebp]
	add	edx, 1
	mov	DWORD PTR _str1$[ebp], edx
	cmp	eax, ecx
	jne	SHORT $LN1@strlcmp

; 64   : 	{
; 65   : 		len --;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 66   : 	}

	jmp	SHORT $LN2@strlcmp
$LN1@strlcmp:

; 67   : 	return len<=0;

	xor	eax, eax
	cmp	DWORD PTR _len$[ebp], 0
	setle	al

; 68   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?strlcmp@@YA_NPAD0H@Z ENDP				; strlcmp
_TEXT	ENDS
PUBLIC	?strsplit@@YAXPADDAAH@Z				; strsplit
; Function compile flags: /Odtp /ZI
;	COMDAT ?strsplit@@YAXPADDAAH@Z
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_s1$ = 8						; size = 4
_delim$ = 12						; size = 1
_count$ = 16						; size = 4
?strsplit@@YAXPADDAAH@Z PROC				; strsplit, COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 72   : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 73   : 	int j = 0;

	mov	DWORD PTR _j$[ebp], 0
$LN4@strsplit:

; 74   : 	while(s1[j] != '\0') {

	mov	eax, DWORD PTR _s1$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@strsplit
$LN2@strsplit:

; 75   : 		while(s1[i] != delim) i++;

	mov	eax, DWORD PTR _s1$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR _delim$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@strsplit
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN2@strsplit
$LN1@strsplit:

; 76   : 		s1[i] = '\0';

	mov	eax, DWORD PTR _s1$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 0

; 77   : 		count ++;

	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	jmp	SHORT $LN4@strsplit
$LN5@strsplit:

; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?strsplit@@YAXPADDAAH@Z ENDP				; strsplit
_TEXT	ENDS
PUBLIC	?strcpy@@YAPADPADPBD@Z				; strcpy
; Function compile flags: /Odtp /ZI
;	COMDAT ?strcpy@@YAPADPADPBD@Z
_TEXT	SEGMENT
_s1_p$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
?strcpy@@YAPADPADPBD@Z PROC				; strcpy, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 84   :     char *s1_p = s1;

	mov	eax, DWORD PTR _s1$[ebp]
	mov	DWORD PTR _s1_p$[ebp], eax
$LN2@strcpy:

; 85   :     while (*s1++ = *s2++);

	mov	eax, DWORD PTR _s1$[ebp]
	mov	ecx, DWORD PTR _s2$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _s1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _s1$[ebp]
	add	edx, 1
	mov	DWORD PTR _s1$[ebp], edx
	mov	eax, DWORD PTR _s2$[ebp]
	add	eax, 1
	mov	DWORD PTR _s2$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN1@strcpy
	jmp	SHORT $LN2@strcpy
$LN1@strcpy:

; 86   :     return s1_p;

	mov	eax, DWORD PTR _s1_p$[ebp]

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?strcpy@@YAPADPADPBD@Z ENDP				; strcpy
_TEXT	ENDS
PUBLIC	?strlen@@YAIPBD@Z				; strlen
; Function compile flags: /Odtp /ZI
;	COMDAT ?strlen@@YAIPBD@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_str$ = 8						; size = 4
?strlen@@YAIPBD@Z PROC					; strlen, COMDAT

; 90   : size_t strlen ( const char* str ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 91   : 
; 92   : 	size_t	len=0;

	mov	DWORD PTR _len$[ebp], 0
$LN2@strlen:

; 93   : 	while (str[len++]);

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	test	ecx, ecx
	je	SHORT $LN1@strlen
	jmp	SHORT $LN2@strlen
$LN1@strlen:

; 94   : 	return len;

	mov	eax, DWORD PTR _len$[ebp]

; 95   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?strlen@@YAIPBD@Z ENDP					; strlen
_TEXT	ENDS
PUBLIC	?strncpy@@YAHPAD0H@Z				; strncpy
; Function compile flags: /Odtp /ZI
;	COMDAT ?strncpy@@YAHPAD0H@Z
_TEXT	SEGMENT
_val$ = -12						; size = 4
_s$ = -8						; size = 4
_d$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
?strncpy@@YAHPAD0H@Z PROC				; strncpy, COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 99   : 	char *d, *s;
; 100  : 	int val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 101  : 
; 102  : 	d = dest;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 103  : 	s = src;

	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN2@strncpy:

; 104  : 
; 105  : 	while ( *s != '\0' && len != 0 )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@strncpy
	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN1@strncpy

; 106  : 	{
; 107  : 		*d++ = *s++;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 108  : 		len--;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 109  : 		val++;

	mov	eax, DWORD PTR _val$[ebp]
	add	eax, 1
	mov	DWORD PTR _val$[ebp], eax

; 110  : 	}

	jmp	SHORT $LN2@strncpy
$LN1@strncpy:

; 111  : 	*d++ = '\0';

	mov	eax, DWORD PTR _d$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, 1
	mov	DWORD PTR _d$[ebp], ecx

; 112  : 	
; 113  : 	return val;

	mov	eax, DWORD PTR _val$[ebp]

; 114  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?strncpy@@YAHPAD0H@Z ENDP				; strncpy
_TEXT	ENDS
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
; Function compile flags: /Odtp /ZI
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_character$ = 12					; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 135  : char* strchr (char * str, int character ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$LN4@strchr:

; 136  : 
; 137  : 	do {
; 138  : 		if ( *str == character )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _character$[ebp]
	jne	SHORT $LN3@strchr

; 139  : 			return (char*)str;

	mov	eax, DWORD PTR _str$[ebp]
	jmp	SHORT $LN5@strchr
$LN3@strchr:

; 140  : 	}
; 141  : 	while (*str++);

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx
	test	ecx, ecx
	jne	SHORT $LN4@strchr

; 142  : 
; 143  : 	return 0;

	xor	eax, eax
$LN5@strchr:

; 144  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
PUBLIC	?strspr@@YAXPAD0HF@Z				; strspr
; Function compile flags: /Odtp /ZI
;	COMDAT ?strspr@@YAXPAD0HF@Z
_TEXT	SEGMENT
_found$ = -9						; size = 1
_backup$ = -8						; size = 4
_counter$ = -4						; size = 2
_str$ = 8						; size = 4
_buff$ = 12						; size = 4
_sep$ = 16						; size = 4
_which$ = 20						; size = 2
?strspr@@YAXPAD0HF@Z PROC				; strspr, COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 149  : 	short counter = 0;

	xor	eax, eax
	mov	WORD PTR _counter$[ebp], ax

; 150  : 	char* backup = str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _backup$[ebp], eax

; 151  : 	bool found = false;

	mov	BYTE PTR _found$[ebp], 0
$LN6@strspr:

; 152  : 	do {
; 153  : 		if ( *str == sep )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _sep$[ebp]
	jne	SHORT $LN3@strspr

; 154  : 		{
; 155  : 			counter++; continue;

	mov	ax, WORD PTR _counter$[ebp]
	add	ax, 1
	mov	WORD PTR _counter$[ebp], ax
	jmp	SHORT $LN5@strspr
$LN3@strspr:

; 156  : 		}
; 157  : 		if(counter == which)

	movsx	eax, WORD PTR _counter$[ebp]
	movsx	ecx, WORD PTR _which$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN5@strspr

; 158  : 			found=true;

	mov	BYTE PTR _found$[ebp], 1
$LN5@strspr:

; 159  : 	}
; 160  : 	while (*str++);

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx
	test	ecx, ecx
	jne	SHORT $LN6@strspr

; 161  : 
; 162  : 	if(!found) return;

	movzx	eax, BYTE PTR _found$[ebp]
	test	eax, eax
	jne	SHORT $LN1@strspr
	jmp	SHORT $LN7@strspr
$LN1@strspr:

; 163  : 	*backup += counter;

	movsx	eax, WORD PTR _counter$[ebp]
	mov	ecx, DWORD PTR _backup$[ebp]
	movsx	edx, BYTE PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _backup$[ebp]
	mov	BYTE PTR [eax], dl

; 164  : 	buff = backup;

	mov	eax, DWORD PTR _backup$[ebp]
	mov	DWORD PTR _buff$[ebp], eax
$LN7@strspr:

; 165  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?strspr@@YAXPAD0HF@Z ENDP				; strspr
_TEXT	ENDS
END
