; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\PCI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?pciConfigReadWord@@YAIGGGG@Z			; pciConfigReadWord
EXTRN	?inportW@@YAIG@Z:PROC				; inportW
EXTRN	?outportW@@YAXGI@Z:PROC				; outportW
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\pci.cpp
;	COMDAT ?pciConfigReadWord@@YAIGGGG@Z
_TEXT	SEGMENT
_bus$ = 8						; size = 2
_slot$ = 12						; size = 2
_func$ = 16						; size = 2
_offset$ = 20						; size = 2
?pciConfigReadWord@@YAIGGGG@Z PROC			; pciConfigReadWord, COMDAT

; 32   :     unsigned long address;
; 33   :     unsigned long lbus = (unsigned long)bus;
; 34   :     unsigned long lslot = (unsigned long)slot;
; 35   :     unsigned long lfunc = (unsigned long)func;
; 36   :     unsigned short tmp = 0;
; 37   :     address = (unsigned long)((lbus << 16) | (lslot << 11) |
; 38   :               (lfunc << 8) | (offset & 0xfc) | ((int)0x80000000));
; 39   :     outportW (0xCF8, address);

	movzx	eax, WORD PTR _bus$[esp-4]
	movzx	ecx, WORD PTR _slot$[esp-4]
	movzx	edx, WORD PTR _func$[esp-4]
	or	eax, -32768				; ffff8000H
	shl	eax, 5
	or	eax, ecx
	add	eax, eax
	add	eax, eax
	push	esi
	movzx	esi, WORD PTR _offset$[esp]
	add	eax, eax
	or	eax, edx
	mov	ecx, esi
	shl	eax, 8
	and	ecx, 252				; 000000fcH
	or	eax, ecx
	push	eax
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW

; 40   :     tmp = (unsigned short)((inportW (0xCFC) >> ((offset & 2) * 8)) & 0xffff);

	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	mov	ecx, esi
	and	ecx, 2
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	shr	eax, cl
	add	esp, 12					; 0000000cH
	pop	esi

; 41   :     return (tmp);

	movzx	eax, ax

; 42   :  }

	ret	0
?pciConfigReadWord@@YAIGGGG@Z ENDP			; pciConfigReadWord
_TEXT	ENDS
PUBLIC	?pciCheckVendor@@YAGGG@Z			; pciCheckVendor
; Function compile flags: /Ogtpy
;	COMDAT ?pciCheckVendor@@YAGGG@Z
_TEXT	SEGMENT
_bus$ = 8						; size = 2
_slot$ = 12						; size = 2
?pciCheckVendor@@YAGGG@Z PROC				; pciCheckVendor, COMDAT

; 46   :     unsigned short vendor,device;
; 47   : 	/* check if device is valid */
; 48   :     if ((vendor = pciConfigReadWord(bus,slot,0,0)) != 0xFFFF) {

	movzx	eax, WORD PTR _slot$[esp-4]
	push	esi
	movzx	esi, WORD PTR _bus$[esp]
	or	esi, -32768				; ffff8000H
	shl	esi, 5
	or	esi, eax
	push	edi
	shl	esi, 11					; 0000000bH
	push	esi
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	movzx	edi, ax
	mov	ecx, 65535				; 0000ffffH
	add	esp, 12					; 0000000cH
	cmp	di, cx
	je	SHORT $LN8@pciCheckVe

; 49   :        device = pciConfigReadWord(bus,slot,0,2);

	push	esi
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	add	esp, 12					; 0000000cH
$LN8@pciCheckVe:

; 50   :        /* valid device */
; 51   :     } return (vendor);

	mov	ax, di
	pop	edi
	pop	esi

; 52   :  }

	ret	0
?pciCheckVendor@@YAGGG@Z ENDP				; pciCheckVendor
_TEXT	ENDS
PUBLIC	?getVendorID@@YAGGGG@Z				; getVendorID
; Function compile flags: /Ogtpy
;	COMDAT ?getVendorID@@YAGGGG@Z
_TEXT	SEGMENT
_bus$ = 8						; size = 2
_device$ = 12						; size = 2
_function$ = 16						; size = 2
?getVendorID@@YAGGGG@Z PROC				; getVendorID, COMDAT

; 56   : 	int r0 = pciConfigReadWord(bus,device,function,0);

	movzx	eax, WORD PTR _bus$[esp-4]
	movzx	ecx, WORD PTR _device$[esp-4]
	movzx	edx, WORD PTR _function$[esp-4]
	or	eax, -32768				; ffff8000H
	shl	eax, 5
	or	eax, ecx
	add	eax, eax
	add	eax, eax
	add	eax, eax
	or	eax, edx
	shl	eax, 8
	push	eax
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	add	esp, 12					; 0000000cH

; 57   : 	// Register 00 => DeviceID(2b) VendorID(2b)
; 58   : 	return r0;
; 59   : }

	ret	0
?getVendorID@@YAGGGG@Z ENDP				; getVendorID
_TEXT	ENDS
PUBLIC	?getDeviceID@@YAGGGG@Z				; getDeviceID
; Function compile flags: /Ogtpy
;	COMDAT ?getDeviceID@@YAGGGG@Z
_TEXT	SEGMENT
_bus$ = 8						; size = 2
_device$ = 12						; size = 2
_function$ = 16						; size = 2
?getDeviceID@@YAGGGG@Z PROC				; getDeviceID, COMDAT

; 63   : 	int r0 = pciConfigReadWord(bus,device,function,2);

	movzx	eax, WORD PTR _bus$[esp-4]
	movzx	ecx, WORD PTR _device$[esp-4]
	movzx	edx, WORD PTR _function$[esp-4]
	or	eax, -32768				; ffff8000H
	shl	eax, 5
	or	eax, ecx
	add	eax, eax
	add	eax, eax
	add	eax, eax
	or	eax, edx
	shl	eax, 8
	push	eax
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	add	esp, 12					; 0000000cH
	shr	eax, 16					; 00000010H

; 64   : 	// Register 00 => DeviceID(2b) VendorID(2b)
; 65   : 	return r0;
; 66   : }

	ret	0
?getDeviceID@@YAGGGG@Z ENDP				; getDeviceID
_TEXT	ENDS
PUBLIC	?getClassId@@YAGGGG@Z				; getClassId
; Function compile flags: /Ogtpy
;	COMDAT ?getClassId@@YAGGGG@Z
_TEXT	SEGMENT
_bus$ = 8						; size = 2
_device$ = 12						; size = 2
_function$ = 16						; size = 2
?getClassId@@YAGGGG@Z PROC				; getClassId, COMDAT

; 70   : 	int r0 = pciConfigReadWord(bus,device,function,0xA);

	movzx	eax, WORD PTR _bus$[esp-4]
	movzx	ecx, WORD PTR _device$[esp-4]
	movzx	edx, WORD PTR _function$[esp-4]
	shl	eax, 5
	or	eax, ecx
	add	eax, eax
	add	eax, eax
	add	eax, eax
	or	eax, edx
	shl	eax, 8
	or	eax, -2147483640			; 80000008H
	push	eax
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	shr	eax, 16					; 00000010H
	add	esp, 12					; 0000000cH

; 71   : 	return (r0 & ~0x00FF) >> 8;

	shr	eax, 8

; 72   : }

	ret	0
?getClassId@@YAGGGG@Z ENDP				; getClassId
_TEXT	ENDS
PUBLIC	?getSubClassId@@YAGGGG@Z			; getSubClassId
; Function compile flags: /Ogtpy
;	COMDAT ?getSubClassId@@YAGGGG@Z
_TEXT	SEGMENT
_bus$ = 8						; size = 2
_device$ = 12						; size = 2
_function$ = 16						; size = 2
?getSubClassId@@YAGGGG@Z PROC				; getSubClassId, COMDAT

; 76   : 	int r0 = pciConfigReadWord(bus,device,function,0xA);

	movzx	eax, WORD PTR _bus$[esp-4]
	movzx	ecx, WORD PTR _device$[esp-4]
	movzx	edx, WORD PTR _function$[esp-4]
	shl	eax, 5
	or	eax, ecx
	add	eax, eax
	add	eax, eax
	add	eax, eax
	or	eax, edx
	shl	eax, 8
	or	eax, -2147483640			; 80000008H
	push	eax
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	shr	eax, 16					; 00000010H
	add	esp, 12					; 0000000cH

; 77   : 	return (r0 & ~0xFF00);

	and	eax, -65281				; ffff00ffH

; 78   : }

	ret	0
?getSubClassId@@YAGGGG@Z ENDP				; getSubClassId
_TEXT	ENDS
PUBLIC	??_C@_0CG@KJDCIMEK@?6?5?5?5?5?5?5?5?5ClassId?$DN0x?$CFx?5SubclassId@ ; `string'
PUBLIC	??_C@_0ED@BAHLBCOH@?6PCI?3?5Bus?3?50x?$CFX?5Slot?3?50x?$CFx?5Funct@ ; `string'
PUBLIC	??_C@_0P@GELAMMA@?6PCI?5testing?4?4?$AA@	; `string'
PUBLIC	?PCI_test@@YAXXZ				; PCI_test
EXTRN	?DebugPrintf@@YAHPBDZZ:PROC			; DebugPrintf
;	COMDAT ??_C@_0CG@KJDCIMEK@?6?5?5?5?5?5?5?5?5ClassId?$DN0x?$CFx?5SubclassId@
CONST	SEGMENT
??_C@_0CG@KJDCIMEK@?6?5?5?5?5?5?5?5?5ClassId?$DN0x?$CFx?5SubclassId@ DB 0aH
	DB	'        ClassId=0x%x SubclassId=0x%x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@BAHLBCOH@?6PCI?3?5Bus?3?50x?$CFX?5Slot?3?50x?$CFx?5Funct@
CONST	SEGMENT
??_C@_0ED@BAHLBCOH@?6PCI?3?5Bus?3?50x?$CFX?5Slot?3?50x?$CFx?5Funct@ DB 0aH
	DB	'PCI: Bus: 0x%X Slot: 0x%x Function: 0x%x Vendor: 0x%X Device='
	DB	'0x%x', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GELAMMA@?6PCI?5testing?4?4?$AA@
CONST	SEGMENT
??_C@_0P@GELAMMA@?6PCI?5testing?4?4?$AA@ DB 0aH, 'PCI testing..', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?PCI_test@@YAXXZ
_TEXT	SEGMENT
_slot$2662 = -16					; size = 4
_bus$2658 = -12						; size = 4
tv404 = -8						; size = 4
tv408 = -4						; size = 4
?PCI_test@@YAXXZ PROC					; PCI_test, COMDAT

; 11   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 12   : 	DebugPrintf("\nPCI testing..");

	push	OFFSET ??_C@_0P@GELAMMA@?6PCI?5testing?4?4?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 4

; 13   : 	// Maximum PCI capacity: 256 bus each having at most 32 slots and each slots having at most 8 functions
; 14   : 	for(int bus = 0; bus < 256; bus++)

	mov	DWORD PTR _bus$2658[esp+32], 0
	npad	4
$LL35@PCI_test:
	movzx	eax, WORD PTR _bus$2658[esp+32]
	or	eax, -32768				; ffff8000H
	shl	eax, 5

; 15   : 	{
; 16   : 		for(int slot = 0; slot < 32; slot++)

	mov	DWORD PTR _slot$2662[esp+32], 0
	mov	DWORD PTR tv404[esp+32], eax
	jmp	SHORT $LN7@PCI_test
	npad	5
$LL36@PCI_test:

; 13   : 	// Maximum PCI capacity: 256 bus each having at most 32 slots and each slots having at most 8 functions
; 14   : 	for(int bus = 0; bus < 256; bus++)

	mov	eax, DWORD PTR tv404[esp+32]
$LN7@PCI_test:

; 15   : 	{
; 16   : 		for(int slot = 0; slot < 32; slot++)

	movzx	ecx, WORD PTR _slot$2662[esp+32]
	or	eax, ecx

; 21   : 				if(vendor == 0xFFFF) continue;

	add	eax, eax
	add	eax, eax
	xor	edi, edi
	add	eax, eax
	mov	DWORD PTR tv408[esp+32], eax
$LL37@PCI_test:

; 15   : 	{
; 16   : 		for(int slot = 0; slot < 32; slot++)

	mov	esi, DWORD PTR tv408[esp+32]
	movzx	ebx, di

; 19   : 			{
; 20   : 				unsigned short vendor = getVendorID(bus, slot, function);

	or	esi, ebx
	shl	esi, 8
	push	esi
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	movzx	ebp, ax

; 21   : 				if(vendor == 0xFFFF) continue;

	mov	ecx, 65535				; 0000ffffH
	add	esp, 12					; 0000000cH
	cmp	bp, cx
	je	$LN3@PCI_test

; 22   : 				unsigned short device = getDeviceID(bus, slot, function);

	push	esi
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW

; 23   : 				DebugPrintf("\nPCI: Bus: 0x%X Slot: 0x%x Function: 0x%x Vendor: 0x%X Device=0x%x", bus, slot,function, vendor, device);

	mov	esi, DWORD PTR _bus$2658[esp+44]
	shr	eax, 16					; 00000010H
	push	eax
	push	ebp
	mov	ebp, DWORD PTR _slot$2662[esp+52]
	push	edi
	push	ebp
	push	esi
	push	OFFSET ??_C@_0ED@BAHLBCOH@?6PCI?3?5Bus?3?50x?$CFX?5Slot?3?50x?$CFx?5Funct@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 24   : 				DebugPrintf("\n        ClassId=0x%x SubclassId=0x%x", getClassId(bus, slot, function), getSubClassId(bus, slot, function));

	movzx	esi, si
	shl	esi, 5
	movzx	eax, bp
	or	esi, eax
	add	esi, esi
	add	esi, esi
	add	esi, esi
	or	esi, ebx
	shl	esi, 8
	or	esi, -2147483640			; 80000008H
	push	esi
	push	3320					; 00000cf8H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	mov	ebx, eax
	push	esi
	push	3320					; 00000cf8H
	shr	ebx, 16					; 00000010H
	call	?outportW@@YAXGI@Z			; outportW
	push	3324					; 00000cfcH
	call	?inportW@@YAIG@Z			; inportW
	shr	eax, 16					; 00000010H
	movzx	ecx, bl
	mov	edx, eax
	push	ecx
	shr	edx, 8
	push	edx
	push	OFFSET ??_C@_0CG@KJDCIMEK@?6?5?5?5?5?5?5?5?5ClassId?$DN0x?$CFx?5SubclassId@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 72					; 00000048H
$LN3@PCI_test:

; 17   : 		{
; 18   : 			for(int function = 0; function < 8; function++)

	inc	edi
	cmp	edi, 8
	jl	$LL37@PCI_test

; 15   : 	{
; 16   : 		for(int slot = 0; slot < 32; slot++)

	mov	eax, DWORD PTR _slot$2662[esp+32]
	inc	eax
	mov	DWORD PTR _slot$2662[esp+32], eax
	cmp	eax, 32					; 00000020H
	jl	$LL36@PCI_test

; 13   : 	// Maximum PCI capacity: 256 bus each having at most 32 slots and each slots having at most 8 functions
; 14   : 	for(int bus = 0; bus < 256; bus++)

	mov	eax, DWORD PTR _bus$2658[esp+32]
	inc	eax
	mov	DWORD PTR _bus$2658[esp+32], eax
	cmp	eax, 256				; 00000100H
	jl	$LL35@PCI_test
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 25   : 			}
; 26   : 		}
; 27   : 	}
; 28   : }

	add	esp, 16					; 00000010H
	ret	0
?PCI_test@@YAXXZ ENDP					; PCI_test
_TEXT	ENDS
END
