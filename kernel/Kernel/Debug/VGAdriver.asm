; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\VGAdriver.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?VGA_height@@3IA				; VGA_height
PUBLIC	?savedPalette@@3PAUpalette_entry@@A		; savedPalette
PUBLIC	?__font@@3PADA					; __font
PUBLIC	?mode@@3UVIDEO_MODE@@A				; mode
PUBLIC	?VGA_address@@3PAEA				; VGA_address
PUBLIC	?VGA_width@@3IA					; VGA_width
PUBLIC	?VGA_bpp@@3IA					; VGA_bpp
PUBLIC	?vidmem@@3PADA					; vidmem
PUBLIC	?mode_320_200_256@@3PAEA			; mode_320_200_256
PUBLIC	?mode_80_25_text@@3PAEA				; mode_80_25_text
PUBLIC	?mode_640_480_16@@3PAEA				; mode_640_480_16
_BSS	SEGMENT
?VGA_height@@3IA DD 01H DUP (?)				; VGA_height
?savedPalette@@3PAUpalette_entry@@A DB 0300H DUP (?)	; savedPalette
?__font@@3PADA DD 01H DUP (?)				; __font
?mode@@3UVIDEO_MODE@@A DB 012H DUP (?)			; mode
	ALIGN	4

?VGA_address@@3PAEA DD 01H DUP (?)			; VGA_address
?VGA_width@@3IA DD 01H DUP (?)				; VGA_width
?VGA_bpp@@3IA DD 01H DUP (?)				; VGA_bpp
?vidmem@@3PADA DD 01H DUP (?)				; vidmem
__isVGA	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?mode_320_200_256@@3PAEA DB 063H			; mode_320_200_256
	DB	03H
	DB	01H
	DB	0fH
	DB	00H
	DB	0eH
	DB	05fH
	DB	04fH
	DB	050H
	DB	082H
	DB	054H
	DB	080H
	DB	0bfH
	DB	01fH
	DB	00H
	DB	041H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	09cH
	DB	0eH
	DB	08fH
	DB	028H
	DB	040H
	DB	096H
	DB	0b9H
	DB	0a3H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	040H
	DB	05H
	DB	0fH
	DB	0ffH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	041H
	DB	00H
	DB	0fH
	DB	00H
	DB	00H
	ORG $+3
?mode_80_25_text@@3PAEA DB 067H				; mode_80_25_text
	DB	03H
	DB	00H
	DB	03H
	DB	00H
	DB	02H
	DB	05fH
	DB	04fH
	DB	050H
	DB	082H
	DB	055H
	DB	081H
	DB	0bfH
	DB	01fH
	DB	00H
	DB	04fH
	DB	0dH
	DB	0eH
	DB	00H
	DB	00H
	DB	00H
	DB	050H
	DB	09cH
	DB	0eH
	DB	08fH
	DB	028H
	DB	01fH
	DB	096H
	DB	0b9H
	DB	0a3H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	0eH
	DB	00H
	DB	0ffH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	014H
	DB	07H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	0cH
	DB	00H
	DB	0fH
	DB	08H
	DB	00H
	ORG $+3
?mode_640_480_16@@3PAEA DB 0e3H				; mode_640_480_16
	DB	03H
	DB	01H
	DB	08H
	DB	00H
	DB	06H
	DB	05fH
	DB	04fH
	DB	050H
	DB	082H
	DB	054H
	DB	080H
	DB	0bH
	DB	03eH
	DB	00H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0eaH
	DB	0cH
	DB	0dfH
	DB	028H
	DB	00H
	DB	0e7H
	DB	04H
	DB	0e3H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	00H
	DB	05H
	DB	0fH
	DB	0ffH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	014H
	DB	07H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	01H
	DB	00H
	DB	0fH
	DB	00H
	DB	00H
	ORG $+3
_g_8x8_font DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07eH
	DB	081H
	DB	0a5H
	DB	081H
	DB	0bdH
	DB	099H
	DB	081H
	DB	07eH
	DB	07eH
	DB	0ffH
	DB	0dbH
	DB	0ffH
	DB	0c3H
	DB	0e7H
	DB	0ffH
	DB	07eH
	DB	06cH
	DB	0feH
	DB	0feH
	DB	0feH
	DB	07cH
	DB	038H
	DB	010H
	DB	00H
	DB	010H
	DB	038H
	DB	07cH
	DB	0feH
	DB	07cH
	DB	038H
	DB	010H
	DB	00H
	DB	038H
	DB	07cH
	DB	038H
	DB	0feH
	DB	0feH
	DB	092H
	DB	010H
	DB	07cH
	DB	00H
	DB	010H
	DB	038H
	DB	07cH
	DB	0feH
	DB	07cH
	DB	038H
	DB	07cH
	DB	00H
	DB	00H
	DB	018H
	DB	03cH
	DB	03cH
	DB	018H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0e7H
	DB	0c3H
	DB	0c3H
	DB	0e7H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	03cH
	DB	066H
	DB	042H
	DB	042H
	DB	066H
	DB	03cH
	DB	00H
	DB	0ffH
	DB	0c3H
	DB	099H
	DB	0bdH
	DB	0bdH
	DB	099H
	DB	0c3H
	DB	0ffH
	DB	0fH
	DB	07H
	DB	0fH
	DB	07dH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	03cH
	DB	066H
	DB	066H
	DB	066H
	DB	03cH
	DB	018H
	DB	07eH
	DB	018H
	DB	03fH
	DB	033H
	DB	03fH
	DB	030H
	DB	030H
	DB	070H
	DB	0f0H
	DB	0e0H
	DB	07fH
	DB	063H
	DB	07fH
	DB	063H
	DB	063H
	DB	067H
	DB	0e6H
	DB	0c0H
	DB	099H
	DB	05aH
	DB	03cH
	DB	0e7H
	DB	0e7H
	DB	03cH
	DB	05aH
	DB	099H
	DB	080H
	DB	0e0H
	DB	0f8H
	DB	0feH
	DB	0f8H
	DB	0e0H
	DB	080H
	DB	00H
	DB	02H
	DB	0eH
	DB	03eH
	DB	0feH
	DB	03eH
	DB	0eH
	DB	02H
	DB	00H
	DB	018H
	DB	03cH
	DB	07eH
	DB	018H
	DB	018H
	DB	07eH
	DB	03cH
	DB	018H
	DB	066H
	DB	066H
	DB	066H
	DB	066H
	DB	066H
	DB	00H
	DB	066H
	DB	00H
	DB	07fH
	DB	0dbH
	DB	0dbH
	DB	07bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	00H
	DB	03eH
	DB	063H
	DB	038H
	DB	06cH
	DB	06cH
	DB	038H
	DB	086H
	DB	0fcH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07eH
	DB	07eH
	DB	07eH
	DB	00H
	DB	018H
	DB	03cH
	DB	07eH
	DB	018H
	DB	07eH
	DB	03cH
	DB	018H
	DB	0ffH
	DB	018H
	DB	03cH
	DB	07eH
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	07eH
	DB	03cH
	DB	018H
	DB	00H
	DB	00H
	DB	018H
	DB	0cH
	DB	0feH
	DB	0cH
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	030H
	DB	060H
	DB	0feH
	DB	060H
	DB	030H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0c0H
	DB	0c0H
	DB	0c0H
	DB	0feH
	DB	00H
	DB	00H
	DB	00H
	DB	024H
	DB	066H
	DB	0ffH
	DB	066H
	DB	024H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	03cH
	DB	07eH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	07eH
	DB	03cH
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	03cH
	DB	03cH
	DB	018H
	DB	018H
	DB	00H
	DB	018H
	DB	00H
	DB	06cH
	DB	06cH
	DB	06cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06cH
	DB	06cH
	DB	0feH
	DB	06cH
	DB	0feH
	DB	06cH
	DB	06cH
	DB	00H
	DB	018H
	DB	07eH
	DB	0c0H
	DB	07cH
	DB	06H
	DB	0fcH
	DB	018H
	DB	00H
	DB	00H
	DB	0c6H
	DB	0ccH
	DB	018H
	DB	030H
	DB	066H
	DB	0c6H
	DB	00H
	DB	038H
	DB	06cH
	DB	038H
	DB	076H
	DB	0dcH
	DB	0ccH
	DB	076H
	DB	00H
	DB	030H
	DB	030H
	DB	060H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	030H
	DB	060H
	DB	060H
	DB	060H
	DB	030H
	DB	018H
	DB	00H
	DB	060H
	DB	030H
	DB	018H
	DB	018H
	DB	018H
	DB	030H
	DB	060H
	DB	00H
	DB	00H
	DB	066H
	DB	03cH
	DB	0ffH
	DB	03cH
	DB	066H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	07eH
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	030H
	DB	00H
	DB	00H
	DB	00H
	DB	07eH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	00H
	DB	06H
	DB	0cH
	DB	018H
	DB	030H
	DB	060H
	DB	0c0H
	DB	080H
	DB	00H
	DB	07cH
	DB	0ceH
	DB	0deH
	DB	0f6H
	DB	0e6H
	DB	0c6H
	DB	07cH
	DB	00H
	DB	030H
	DB	070H
	DB	030H
	DB	030H
	DB	030H
	DB	030H
	DB	0fcH
	DB	00H
	DB	078H
	DB	0ccH
	DB	0cH
	DB	038H
	DB	060H
	DB	0ccH
	DB	0fcH
	DB	00H
	DB	078H
	DB	0ccH
	DB	0cH
	DB	038H
	DB	0cH
	DB	0ccH
	DB	078H
	DB	00H
	DB	01cH
	DB	03cH
	DB	06cH
	DB	0ccH
	DB	0feH
	DB	0cH
	DB	01eH
	DB	00H
	DB	0fcH
	DB	0c0H
	DB	0f8H
	DB	0cH
	DB	0cH
	DB	0ccH
	DB	078H
	DB	00H
	DB	038H
	DB	060H
	DB	0c0H
	DB	0f8H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	0fcH
	DB	0ccH
	DB	0cH
	DB	018H
	DB	030H
	DB	030H
	DB	030H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	07cH
	DB	0cH
	DB	018H
	DB	070H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	030H
	DB	018H
	DB	030H
	DB	060H
	DB	0c0H
	DB	060H
	DB	030H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	07eH
	DB	00H
	DB	07eH
	DB	00H
	DB	00H
	DB	00H
	DB	060H
	DB	030H
	DB	018H
	DB	0cH
	DB	018H
	DB	030H
	DB	060H
	DB	00H
	DB	03cH
	DB	066H
	DB	0cH
	DB	018H
	DB	018H
	DB	00H
	DB	018H
	DB	00H
	DB	07cH
	DB	0c6H
	DB	0deH
	DB	0deH
	DB	0dcH
	DB	0c0H
	DB	07cH
	DB	00H
	DB	030H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	0fcH
	DB	0ccH
	DB	0ccH
	DB	00H
	DB	0fcH
	DB	066H
	DB	066H
	DB	07cH
	DB	066H
	DB	066H
	DB	0fcH
	DB	00H
	DB	03cH
	DB	066H
	DB	0c0H
	DB	0c0H
	DB	0c0H
	DB	066H
	DB	03cH
	DB	00H
	DB	0f8H
	DB	06cH
	DB	066H
	DB	066H
	DB	066H
	DB	06cH
	DB	0f8H
	DB	00H
	DB	0feH
	DB	062H
	DB	068H
	DB	078H
	DB	068H
	DB	062H
	DB	0feH
	DB	00H
	DB	0feH
	DB	062H
	DB	068H
	DB	078H
	DB	068H
	DB	060H
	DB	0f0H
	DB	00H
	DB	03cH
	DB	066H
	DB	0c0H
	DB	0c0H
	DB	0ceH
	DB	066H
	DB	03aH
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0fcH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	00H
	DB	078H
	DB	030H
	DB	030H
	DB	030H
	DB	030H
	DB	030H
	DB	078H
	DB	00H
	DB	01eH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	0e6H
	DB	066H
	DB	06cH
	DB	078H
	DB	06cH
	DB	066H
	DB	0e6H
	DB	00H
	DB	0f0H
	DB	060H
	DB	060H
	DB	060H
	DB	062H
	DB	066H
	DB	0feH
	DB	00H
	DB	0c6H
	DB	0eeH
	DB	0feH
	DB	0feH
	DB	0d6H
	DB	0c6H
	DB	0c6H
	DB	00H
	DB	0c6H
	DB	0e6H
	DB	0f6H
	DB	0deH
	DB	0ceH
	DB	0c6H
	DB	0c6H
	DB	00H
	DB	038H
	DB	06cH
	DB	0c6H
	DB	0c6H
	DB	0c6H
	DB	06cH
	DB	038H
	DB	00H
	DB	0fcH
	DB	066H
	DB	066H
	DB	07cH
	DB	060H
	DB	060H
	DB	0f0H
	DB	00H
	DB	07cH
	DB	0c6H
	DB	0c6H
	DB	0c6H
	DB	0d6H
	DB	07cH
	DB	0eH
	DB	00H
	DB	0fcH
	DB	066H
	DB	066H
	DB	07cH
	DB	06cH
	DB	066H
	DB	0e6H
	DB	00H
	DB	07cH
	DB	0c6H
	DB	0e0H
	DB	078H
	DB	0eH
	DB	0c6H
	DB	07cH
	DB	00H
	DB	0fcH
	DB	0b4H
	DB	030H
	DB	030H
	DB	030H
	DB	030H
	DB	078H
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0fcH
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	030H
	DB	00H
	DB	0c6H
	DB	0c6H
	DB	0c6H
	DB	0c6H
	DB	0d6H
	DB	0feH
	DB	06cH
	DB	00H
	DB	0c6H
	DB	0c6H
	DB	06cH
	DB	038H
	DB	06cH
	DB	0c6H
	DB	0c6H
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	030H
	DB	030H
	DB	078H
	DB	00H
	DB	0feH
	DB	0c6H
	DB	08cH
	DB	018H
	DB	032H
	DB	066H
	DB	0feH
	DB	00H
	DB	078H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	078H
	DB	00H
	DB	0c0H
	DB	060H
	DB	030H
	DB	018H
	DB	0cH
	DB	06H
	DB	02H
	DB	00H
	DB	078H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	078H
	DB	00H
	DB	010H
	DB	038H
	DB	06cH
	DB	0c6H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	030H
	DB	030H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	078H
	DB	0cH
	DB	07cH
	DB	0ccH
	DB	076H
	DB	00H
	DB	0e0H
	DB	060H
	DB	060H
	DB	07cH
	DB	066H
	DB	066H
	DB	0dcH
	DB	00H
	DB	00H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0c0H
	DB	0ccH
	DB	078H
	DB	00H
	DB	01cH
	DB	0cH
	DB	0cH
	DB	07cH
	DB	0ccH
	DB	0ccH
	DB	076H
	DB	00H
	DB	00H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0fcH
	DB	0c0H
	DB	078H
	DB	00H
	DB	038H
	DB	06cH
	DB	064H
	DB	0f0H
	DB	060H
	DB	060H
	DB	0f0H
	DB	00H
	DB	00H
	DB	00H
	DB	076H
	DB	0ccH
	DB	0ccH
	DB	07cH
	DB	0cH
	DB	0f8H
	DB	0e0H
	DB	060H
	DB	06cH
	DB	076H
	DB	066H
	DB	066H
	DB	0e6H
	DB	00H
	DB	030H
	DB	00H
	DB	070H
	DB	030H
	DB	030H
	DB	030H
	DB	078H
	DB	00H
	DB	0cH
	DB	00H
	DB	01cH
	DB	0cH
	DB	0cH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	0e0H
	DB	060H
	DB	066H
	DB	06cH
	DB	078H
	DB	06cH
	DB	0e6H
	DB	00H
	DB	070H
	DB	030H
	DB	030H
	DB	030H
	DB	030H
	DB	030H
	DB	078H
	DB	00H
	DB	00H
	DB	00H
	DB	0ccH
	DB	0feH
	DB	0feH
	DB	0d6H
	DB	0d6H
	DB	00H
	DB	00H
	DB	00H
	DB	0b8H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	00H
	DB	00H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	00H
	DB	00H
	DB	0dcH
	DB	066H
	DB	066H
	DB	07cH
	DB	060H
	DB	0f0H
	DB	00H
	DB	00H
	DB	076H
	DB	0ccH
	DB	0ccH
	DB	07cH
	DB	0cH
	DB	01eH
	DB	00H
	DB	00H
	DB	0dcH
	DB	076H
	DB	062H
	DB	060H
	DB	0f0H
	DB	00H
	DB	00H
	DB	00H
	DB	07cH
	DB	0c0H
	DB	070H
	DB	01cH
	DB	0f8H
	DB	00H
	DB	010H
	DB	030H
	DB	0fcH
	DB	030H
	DB	030H
	DB	034H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	076H
	DB	00H
	DB	00H
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	030H
	DB	00H
	DB	00H
	DB	00H
	DB	0c6H
	DB	0c6H
	DB	0d6H
	DB	0feH
	DB	06cH
	DB	00H
	DB	00H
	DB	00H
	DB	0c6H
	DB	06cH
	DB	038H
	DB	06cH
	DB	0c6H
	DB	00H
	DB	00H
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	07cH
	DB	0cH
	DB	0f8H
	DB	00H
	DB	00H
	DB	0fcH
	DB	098H
	DB	030H
	DB	064H
	DB	0fcH
	DB	00H
	DB	01cH
	DB	030H
	DB	030H
	DB	0e0H
	DB	030H
	DB	030H
	DB	01cH
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	0e0H
	DB	030H
	DB	030H
	DB	01cH
	DB	030H
	DB	030H
	DB	0e0H
	DB	00H
	DB	076H
	DB	0dcH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	038H
	DB	06cH
	DB	0c6H
	DB	0c6H
	DB	0feH
	DB	00H
	DB	07cH
	DB	0c6H
	DB	0c0H
	DB	0c6H
	DB	07cH
	DB	0cH
	DB	06H
	DB	07cH
	DB	00H
	DB	0ccH
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	076H
	DB	00H
	DB	01cH
	DB	00H
	DB	078H
	DB	0ccH
	DB	0fcH
	DB	0c0H
	DB	078H
	DB	00H
	DB	07eH
	DB	081H
	DB	03cH
	DB	06H
	DB	03eH
	DB	066H
	DB	03bH
	DB	00H
	DB	0ccH
	DB	00H
	DB	078H
	DB	0cH
	DB	07cH
	DB	0ccH
	DB	076H
	DB	00H
	DB	0e0H
	DB	00H
	DB	078H
	DB	0cH
	DB	07cH
	DB	0ccH
	DB	076H
	DB	00H
	DB	030H
	DB	030H
	DB	078H
	DB	0cH
	DB	07cH
	DB	0ccH
	DB	076H
	DB	00H
	DB	00H
	DB	00H
	DB	07cH
	DB	0c6H
	DB	0c0H
	DB	078H
	DB	0cH
	DB	038H
	DB	07eH
	DB	081H
	DB	03cH
	DB	066H
	DB	07eH
	DB	060H
	DB	03cH
	DB	00H
	DB	0ccH
	DB	00H
	DB	078H
	DB	0ccH
	DB	0fcH
	DB	0c0H
	DB	078H
	DB	00H
	DB	0e0H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0fcH
	DB	0c0H
	DB	078H
	DB	00H
	DB	0ccH
	DB	00H
	DB	070H
	DB	030H
	DB	030H
	DB	030H
	DB	078H
	DB	00H
	DB	07cH
	DB	082H
	DB	038H
	DB	018H
	DB	018H
	DB	018H
	DB	03cH
	DB	00H
	DB	0e0H
	DB	00H
	DB	070H
	DB	030H
	DB	030H
	DB	030H
	DB	078H
	DB	00H
	DB	0c6H
	DB	010H
	DB	07cH
	DB	0c6H
	DB	0feH
	DB	0c6H
	DB	0c6H
	DB	00H
	DB	030H
	DB	030H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0fcH
	DB	0ccH
	DB	00H
	DB	01cH
	DB	00H
	DB	0fcH
	DB	060H
	DB	078H
	DB	060H
	DB	0fcH
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	0cH
	DB	07fH
	DB	0ccH
	DB	07fH
	DB	00H
	DB	03eH
	DB	06cH
	DB	0ccH
	DB	0feH
	DB	0ccH
	DB	0ccH
	DB	0ceH
	DB	00H
	DB	078H
	DB	084H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	00H
	DB	0ccH
	DB	00H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	00H
	DB	0e0H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	078H
	DB	084H
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	076H
	DB	00H
	DB	00H
	DB	0e0H
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	076H
	DB	00H
	DB	00H
	DB	0ccH
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	07cH
	DB	0cH
	DB	0f8H
	DB	0c3H
	DB	018H
	DB	03cH
	DB	066H
	DB	066H
	DB	03cH
	DB	018H
	DB	00H
	DB	0ccH
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	018H
	DB	018H
	DB	07eH
	DB	0c0H
	DB	0c0H
	DB	07eH
	DB	018H
	DB	018H
	DB	038H
	DB	06cH
	DB	064H
	DB	0f0H
	DB	060H
	DB	0e6H
	DB	0fcH
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	030H
	DB	0fcH
	DB	030H
	DB	0fcH
	DB	030H
	DB	0f8H
	DB	0ccH
	DB	0ccH
	DB	0faH
	DB	0c6H
	DB	0cfH
	DB	0c6H
	DB	0c3H
	DB	0eH
	DB	01bH
	DB	018H
	DB	03cH
	DB	018H
	DB	018H
	DB	0d8H
	DB	070H
	DB	01cH
	DB	00H
	DB	078H
	DB	0cH
	DB	07cH
	DB	0ccH
	DB	076H
	DB	00H
	DB	038H
	DB	00H
	DB	070H
	DB	030H
	DB	030H
	DB	030H
	DB	078H
	DB	00H
	DB	00H
	DB	01cH
	DB	00H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	00H
	DB	01cH
	DB	00H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	076H
	DB	00H
	DB	00H
	DB	0f8H
	DB	00H
	DB	0b8H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	00H
	DB	0fcH
	DB	00H
	DB	0ccH
	DB	0ecH
	DB	0fcH
	DB	0dcH
	DB	0ccH
	DB	00H
	DB	03cH
	DB	06cH
	DB	06cH
	DB	03eH
	DB	00H
	DB	07eH
	DB	00H
	DB	00H
	DB	038H
	DB	06cH
	DB	06cH
	DB	038H
	DB	00H
	DB	07cH
	DB	00H
	DB	00H
	DB	018H
	DB	00H
	DB	018H
	DB	018H
	DB	030H
	DB	066H
	DB	03cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fcH
	DB	0c0H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fcH
	DB	0cH
	DB	0cH
	DB	00H
	DB	00H
	DB	0c6H
	DB	0ccH
	DB	0d8H
	DB	036H
	DB	06bH
	DB	0c2H
	DB	084H
	DB	0fH
	DB	0c3H
	DB	0c6H
	DB	0ccH
	DB	0dbH
	DB	037H
	DB	06dH
	DB	0cfH
	DB	03H
	DB	018H
	DB	00H
	DB	018H
	DB	018H
	DB	03cH
	DB	03cH
	DB	018H
	DB	00H
	DB	00H
	DB	033H
	DB	066H
	DB	0ccH
	DB	066H
	DB	033H
	DB	00H
	DB	00H
	DB	00H
	DB	0ccH
	DB	066H
	DB	033H
	DB	066H
	DB	0ccH
	DB	00H
	DB	00H
	DB	022H
	DB	088H
	DB	022H
	DB	088H
	DB	022H
	DB	088H
	DB	022H
	DB	088H
	DB	055H
	DB	0aaH
	DB	055H
	DB	0aaH
	DB	055H
	DB	0aaH
	DB	055H
	DB	0aaH
	DB	0dbH
	DB	0f6H
	DB	0dbH
	DB	06fH
	DB	0dbH
	DB	07eH
	DB	0d7H
	DB	0edH
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	0f8H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	0f8H
	DB	018H
	DB	0f8H
	DB	018H
	DB	018H
	DB	018H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	0f6H
	DB	036H
	DB	036H
	DB	036H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0feH
	DB	036H
	DB	036H
	DB	036H
	DB	00H
	DB	00H
	DB	0f8H
	DB	018H
	DB	0f8H
	DB	018H
	DB	018H
	DB	018H
	DB	036H
	DB	036H
	DB	0f6H
	DB	06H
	DB	0f6H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	00H
	DB	00H
	DB	0feH
	DB	06H
	DB	0f6H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	0f6H
	DB	06H
	DB	0feH
	DB	00H
	DB	00H
	DB	00H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	0feH
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	0f8H
	DB	018H
	DB	0f8H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0f8H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	01fH
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	01fH
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	0ffH
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	01fH
	DB	018H
	DB	01fH
	DB	018H
	DB	018H
	DB	018H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	037H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	037H
	DB	030H
	DB	03fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03fH
	DB	030H
	DB	037H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	0f7H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0f7H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	037H
	DB	030H
	DB	037H
	DB	036H
	DB	036H
	DB	036H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	036H
	DB	036H
	DB	0f7H
	DB	00H
	DB	0f7H
	DB	036H
	DB	036H
	DB	036H
	DB	018H
	DB	018H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	03fH
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	01fH
	DB	018H
	DB	01fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01fH
	DB	018H
	DB	01fH
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03fH
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	036H
	DB	0ffH
	DB	036H
	DB	036H
	DB	036H
	DB	018H
	DB	018H
	DB	0ffH
	DB	018H
	DB	0ffH
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	0f8H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01fH
	DB	018H
	DB	018H
	DB	018H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	076H
	DB	0dcH
	DB	0c8H
	DB	0dcH
	DB	076H
	DB	00H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0f8H
	DB	0ccH
	DB	0f8H
	DB	0c0H
	DB	0c0H
	DB	00H
	DB	0fcH
	DB	0ccH
	DB	0c0H
	DB	0c0H
	DB	0c0H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	0feH
	DB	06cH
	DB	06cH
	DB	06cH
	DB	06cH
	DB	00H
	DB	0fcH
	DB	0ccH
	DB	060H
	DB	030H
	DB	060H
	DB	0ccH
	DB	0fcH
	DB	00H
	DB	00H
	DB	00H
	DB	07eH
	DB	0d8H
	DB	0d8H
	DB	0d8H
	DB	070H
	DB	00H
	DB	00H
	DB	066H
	DB	066H
	DB	066H
	DB	066H
	DB	07cH
	DB	060H
	DB	0c0H
	DB	00H
	DB	076H
	DB	0dcH
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	0fcH
	DB	030H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	030H
	DB	0fcH
	DB	038H
	DB	06cH
	DB	0c6H
	DB	0feH
	DB	0c6H
	DB	06cH
	DB	038H
	DB	00H
	DB	038H
	DB	06cH
	DB	0c6H
	DB	0c6H
	DB	06cH
	DB	06cH
	DB	0eeH
	DB	00H
	DB	01cH
	DB	030H
	DB	018H
	DB	07cH
	DB	0ccH
	DB	0ccH
	DB	078H
	DB	00H
	DB	00H
	DB	00H
	DB	07eH
	DB	0dbH
	DB	0dbH
	DB	07eH
	DB	00H
	DB	00H
	DB	06H
	DB	0cH
	DB	07eH
	DB	0dbH
	DB	0dbH
	DB	07eH
	DB	060H
	DB	0c0H
	DB	038H
	DB	060H
	DB	0c0H
	DB	0f8H
	DB	0c0H
	DB	060H
	DB	038H
	DB	00H
	DB	078H
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	0ccH
	DB	00H
	DB	00H
	DB	07eH
	DB	00H
	DB	07eH
	DB	00H
	DB	07eH
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	07eH
	DB	018H
	DB	018H
	DB	00H
	DB	07eH
	DB	00H
	DB	060H
	DB	030H
	DB	018H
	DB	030H
	DB	060H
	DB	00H
	DB	0fcH
	DB	00H
	DB	018H
	DB	030H
	DB	060H
	DB	030H
	DB	018H
	DB	00H
	DB	0fcH
	DB	00H
	DB	0eH
	DB	01bH
	DB	01bH
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	0d8H
	DB	0d8H
	DB	070H
	DB	018H
	DB	018H
	DB	00H
	DB	07eH
	DB	00H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	076H
	DB	0dcH
	DB	00H
	DB	076H
	DB	0dcH
	DB	00H
	DB	00H
	DB	038H
	DB	06cH
	DB	06cH
	DB	038H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0ecH
	DB	06cH
	DB	03cH
	DB	01cH
	DB	058H
	DB	06cH
	DB	06cH
	DB	06cH
	DB	06cH
	DB	00H
	DB	00H
	DB	00H
	DB	070H
	DB	098H
	DB	030H
	DB	060H
	DB	0f8H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03cH
	DB	03cH
	DB	03cH
	DB	03cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
PUBLIC	?isVGA@@YA_NXZ					; isVGA
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\vgadriver.cpp
;	COMDAT ?isVGA@@YA_NXZ
_TEXT	SEGMENT
?isVGA@@YA_NXZ PROC					; isVGA, COMDAT

; 39   : bool isVGA() { return _isVGA; }

	mov	al, BYTE PTR __isVGA
	ret	0
?isVGA@@YA_NXZ ENDP					; isVGA
_TEXT	ENDS
PUBLIC	?read_registers@@YAXPAE@Z			; read_registers
EXTRN	?outport@@YAXGE@Z:PROC				; outport
EXTRN	?inport@@YAEG@Z:PROC				; inport
; Function compile flags: /Ogtpy
;	COMDAT ?read_registers@@YAXPAE@Z
_TEXT	SEGMENT
_regs$ = 8						; size = 4
?read_registers@@YAXPAE@Z PROC				; read_registers, COMDAT

; 237  : {

	push	esi
	push	edi

; 238  : 	unsigned i;
; 239  : /* read MISCELLANEOUS reg */
; 240  : 	*regs = inport(VGA_MISC_READ);

	push	972					; 000003ccH
	call	?inport@@YAEG@Z				; inport
	mov	esi, DWORD PTR _regs$[esp+8]
	mov	BYTE PTR [esi], al
	add	esp, 4

; 241  : 	regs++;

	inc	esi

; 242  : /* read SEQUENCER regs */
; 243  : 	for(i = 0; i < VGA_NUM_SEQ_REGS; i++)

	xor	edi, edi
	npad	8
$LL12@read_regis:

; 244  : 	{
; 245  : 		outport(VGA_SEQ_INDEX, i);

	push	edi
	push	964					; 000003c4H
	call	?outport@@YAXGE@Z			; outport

; 246  : 		*regs = inport(VGA_SEQ_DATA);

	push	965					; 000003c5H
	call	?inport@@YAEG@Z				; inport
	mov	BYTE PTR [esi], al
	inc	edi
	add	esp, 12					; 0000000cH

; 247  : 		regs++;

	inc	esi
	cmp	edi, 5
	jb	SHORT $LL12@read_regis

; 248  : 	}
; 249  : /* read CRTC regs */
; 250  : 	for(i = 0; i < VGA_NUM_CRTC_REGS; i++)

	xor	edi, edi
$LL9@read_regis:

; 251  : 	{
; 252  : 		outport(VGA_CRTC_INDEX, i);

	push	edi
	push	980					; 000003d4H
	call	?outport@@YAXGE@Z			; outport

; 253  : 		*regs = inport(VGA_CRTC_DATA);

	push	981					; 000003d5H
	call	?inport@@YAEG@Z				; inport
	mov	BYTE PTR [esi], al
	inc	edi
	add	esp, 12					; 0000000cH

; 254  : 		regs++;

	inc	esi
	cmp	edi, 25					; 00000019H
	jb	SHORT $LL9@read_regis

; 255  : 	}
; 256  : /* read GRAPHICS CONTROLLER regs */
; 257  : 	for(i = 0; i < VGA_NUM_GC_REGS; i++)

	xor	edi, edi
	npad	10
$LL6@read_regis:

; 258  : 	{
; 259  : 		outport(VGA_GC_INDEX, i);

	push	edi
	push	974					; 000003ceH
	call	?outport@@YAXGE@Z			; outport

; 260  : 		*regs = inport(VGA_GC_DATA);

	push	975					; 000003cfH
	call	?inport@@YAEG@Z				; inport
	mov	BYTE PTR [esi], al
	inc	edi
	add	esp, 12					; 0000000cH

; 261  : 		regs++;

	inc	esi
	cmp	edi, 9
	jb	SHORT $LL6@read_regis

; 262  : 	}
; 263  : /* read ATTRIBUTE CONTROLLER regs */
; 264  : 	for(i = 0; i < VGA_NUM_AC_REGS; i++)

	xor	edi, edi
$LL3@read_regis:

; 265  : 	{
; 266  : 		(void)inport(VGA_INSTAT_READ);

	push	986					; 000003daH
	call	?inport@@YAEG@Z				; inport

; 267  : 		outport(VGA_AC_INDEX, i);

	push	edi
	push	960					; 000003c0H
	call	?outport@@YAXGE@Z			; outport

; 268  : 		*regs = inport(VGA_AC_READ);

	push	961					; 000003c1H
	call	?inport@@YAEG@Z				; inport
	mov	BYTE PTR [esi], al
	inc	edi
	add	esp, 16					; 00000010H

; 269  : 		regs++;

	inc	esi
	cmp	edi, 21					; 00000015H
	jb	SHORT $LL3@read_regis

; 270  : 	}
; 271  : 	/* lock 16-color palette and unblank display */
; 272  : 		(void)inport(VGA_INSTAT_READ);

	push	986					; 000003daH
	call	?inport@@YAEG@Z				; inport

; 273  : 		outport(VGA_AC_INDEX, 0x20);

	push	32					; 00000020H
	push	960					; 000003c0H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 274  : }

	ret	0
?read_registers@@YAXPAE@Z ENDP				; read_registers
_TEXT	ENDS
PUBLIC	?savePalette@@YAXPAUpalette_entry@@@Z		; savePalette
; Function compile flags: /Ogtpy
;	COMDAT ?savePalette@@YAXPAUpalette_entry@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?savePalette@@YAXPAUpalette_entry@@@Z PROC		; savePalette, COMDAT

; 277  : {

	push	esi
	push	edi

; 278  : 	outport(0x3C7, 0x00);

	push	0
	push	967					; 000003c7H
	call	?outport@@YAXGE@Z			; outport
	mov	esi, DWORD PTR _p$[esp+12]
	add	esp, 8
	add	esi, 2
	mov	edi, 256				; 00000100H
	npad	3
$LL3@savePalett:

; 279  : 	for(int i = 0; i < 256; i++)
; 280  : 	{
; 281  : 		p[i].R = inport(0x3C9);

	push	969					; 000003c9H
	call	?inport@@YAEG@Z				; inport

; 282  : 		p[i].G = inport(0x3C9);

	push	969					; 000003c9H
	mov	BYTE PTR [esi-2], al
	call	?inport@@YAEG@Z				; inport

; 283  : 		p[i].B = inport(0x3C9);

	push	969					; 000003c9H
	mov	BYTE PTR [esi-1], al
	call	?inport@@YAEG@Z				; inport
	mov	BYTE PTR [esi], al
	add	esp, 12					; 0000000cH
	add	esi, 3
	dec	edi
	jne	SHORT $LL3@savePalett

; 284  : 	}
; 285  : }

	pop	edi
	pop	esi
	ret	0
?savePalette@@YAXPAUpalette_entry@@@Z ENDP		; savePalette
_TEXT	ENDS
PUBLIC	?VGA_map_color@@YAXDDDD@Z			; VGA_map_color
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_map_color@@YAXDDDD@Z
_TEXT	SEGMENT
_index$ = 8						; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?VGA_map_color@@YAXDDDD@Z PROC				; VGA_map_color, COMDAT

; 297  : 	outport(0x3c8,index);

	mov	eax, DWORD PTR _index$[esp-4]
	push	eax
	push	968					; 000003c8H
	call	?outport@@YAXGE@Z			; outport

; 298  : 	outport(0x3c9,r);

	mov	ecx, DWORD PTR _r$[esp+4]
	push	ecx
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport

; 299  : 	outport(0x3c9,g);

	mov	edx, DWORD PTR _g$[esp+12]
	push	edx
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport

; 300  : 	outport(0x3c9,b);

	mov	eax, DWORD PTR _b$[esp+20]
	push	eax
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 32					; 00000020H

; 301  : }

	ret	0
?VGA_map_color@@YAXDDDD@Z ENDP				; VGA_map_color
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?set_plane@@YAXI@Z
_TEXT	SEGMENT
?set_plane@@YAXI@Z PROC					; set_plane, COMDAT
; _p$ = eax

; 565  : {

	push	esi
	mov	esi, eax

; 566  : 	unsigned char pmask;
; 567  : 
; 568  : 	p &= 3;
; 569  : 	pmask = 1 << p;
; 570  : /* set read plane */
; 571  : 	outport(VGA_GC_INDEX, 4);

	push	4
	push	974					; 000003ceH
	and	esi, 3
	call	?outport@@YAXGE@Z			; outport

; 572  : 	outport(VGA_GC_DATA, p);

	push	esi
	push	975					; 000003cfH
	call	?outport@@YAXGE@Z			; outport

; 573  : /* set write plane */
; 574  : 	outport(VGA_SEQ_INDEX, 2);

	push	2
	push	964					; 000003c4H
	call	?outport@@YAXGE@Z			; outport
	mov	al, 1
	mov	ecx, esi
	shl	al, cl

; 575  : 	outport(VGA_SEQ_DATA, pmask);

	movzx	ecx, al
	push	ecx
	push	965					; 000003c5H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 32					; 00000020H
	pop	esi

; 576  : }

	ret	0
?set_plane@@YAXI@Z ENDP					; set_plane
_TEXT	ENDS
PUBLIC	?reverseBits@@YAID@Z				; reverseBits
; Function compile flags: /Ogtpy
;	COMDAT ?reverseBits@@YAID@Z
_TEXT	SEGMENT
_num$ = 8						; size = 1
?reverseBits@@YAID@Z PROC				; reverseBits, COMDAT

; 637  :     unsigned int  NO_OF_BITS = sizeof(num) * 8;
; 638  :     unsigned int reverse_num = 0;
; 639  :     int i;
; 640  :     for (i = 0; i < NO_OF_BITS; i++)
; 641  :     {
; 642  :         if((num & (1 << i)))

	movsx	ecx, BYTE PTR _num$[esp-4]
	xor	eax, eax
	test	cl, 1
	je	SHORT $LN3@reverseBit

; 643  :            reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  

	mov	eax, 128				; 00000080H
$LN3@reverseBit:

; 637  :     unsigned int  NO_OF_BITS = sizeof(num) * 8;
; 638  :     unsigned int reverse_num = 0;
; 639  :     int i;
; 640  :     for (i = 0; i < NO_OF_BITS; i++)
; 641  :     {
; 642  :         if((num & (1 << i)))

	test	cl, 2
	je	SHORT $LN13@reverseBit

; 643  :            reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  

	or	eax, 64					; 00000040H
$LN13@reverseBit:

; 637  :     unsigned int  NO_OF_BITS = sizeof(num) * 8;
; 638  :     unsigned int reverse_num = 0;
; 639  :     int i;
; 640  :     for (i = 0; i < NO_OF_BITS; i++)
; 641  :     {
; 642  :         if((num & (1 << i)))

	test	cl, 4
	je	SHORT $LN15@reverseBit

; 643  :            reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  

	or	eax, 32					; 00000020H
$LN15@reverseBit:

; 637  :     unsigned int  NO_OF_BITS = sizeof(num) * 8;
; 638  :     unsigned int reverse_num = 0;
; 639  :     int i;
; 640  :     for (i = 0; i < NO_OF_BITS; i++)
; 641  :     {
; 642  :         if((num & (1 << i)))

	test	cl, 8
	je	SHORT $LN17@reverseBit

; 643  :            reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  

	or	eax, 16					; 00000010H
$LN17@reverseBit:

; 637  :     unsigned int  NO_OF_BITS = sizeof(num) * 8;
; 638  :     unsigned int reverse_num = 0;
; 639  :     int i;
; 640  :     for (i = 0; i < NO_OF_BITS; i++)
; 641  :     {
; 642  :         if((num & (1 << i)))

	test	cl, 16					; 00000010H
	je	SHORT $LN19@reverseBit

; 643  :            reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  

	or	eax, 8
$LN19@reverseBit:

; 637  :     unsigned int  NO_OF_BITS = sizeof(num) * 8;
; 638  :     unsigned int reverse_num = 0;
; 639  :     int i;
; 640  :     for (i = 0; i < NO_OF_BITS; i++)
; 641  :     {
; 642  :         if((num & (1 << i)))

	test	cl, 32					; 00000020H
	je	SHORT $LN21@reverseBit

; 643  :            reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  

	or	eax, 4
$LN21@reverseBit:

; 637  :     unsigned int  NO_OF_BITS = sizeof(num) * 8;
; 638  :     unsigned int reverse_num = 0;
; 639  :     int i;
; 640  :     for (i = 0; i < NO_OF_BITS; i++)
; 641  :     {
; 642  :         if((num & (1 << i)))

	test	cl, 64					; 00000040H
	je	SHORT $LN23@reverseBit

; 643  :            reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  

	or	eax, 2
$LN23@reverseBit:

; 637  :     unsigned int  NO_OF_BITS = sizeof(num) * 8;
; 638  :     unsigned int reverse_num = 0;
; 639  :     int i;
; 640  :     for (i = 0; i < NO_OF_BITS; i++)
; 641  :     {
; 642  :         if((num & (1 << i)))

	test	cl, cl
	jns	SHORT $LN25@reverseBit

; 643  :            reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  

	or	eax, 1
$LN25@reverseBit:

; 644  :    }
; 645  :     return reverse_num;
; 646  : }

	ret	0
?reverseBits@@YAID@Z ENDP				; reverseBits
_TEXT	ENDS
PUBLIC	?VGA_setfont@@YAXPAD@Z				; VGA_setfont
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_setfont@@YAXPAD@Z
_TEXT	SEGMENT
_font$ = 8						; size = 4
?VGA_setfont@@YAXPAD@Z PROC				; VGA_setfont, COMDAT

; 650  : 	__font = font;

	mov	eax, DWORD PTR _font$[esp-4]
	mov	DWORD PTR ?__font@@3PADA, eax		; __font

; 651  : }

	ret	0
?VGA_setfont@@YAXPAD@Z ENDP				; VGA_setfont
_TEXT	ENDS
PUBLIC	?VGA_clear_screen@@YAXXZ			; VGA_clear_screen
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_clear_screen@@YAXXZ
_TEXT	SEGMENT
?VGA_clear_screen@@YAXXZ PROC				; VGA_clear_screen, COMDAT

; 653  : void VGA_clear_screen() {

	push	esi
	push	edi

; 654  :    unsigned int x=0;
; 655  :    unsigned int y=0;
; 656  :    //qVGA_map_color(0, 0xFF, 0xFF, 0xFF);
; 657  :    for(int p = 0; p < 4; p++)

	xor	edi, edi
$LL3@VGA_clear_:

; 658  :    {
; 659  : 	set_plane(p);

	push	4
	mov	esi, edi
	push	974					; 000003ceH
	and	esi, 3
	call	?outport@@YAXGE@Z			; outport
	push	esi
	push	975					; 000003cfH
	call	?outport@@YAXGE@Z			; outport
	push	2
	push	964					; 000003c4H
	call	?outport@@YAXGE@Z			; outport
	mov	al, 1
	mov	ecx, esi
	shl	al, cl
	movzx	ecx, al
	push	ecx
	push	965					; 000003c5H
	call	?outport@@YAXGE@Z			; outport

; 660  : 	memset(VGA_address, 0, 64*1024);

	mov	edx, DWORD PTR ?VGA_address@@3PAEA	; VGA_address
	push	65536					; 00010000H
	push	0
	push	edx
	call	?memset@@YAPAXPAXDI@Z			; memset
	inc	edi
	add	esp, 44					; 0000002cH
	cmp	edi, 4
	jl	SHORT $LL3@VGA_clear_

; 661  :    }
; 662  :    /*for(y=0; y<VGA_height; y++){
; 663  :       for(x=0; x<VGA_width; x++){
; 664  :          VGA_address[VGA_width*y+x]=0x00;
; 665  :       }
; 666  :    }*/
; 667  : }

	pop	edi
	pop	esi
	ret	0
?VGA_clear_screen@@YAXXZ ENDP				; VGA_clear_screen
_TEXT	ENDS
PUBLIC	?pow2@@YAHD@Z					; pow2
; Function compile flags: /Ogtpy
;	COMDAT ?pow2@@YAHD@Z
_TEXT	SEGMENT
_k$ = 8							; size = 1
?pow2@@YAHD@Z PROC					; pow2, COMDAT

; 737  : 	return 2 << k;

	mov	cl, BYTE PTR _k$[esp-4]
	mov	eax, 2
	shl	eax, cl

; 738  : }

	ret	0
?pow2@@YAHD@Z ENDP					; pow2
_TEXT	ENDS
PUBLIC	?VGA_put_char@@YAXHHDD@Z			; VGA_put_char
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_put_char@@YAXHHDD@Z
_TEXT	SEGMENT
tv239 = -36						; size = 4
_mask$ = -32						; size = 32
_x$ = 8							; size = 4
_y$ = 12						; size = 4
tv259 = 16						; size = 4
_c$ = 16						; size = 1
_color$ = 20						; size = 1
?VGA_put_char@@YAXHHDD@Z PROC				; VGA_put_char, COMDAT

; 752  : {

	sub	esp, 36					; 00000024H

; 753  : 	int cx,cy;
; 754  : 	int mask[8]={1,2,4,8,16,32,64,128};
; 755  : 	unsigned char *glyph=g_8x8_font+(int)c*8;

	movsx	eax, BYTE PTR _c$[esp+32]
	mov	edx, DWORD PTR _x$[esp+32]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _y$[esp+40]
	mov	ecx, 8

; 758  : 		for(cx=0;cx<8;cx++){

	add	edx, ecx
	push	esi
	lea	ebx, DWORD PTR _g_8x8_font[eax*8]
	push	edi
	mov	DWORD PTR _mask$[esp+52], 1
	mov	DWORD PTR _mask$[esp+56], 2
	mov	DWORD PTR _mask$[esp+60], 4
	mov	DWORD PTR _mask$[esp+64], ecx
	mov	DWORD PTR _mask$[esp+68], 16		; 00000010H
	mov	DWORD PTR _mask$[esp+72], 32		; 00000020H
	mov	DWORD PTR _mask$[esp+76], 64		; 00000040H
	mov	DWORD PTR _mask$[esp+80], 128		; 00000080H
	mov	DWORD PTR tv239[esp+52], edx
	sub	ebx, ebp
	mov	DWORD PTR tv259[esp+48], ecx
	npad	8
$LL15@VGA_put_ch:
	mov	edi, DWORD PTR tv239[esp+52]
	xor	esi, esi
$LL16@VGA_put_ch:

; 759  : 			//glyph[cy] = reverseBits(glyph[cy]);
; 760  : 			mode.putpixel(x+(8-cx),y+cy,glyph[cy]&mask[cx]?color:0x00);

	mov	al, BYTE PTR [ebx+ebp]
	test	BYTE PTR _mask$[esp+esi*4+52], al
	je	SHORT $LN9@VGA_put_ch
	movsx	eax, BYTE PTR _color$[esp+48]
	jmp	SHORT $LN10@VGA_put_ch
$LN9@VGA_put_ch:
	xor	eax, eax
$LN10@VGA_put_ch:
	push	eax
	push	ebp
	push	edi
	call	DWORD PTR ?mode@@3UVIDEO_MODE@@A+10
	inc	esi
	add	esp, 12					; 0000000cH
	dec	edi
	cmp	esi, 8
	jl	SHORT $LL16@VGA_put_ch

; 756  :  
; 757  : 	for(cy=0;cy<8;cy++){

	inc	ebp
	dec	DWORD PTR tv259[esp+48]
	jne	SHORT $LL15@VGA_put_ch
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 761  : 		}
; 762  : 	}
; 763  : }

	add	esp, 36					; 00000024H
	ret	0
?VGA_put_char@@YAXHHDD@Z ENDP				; VGA_put_char
_TEXT	ENDS
PUBLIC	?VGA_put_image@@YAXHHPAD@Z			; VGA_put_image
EXTRN	?loadFileToLoc@@YA_NPADPAX@Z:PROC		; loadFileToLoc
EXTRN	?malloc@@YAPAXH@Z:PROC				; malloc
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_put_image@@YAXHHPAD@Z
_TEXT	SEGMENT
$T3169 = -12						; size = 1
$T3170 = -8						; size = 1
$T3171 = -4						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_filename$ = 16						; size = 4
?VGA_put_image@@YAXHHPAD@Z PROC				; VGA_put_image, COMDAT

; 766  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 767  : 	char* buf = (char*)malloc(16*1024);

	push	16384					; 00004000H
	call	?malloc@@YAPAXH@Z			; malloc
	mov	esi, eax

; 768  : 	loadFileToLoc(filename, buf);

	mov	eax, DWORD PTR _filename$[esp+24]
	push	esi
	push	eax
	call	?loadFileToLoc@@YA_NPADPAX@Z		; loadFileToLoc

; 769  : 	bmpHeader* bmph = (bmpHeader*)buf;
; 770  : 	bmpInfoHeader* bmpinfo = (bmpInfoHeader*)(buf + sizeof(bmpHeader));
; 771  : 	// map colors!
; 772  : 	//outport(0xE9, bmpinfo->mNumberOfColorsInPalette);
; 773  : 	bmpColor* me = (bmpColor*)(buf+sizeof(bmpHeader)+bmpinfo->mHeaderSize);

	mov	ecx, DWORD PTR [esi+14]

; 774  : 	for(int i = 0; i < bmpinfo->mNumberOfColorsInPalette; i++)

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	lea	edi, DWORD PTR [ecx+esi+14]
	cmp	DWORD PTR [esi+46], ebx
	jle	SHORT $LN7@VGA_put_im
	npad	2
$LL9@VGA_put_im:

; 775  : 	{
; 776  : 		VGA_map_color(i, me->R, me->G, me->B);

	mov	dl, BYTE PTR [edi]
	mov	al, BYTE PTR [edi+1]
	mov	cl, BYTE PTR [edi+2]
	push	ebx
	push	968					; 000003c8H
	mov	BYTE PTR $T3171[esp+32], dl
	mov	BYTE PTR $T3170[esp+32], al
	mov	BYTE PTR $T3169[esp+32], cl
	call	?outport@@YAXGE@Z			; outport
	mov	edx, DWORD PTR $T3169[esp+32]
	push	edx
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	mov	eax, DWORD PTR $T3170[esp+40]
	push	eax
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	mov	ecx, DWORD PTR $T3171[esp+48]
	push	ecx
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	inc	ebx
	add	esp, 32					; 00000020H

; 777  : 		me++;

	add	edi, 4
	cmp	ebx, DWORD PTR [esi+46]
	jl	SHORT $LL9@VGA_put_im
$LN7@VGA_put_im:

; 778  : 	}
; 779  : 	// memcpy the image!
; 780  : 	for(int a = bmpinfo->mHeight; a > 0; a --)

	mov	ebx, DWORD PTR [esi+22]
	test	ebx, ebx
	jle	SHORT $LN4@VGA_put_im
	push	ebp
	mov	ebp, DWORD PTR _y$[esp+24]
$LL6@VGA_put_im:

; 781  : 	{
; 782  : 		for(int b = bmpinfo->mWidth; b > 0; b --)

	mov	edi, DWORD PTR [esi+18]
	test	edi, edi
	jle	SHORT $LN5@VGA_put_im
	npad	5
$LL3@VGA_put_im:

; 783  : 		{
; 784  : 			//VGA_address[x + y*VGA_width + (bmpinfo->mWidth-b) + (bmpinfo->mHeight-a)*VGA_width] = *(char*)(buf + bmph->mAddressOfPixelArray + a * bmpinfo->mWidth - b);
; 785  : 			mode.putpixel(x + bmpinfo->mWidth - b, y + bmpinfo->mHeight - a, *(char*)(buf + bmph->mAddressOfPixelArray + a * bmpinfo->mWidth - b));

	mov	eax, DWORD PTR [esi+18]
	mov	edx, eax
	imul	edx, ebx
	sub	edx, edi
	add	edx, DWORD PTR [esi+10]
	sub	eax, edi
	movzx	ecx, BYTE PTR [edx+esi]
	add	eax, DWORD PTR _x$[esp+24]
	mov	edx, ebp
	sub	edx, ebx
	add	edx, DWORD PTR [esi+22]
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR ?mode@@3UVIDEO_MODE@@A+10
	dec	edi
	add	esp, 12					; 0000000cH
	test	edi, edi
	jg	SHORT $LL3@VGA_put_im
$LN5@VGA_put_im:

; 778  : 	}
; 779  : 	// memcpy the image!
; 780  : 	for(int a = bmpinfo->mHeight; a > 0; a --)

	dec	ebx
	test	ebx, ebx
	jg	SHORT $LL6@VGA_put_im
	pop	ebp
$LN4@VGA_put_im:
	pop	edi
	pop	esi
	pop	ebx

; 786  : 		}
; 787  : 	}
; 788  : }

	add	esp, 12					; 0000000cH
	ret	0
?VGA_put_image@@YAXHHPAD@Z ENDP				; VGA_put_image
_TEXT	ENDS
PUBLIC	?VGA_put_pixel@@YAXHHD@Z			; VGA_put_pixel
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_put_pixel@@YAXHHD@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_color$ = 16						; size = 1
?VGA_put_pixel@@YAXHHD@Z PROC				; VGA_put_pixel, COMDAT

; 792  : 	VGA_address[VGA_width*y+x] = color;

	mov	eax, DWORD PTR ?VGA_width@@3IA		; VGA_width
	imul	eax, DWORD PTR _y$[esp-4]
	add	eax, DWORD PTR ?VGA_address@@3PAEA	; VGA_address
	mov	cl, BYTE PTR _color$[esp-4]
	mov	edx, DWORD PTR _x$[esp-4]
	mov	BYTE PTR [eax+edx], cl

; 793  : }

	ret	0
?VGA_put_pixel@@YAXHHD@Z ENDP				; VGA_put_pixel
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?write_pixel4p@@YAXIII@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mask$ = 12						; size = 4
_y$ = 12						; size = 4
_c$ = 16						; size = 4
?write_pixel4p@@YAXIII@Z PROC				; write_pixel4p, COMDAT

; 797  : 	unsigned wd_in_bytes, off, mask, p, pmask;
; 798  : 
; 799  : 	wd_in_bytes = VGA_width / 8;
; 800  : 	off = wd_in_bytes * y + x / 8;

	mov	ecx, DWORD PTR _x$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ?VGA_width@@3IA		; VGA_width
	shr	ebp, 3
	imul	ebp, DWORD PTR _y$[esp+4]
	mov	eax, ecx
	shr	eax, 3
	add	ebp, eax

; 801  : 	x = (x & 7) * 1;

	and	ecx, 7

; 802  : 	mask = 0x80 >> x;

	mov	eax, 128				; 00000080H
	sar	eax, cl
	push	esi
	push	edi

; 803  : 	pmask = 1;

	mov	ebx, 1
	mov	DWORD PTR _mask$[esp+12], eax

; 804  : 	for(p = 0; p < 4; p++)

	xor	edi, edi
$LL5@write_pixe:

; 805  : 	{
; 806  : 		set_plane(p);

	push	4
	mov	esi, edi
	push	974					; 000003ceH
	and	esi, 3
	call	?outport@@YAXGE@Z			; outport
	push	esi
	push	975					; 000003cfH
	call	?outport@@YAXGE@Z			; outport
	push	2
	push	964					; 000003c4H
	call	?outport@@YAXGE@Z			; outport
	mov	dl, 1
	mov	ecx, esi
	shl	dl, cl
	movzx	eax, dl
	push	eax
	push	965					; 000003c5H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 32					; 00000020H

; 807  : 		if(pmask & c)

	test	ebx, DWORD PTR _c$[esp+12]
	je	SHORT $LN2@write_pixe

; 808  : 			*(char*)(0xA000*16+off) = (*(char*)((unsigned int)0xA000*16 + off))|mask;

	mov	dl, BYTE PTR _mask$[esp+12]
	or	BYTE PTR [ebp+655360], dl

; 809  : 		else

	jmp	SHORT $LN1@write_pixe
$LN2@write_pixe:

; 810  : 			*(char*)(0xA000*16+off) = (*(char*)((unsigned int)0xA000*16 + off))&~mask;

	mov	al, BYTE PTR _mask$[esp+12]
	not	al
	and	BYTE PTR [ebp+655360], al
$LN1@write_pixe:

; 811  : 		pmask <<= 1;

	inc	edi
	add	ebx, ebx
	cmp	edi, 4
	jb	SHORT $LL5@write_pixe

; 812  : 	}
; 813  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
?write_pixel4p@@YAXIII@Z ENDP				; write_pixel4p
_TEXT	ENDS
PUBLIC	?VGA_put_line@@YAXHHHHD@Z			; VGA_put_line
EXTRN	?math_abs@@YAIH@Z:PROC				; math_abs
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_put_line@@YAXHHHHD@Z
_TEXT	SEGMENT
_steep$ = 8						; size = 1
_x0$ = 8						; size = 4
_deltay$ = 12						; size = 4
_y0$ = 12						; size = 4
_x1$ = 16						; size = 4
_error$ = 20						; size = 4
_y1$ = 20						; size = 4
_color$ = 24						; size = 1
?VGA_put_line@@YAXHHHHD@Z PROC				; VGA_put_line, COMDAT

; 819  : 	/*
; 820  : 	http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
; 821  : 	 function line(x0, y0, x1, y1)
; 822  :      boolean steep := abs(y1 - y0) > abs(x1 - x0)
; 823  :      if steep then
; 824  :          swap(x0, y0)
; 825  :          swap(x1, y1)
; 826  :      if x0 > x1 then
; 827  :          swap(x0, x1)
; 828  :          swap(y0, y1)
; 829  :      int deltax := x1 - x0
; 830  :      int deltay := abs(y1 - y0)
; 831  :      int error := deltax / 2
; 832  :      int ystep
; 833  :      int y := y0
; 834  :      if y0 < y1 then ystep := 1 else ystep := -1
; 835  :      for x from x0 to x1
; 836  :          if steep then plot(y,x) else plot(x,y)
; 837  :          error := error - deltay
; 838  :          if error < 0 then
; 839  :              y := y + ystep
; 840  :              error := error + deltax
; 841  : 	*/
; 842  : 	bool steep = math_abs(y1-y0) > math_abs(x1-x0);

	mov	eax, DWORD PTR _x1$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _x0$[esp+8]
	sub	eax, esi
	push	edi
	push	eax
	call	?math_abs@@YAIH@Z			; math_abs
	mov	ebp, DWORD PTR _y1$[esp+16]
	mov	edi, DWORD PTR _y0$[esp+16]
	mov	ecx, ebp
	sub	ecx, edi
	push	ecx
	mov	ebx, eax
	call	?math_abs@@YAIH@Z			; math_abs
	add	esp, 8
	cmp	eax, ebx
	seta	al
	mov	BYTE PTR _steep$[esp+12], al

; 843  : 	int tmp = 0;
; 844  : 	if(steep)

	test	al, al
	je	SHORT $LN15@VGA_put_li

; 845  : 	{
; 846  : 		tmp = x0;

	mov	eax, esi

; 847  : 		x0 = y0;

	mov	esi, edi

; 848  : 		y0 = tmp;

	mov	edi, eax

; 849  : 
; 850  : 		tmp = x1;

	mov	eax, DWORD PTR _x1$[esp+12]

; 851  : 		x1 = y1;

	mov	ebx, ebp
	mov	DWORD PTR _x1$[esp+12], ebx

; 852  : 		y1 = tmp;

	mov	ebp, eax
	jmp	SHORT $LN10@VGA_put_li
$LN15@VGA_put_li:
	mov	ebx, DWORD PTR _x1$[esp+12]
$LN10@VGA_put_li:

; 853  : 	}
; 854  : 	if(x0 > x1)

	cmp	esi, ebx
	jle	SHORT $LN9@VGA_put_li

; 855  : 	{
; 856  : 		tmp = x0;
; 857  : 		x0 = x1;
; 858  : 		x1 = tmp;

	mov	DWORD PTR _x1$[esp+12], esi

; 859  : 
; 860  : 		tmp = y0;

	mov	eax, edi
	mov	esi, ebx

; 861  : 		y0 = y1;
; 862  : 		y1 = tmp;

	mov	ebx, DWORD PTR _x1$[esp+12]
	mov	edi, ebp
	mov	ebp, eax
$LN9@VGA_put_li:

; 863  : 	}
; 864  : 	int deltax = x1-x0;
; 865  : 	int deltay = math_abs(y1-y0);

	mov	edx, ebp
	sub	edx, edi
	push	edx
	sub	ebx, esi
	call	?math_abs@@YAIH@Z			; math_abs
	mov	DWORD PTR _deltay$[esp+16], eax

; 866  : 	int error = deltax / 2;

	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _error$[esp+16], eax

; 867  : 	int ystep;
; 868  : 	int y = y0;
; 869  : 	if(y0 < y1) ystep = 1; else ystep = -1;

	xor	eax, eax
	add	esp, 4
	cmp	edi, ebp
	setl	al
	lea	ebp, DWORD PTR [eax+eax-1]

; 870  : 	for(int x = x0; x < x1;x++)

	cmp	esi, DWORD PTR _x1$[esp+12]
	jge	SHORT $LN4@VGA_put_li
$LL6@VGA_put_li:

; 871  : 	{
; 872  : 		if(steep) mode.putpixel(y, x, color); else mode.putpixel(x,y,color);

	cmp	BYTE PTR _steep$[esp+12], 0
	je	SHORT $LN3@VGA_put_li
	mov	ecx, DWORD PTR _color$[esp+12]
	push	ecx
	push	esi
	push	edi
	jmp	SHORT $LN16@VGA_put_li
$LN3@VGA_put_li:
	mov	edx, DWORD PTR _color$[esp+12]
	push	edx
	push	edi
	push	esi
$LN16@VGA_put_li:
	call	DWORD PTR ?mode@@3UVIDEO_MODE@@A+10

; 873  : 		error = error - deltay;

	mov	eax, DWORD PTR _deltay$[esp+24]
	add	esp, 12					; 0000000cH
	sub	DWORD PTR _error$[esp+12], eax

; 874  : 		if(error < 0)

	jns	SHORT $LN5@VGA_put_li

; 875  : 		{
; 876  : 			y = y + ystep;

	add	edi, ebp

; 877  : 			error = error +deltax;

	add	DWORD PTR _error$[esp+12], ebx
$LN5@VGA_put_li:

; 870  : 	for(int x = x0; x < x1;x++)

	inc	esi
	cmp	esi, DWORD PTR _x1$[esp+12]
	jl	SHORT $LL6@VGA_put_li
$LN4@VGA_put_li:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 878  : 		}
; 879  : 	}
; 880  : 
; 881  : }

	ret	0
?VGA_put_line@@YAXHHHHD@Z ENDP				; VGA_put_line
_TEXT	ENDS
PUBLIC	?VGA_put_rectangle@@YAXHHHHD@Z			; VGA_put_rectangle
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_put_rectangle@@YAXHHHHD@Z
_TEXT	SEGMENT
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_ex$ = 16						; size = 4
_ey$ = 20						; size = 4
_fill$ = 24						; size = 1
?VGA_put_rectangle@@YAXHHHHD@Z PROC			; VGA_put_rectangle, COMDAT

; 884  : {

	push	ebx

; 885  : 		VGA_put_line(sx, sy, ex, sy, fill);

	mov	ebx, DWORD PTR _ex$[esp]
	push	ebp
	mov	ebp, DWORD PTR _sx$[esp+4]
	push	esi
	mov	esi, DWORD PTR _fill$[esp+8]
	push	edi
	mov	edi, DWORD PTR _sy$[esp+12]
	push	esi
	push	edi
	push	ebx
	push	edi
	push	ebp
	call	?VGA_put_line@@YAXHHHHD@Z		; VGA_put_line

; 886  : 		VGA_put_line(sx, sy, sx, ey, fill);

	mov	eax, DWORD PTR _ey$[esp+32]
	push	esi
	push	eax
	push	ebp
	push	edi
	push	ebp
	call	?VGA_put_line@@YAXHHHHD@Z		; VGA_put_line

; 887  : 		VGA_put_line(sx, ey, ex, ey, fill);

	mov	eax, DWORD PTR _ey$[esp+52]
	push	esi
	push	eax
	push	ebx
	push	eax
	push	ebp
	call	?VGA_put_line@@YAXHHHHD@Z		; VGA_put_line

; 888  : 		VGA_put_line(ex, ey, ex, sy, fill);

	mov	ecx, DWORD PTR _ey$[esp+72]
	push	esi
	push	edi
	push	ebx
	push	ecx
	push	ebx
	call	?VGA_put_line@@YAXHHHHD@Z		; VGA_put_line
	add	esp, 80					; 00000050H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 889  : }

	ret	0
?VGA_put_rectangle@@YAXHHHHD@Z ENDP			; VGA_put_rectangle
_TEXT	ENDS
PUBLIC	?write_registers@@YAXPAE@Z			; write_registers
; Function compile flags: /Ogtpy
;	COMDAT ?write_registers@@YAXPAE@Z
_TEXT	SEGMENT
_regs$ = 8						; size = 4
?write_registers@@YAXPAE@Z PROC				; write_registers, COMDAT

; 185  : void write_registers(unsigned char *regs){

	push	esi

; 186  :    unsigned i;
; 187  : 
; 188  :    /* write MISCELLANEOUS reg */
; 189  :    outport(VGA_MISC_WRITE, *regs);

	mov	esi, DWORD PTR _regs$[esp]
	movzx	eax, BYTE PTR [esi]
	push	edi
	push	eax
	push	962					; 000003c2H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 8

; 190  :    regs++;

	inc	esi

; 191  :    /* write SEQUENCER regs */
; 192  :    for(i = 0; i < VGA_NUM_SEQ_REGS; i++)

	xor	edi, edi
	npad	6
$LL12@write_regi:

; 193  :    {
; 194  :       outport(VGA_SEQ_INDEX, i);

	push	edi
	push	964					; 000003c4H
	call	?outport@@YAXGE@Z			; outport

; 195  :       outport(VGA_SEQ_DATA, *regs);

	movzx	ecx, BYTE PTR [esi]
	push	ecx
	push	965					; 000003c5H
	call	?outport@@YAXGE@Z			; outport
	inc	edi
	add	esp, 16					; 00000010H

; 196  :       regs++;

	inc	esi
	cmp	edi, 5
	jb	SHORT $LL12@write_regi

; 197  :    }
; 198  :    /* unlock CRTC registers */
; 199  :    outport(VGA_CRTC_INDEX, 0x03);

	push	3
	push	980					; 000003d4H
	call	?outport@@YAXGE@Z			; outport

; 200  :    outport(VGA_CRTC_DATA, inport(VGA_CRTC_DATA) | 0x80);

	push	981					; 000003d5H
	call	?inport@@YAEG@Z				; inport
	or	al, 128					; 00000080H
	movzx	edx, al
	push	edx
	push	981					; 000003d5H
	call	?outport@@YAXGE@Z			; outport

; 201  :    outport(VGA_CRTC_INDEX, 0x11);

	push	17					; 00000011H
	push	980					; 000003d4H
	call	?outport@@YAXGE@Z			; outport

; 202  :    outport(VGA_CRTC_DATA, inport(VGA_CRTC_DATA) & ~0x80);

	push	981					; 000003d5H
	call	?inport@@YAEG@Z				; inport
	and	al, 127					; 0000007fH
	movzx	eax, al
	push	eax
	push	981					; 000003d5H
	call	?outport@@YAXGE@Z			; outport

; 203  :    /* make sure they remain unlocked */
; 204  :    regs[0x03] |= 0x80;

	or	BYTE PTR [esi+3], 128			; 00000080H

; 205  :    regs[0x11] &= ~0x80;

	and	BYTE PTR [esi+17], 127			; 0000007fH
	add	esp, 40					; 00000028H

; 206  :    /* write CRTC regs */
; 207  :    for(i = 0; i < VGA_NUM_CRTC_REGS; i++)

	xor	edi, edi
	npad	4
$LL9@write_regi:

; 208  :    {
; 209  :       outport(VGA_CRTC_INDEX, i);

	push	edi
	push	980					; 000003d4H
	call	?outport@@YAXGE@Z			; outport

; 210  :       outport(VGA_CRTC_DATA, *regs);

	movzx	ecx, BYTE PTR [esi]
	push	ecx
	push	981					; 000003d5H
	call	?outport@@YAXGE@Z			; outport
	inc	edi
	add	esp, 16					; 00000010H

; 211  :       regs++;

	inc	esi
	cmp	edi, 25					; 00000019H
	jb	SHORT $LL9@write_regi

; 212  :    }
; 213  :    /* write GRAPHICS CONTROLLER regs */
; 214  :    for(i = 0; i < VGA_NUM_GC_REGS; i++)

	xor	edi, edi
$LL6@write_regi:

; 215  :    {
; 216  :       outport(VGA_GC_INDEX, i);

	push	edi
	push	974					; 000003ceH
	call	?outport@@YAXGE@Z			; outport

; 217  :       outport(VGA_GC_DATA, *regs);

	movzx	edx, BYTE PTR [esi]
	push	edx
	push	975					; 000003cfH
	call	?outport@@YAXGE@Z			; outport
	inc	edi
	add	esp, 16					; 00000010H

; 218  :       regs++;

	inc	esi
	cmp	edi, 9
	jb	SHORT $LL6@write_regi

; 219  :    }
; 220  :    /* write ATTRIBUTE CONTROLLER regs */
; 221  :    for(i = 0; i < VGA_NUM_AC_REGS; i++)

	xor	edi, edi
	npad	6
$LL3@write_regi:

; 222  :    {
; 223  :       (void)inport(VGA_INSTAT_READ);

	push	986					; 000003daH
	call	?inport@@YAEG@Z				; inport

; 224  :       outport(VGA_AC_INDEX, i);

	push	edi
	push	960					; 000003c0H
	call	?outport@@YAXGE@Z			; outport

; 225  :       outport(VGA_AC_WRITE, *regs);

	movzx	eax, BYTE PTR [esi]
	push	eax
	push	960					; 000003c0H
	call	?outport@@YAXGE@Z			; outport
	inc	edi
	add	esp, 20					; 00000014H

; 226  :       regs++;

	inc	esi
	cmp	edi, 21					; 00000015H
	jb	SHORT $LL3@write_regi

; 227  :    }
; 228  :    
; 229  :    /* lock 16-color palette and unblank display */
; 230  :    (void)inport(VGA_INSTAT_READ);

	push	986					; 000003daH
	call	?inport@@YAEG@Z				; inport

; 231  :    outport(VGA_AC_INDEX, 0x20);

	push	32					; 00000020H
	push	960					; 000003c0H
	call	?outport@@YAXGE@Z			; outport

; 232  :    /* add new palette */
; 233  :    VGA_map_color(0, 0xFF, 0xFF, 0xFF);

	push	0
	push	968					; 000003c8H
	call	?outport@@YAXGE@Z			; outport
	push	255					; 000000ffH
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	push	255					; 000000ffH
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	push	255					; 000000ffH
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi

; 234  : }

	ret	0
?write_registers@@YAXPAE@Z ENDP				; write_registers
_TEXT	ENDS
PUBLIC	?restorePalette@@YAXPAUpalette_entry@@@Z	; restorePalette
; Function compile flags: /Ogtpy
;	COMDAT ?restorePalette@@YAXPAUpalette_entry@@@Z
_TEXT	SEGMENT
$T3221 = -12						; size = 1
$T3222 = -8						; size = 1
$T3223 = -4						; size = 1
_p$ = 8							; size = 4
?restorePalette@@YAXPAUpalette_entry@@@Z PROC		; restorePalette, COMDAT

; 288  : {

	sub	esp, 12					; 0000000cH
	push	esi

; 289  : 	for(int i = 0; i<256;i++)

	mov	esi, DWORD PTR _p$[esp+12]
	push	edi
	xor	edi, edi
	inc	esi
	npad	4
$LL3@restorePal:

; 290  : 	{
; 291  : 		VGA_map_color(i, p[i].R, p[i].G, p[i].B);

	mov	al, BYTE PTR [esi+1]
	mov	cl, BYTE PTR [esi]
	mov	dl, BYTE PTR [esi-1]
	push	edi
	push	968					; 000003c8H
	mov	BYTE PTR $T3223[esp+28], al
	mov	BYTE PTR $T3222[esp+28], cl
	mov	BYTE PTR $T3221[esp+28], dl
	call	?outport@@YAXGE@Z			; outport
	mov	eax, DWORD PTR $T3221[esp+28]
	push	eax
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	mov	ecx, DWORD PTR $T3222[esp+36]
	push	ecx
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	mov	edx, DWORD PTR $T3223[esp+44]
	push	edx
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	inc	edi
	add	esp, 32					; 00000020H
	add	esi, 3
	cmp	edi, 256				; 00000100H
	jl	SHORT $LL3@restorePal
	pop	edi
	pop	esi

; 292  : 	}
; 293  : }

	add	esp, 12					; 0000000cH
	ret	0
?restorePalette@@YAXPAUpalette_entry@@@Z ENDP		; restorePalette
_TEXT	ENDS
PUBLIC	?VGA_init@@YAXHHH@Z				; VGA_init
EXTRN	?DebugReset@@YAXXZ:PROC				; DebugReset
EXTRN	?memcpy@@YAXPAD0H@Z:PROC			; memcpy
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_init@@YAXHHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_bpp$ = 16						; size = 4
?VGA_init@@YAXHHH@Z PROC				; VGA_init, COMDAT

; 670  : void VGA_init(int width, int height, int bpp){

	push	ebx

; 671  : 	//savefont();
; 672  : 	savePalette(savedPalette);

	push	OFFSET ?savedPalette@@3PAUpalette_entry@@A ; savedPalette
	call	?savePalette@@YAXPAUpalette_entry@@@Z	; savePalette

; 673  : 	//read_registers(mode_80_25_text);
; 674  : 	/*outport(0x3C4, 0x02);
; 675  : 	char in = inport(0x3C5);
; 676  : 	DebugPrintf("\n0x3c4.0x02=0x%x", in);
; 677  : 	for(;;);*/
; 678  :    //setup the vga struct
; 679  :    VGA_width=(unsigned int)width;

	mov	eax, DWORD PTR _width$[esp+4]

; 680  :    VGA_height=(unsigned int)height;

	mov	ecx, DWORD PTR _height$[esp+4]

; 681  :    VGA_bpp=bpp;

	mov	ebx, DWORD PTR _bpp$[esp+4]

; 682  :    VGA_address = (unsigned char*)0xA0000;
; 683  : 
; 684  :    //enables the mode 13 state
; 685  :    //write_registers(mode_320_200_256);
; 686  :    write_registers(mode_640_480_16);

	push	OFFSET ?mode_640_480_16@@3PAEA		; mode_640_480_16
	mov	DWORD PTR ?VGA_width@@3IA, eax		; VGA_width
	mov	DWORD PTR ?VGA_height@@3IA, ecx		; VGA_height
	mov	DWORD PTR ?VGA_bpp@@3IA, ebx		; VGA_bpp
	mov	DWORD PTR ?VGA_address@@3PAEA, 655360	; VGA_address, 000a0000H
	call	?write_registers@@YAXPAE@Z		; write_registers

; 687  :    VGA_width = 640;
; 688  :    VGA_height = 480;
; 689  :    mode.address = (char*)VGA_address;

	mov	edx, DWORD PTR ?VGA_address@@3PAEA	; VGA_address
	mov	ecx, 640				; 00000280H
	mov	eax, 480				; 000001e0H

; 690  :    mode.bpp = bpp;
; 691  :    mode.height = VGA_height;
; 692  :    mode.width = VGA_width;
; 693  :    mode.id = 0x12;
; 694  :    mode.putpixel = (PIXEL_WRITER)write_pixel4p;
; 695  :    //save videomemory
; 696  :    vidmem = (char*)malloc(256*1024);

	push	262144					; 00040000H
	mov	DWORD PTR ?VGA_width@@3IA, ecx		; VGA_width
	mov	DWORD PTR ?VGA_height@@3IA, eax		; VGA_height
	mov	DWORD PTR ?mode@@3UVIDEO_MODE@@A+14, edx
	mov	BYTE PTR ?mode@@3UVIDEO_MODE@@A+9, bl
	mov	DWORD PTR ?mode@@3UVIDEO_MODE@@A+5, eax
	mov	DWORD PTR ?mode@@3UVIDEO_MODE@@A+1, ecx
	mov	BYTE PTR ?mode@@3UVIDEO_MODE@@A, 18	; 00000012H
	mov	DWORD PTR ?mode@@3UVIDEO_MODE@@A+10, OFFSET ?write_pixel4p@@YAXIII@Z ; write_pixel4p
	call	?malloc@@YAPAXH@Z			; malloc

; 697  :    memcpy((char*)VGA_address, vidmem, 256*1024);

	push	262144					; 00040000H
	push	eax
	mov	DWORD PTR ?vidmem@@3PADA, eax		; vidmem
	mov	eax, DWORD PTR ?VGA_address@@3PAEA	; VGA_address
	push	eax
	call	?memcpy@@YAXPAD0H@Z			; memcpy

; 698  :    _isVGA = true;

	mov	BYTE PTR __isVGA, 1

; 699  :    DebugReset();

	call	?DebugReset@@YAXXZ			; DebugReset

; 700  : 
; 701  :    //clears the screen
; 702  :    VGA_clear_screen();

	call	?VGA_clear_screen@@YAXXZ		; VGA_clear_screen

; 703  : 
; 704  :    //write_pixel4p(16, 16, 0x3d);
; 705  :   // for(;;);
; 706  : 
; 707  :   // VGA_put_pixel(16, 16, 11);
; 708  :    VGA_map_color(0x3D, 0xFF, 0x00, 0x00);

	push	61					; 0000003dH
	push	968					; 000003c8H
	call	?outport@@YAXGE@Z			; outport
	push	255					; 000000ffH
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	push	0
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	push	0
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport

; 709  :    VGA_map_color(0x00, 0xFF, 0xFF, 0xFF);

	push	0
	push	968					; 000003c8H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 64					; 00000040H
	push	255					; 000000ffH
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	push	255					; 000000ffH
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	push	255					; 000000ffH
	push	969					; 000003c9H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 24					; 00000018H
	pop	ebx

; 710  : 	/*_put_char(16, 16, 'l');
; 711  : 	_put_char(24, 16, 'e');
; 712  : 	_put_char(32, 16, 'v');
; 713  : 	_put_char(40, 16, 'e');
; 714  : 	_put_char(48, 16, 'x');*/
; 715  :    //VGA_put_string(16,16, "levex");
; 716  :    //mehgfor(;;);
; 717  : 
; 718  :  //  VGA_put_image(10, 10, "test.bmp");
; 719  : 
; 720  : }

	ret	0
?VGA_init@@YAXHHH@Z ENDP				; VGA_init
_TEXT	ENDS
PUBLIC	?VGA_deinit@@YAXXZ				; VGA_deinit
EXTRN	?DebugClrScr@@YAXG@Z:PROC			; DebugClrScr
EXTRN	?memcpyTF@@YAXPAD0H@Z:PROC			; memcpyTF
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_deinit@@YAXXZ
_TEXT	SEGMENT
?VGA_deinit@@YAXXZ PROC					; VGA_deinit, COMDAT

; 724  : 	memcpyTF((char*)VGA_address, vidmem, 256*1024);

	mov	eax, DWORD PTR ?vidmem@@3PADA		; vidmem
	mov	ecx, DWORD PTR ?VGA_address@@3PAEA	; VGA_address
	push	262144					; 00040000H
	push	eax
	push	ecx
	call	?memcpyTF@@YAXPAD0H@Z			; memcpyTF

; 725  : 	write_registers(mode_80_25_text);

	push	OFFSET ?mode_80_25_text@@3PAEA		; mode_80_25_text
	call	?write_registers@@YAXPAE@Z		; write_registers

; 726  : 	restorePalette(savedPalette);

	push	OFFSET ?savedPalette@@3PAUpalette_entry@@A ; savedPalette
	call	?restorePalette@@YAXPAUpalette_entry@@@Z ; restorePalette

; 727  : 	_isVGA = false;

	mov	BYTE PTR __isVGA, 0

; 728  : 	DebugReset();

	call	?DebugReset@@YAXXZ			; DebugReset

; 729  : 	//restorefont((char*)g_8x8_font);
; 730  : 	//write_font(g_8x8_font, 8);
; 731  : 	//memset((char*)0xB8000, 0, 64*1024);
; 732  : 	DebugClrScr(0x17);

	push	23					; 00000017H
	call	?DebugClrScr@@YAXG@Z			; DebugClrScr
	add	esp, 24					; 00000018H

; 733  : }

	ret	0
?VGA_deinit@@YAXXZ ENDP					; VGA_deinit
_TEXT	ENDS
PUBLIC	?VGA_put_string@@YAXHHPADD@Z			; VGA_put_string
; Function compile flags: /Ogtpy
;	COMDAT ?VGA_put_string@@YAXHHPADD@Z
_TEXT	SEGMENT
_i$ = -41						; size = 1
tv305 = -40						; size = 4
tv262 = -36						; size = 4
_mask$3250 = -32					; size = 32
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_str$ = 16						; size = 4
_col$ = 20						; size = 1
?VGA_put_string@@YAXHHPADD@Z PROC			; VGA_put_string, COMDAT

; 741  : {

	sub	esp, 44					; 0000002cH

; 742  : 	char i = 0;
; 743  : 	while(*str != '\0')

	mov	eax, DWORD PTR _str$[esp+40]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR _i$[esp+44], 0
	test	al, al
	je	$LN1@VGA_put_st
	push	ebx
	push	ebp
	push	esi
	push	edi
	npad	6
$LL2@VGA_put_st:
	movsx	edx, BYTE PTR _i$[esp+60]
	mov	esi, DWORD PTR _x$[esp+56]

; 744  : 	{
; 745  : 		VGA_put_char(x + i*8, y, *str, col);

	mov	edi, DWORD PTR _y$[esp+56]
	movsx	eax, al
	mov	ecx, 8
	lea	ebx, DWORD PTR _g_8x8_font[eax*8]
	lea	edx, DWORD PTR [esi+edx*8+8]
	mov	DWORD PTR _mask$3250[esp+60], 1
	mov	DWORD PTR _mask$3250[esp+64], 2
	mov	DWORD PTR _mask$3250[esp+68], 4
	mov	DWORD PTR _mask$3250[esp+72], ecx
	mov	DWORD PTR _mask$3250[esp+76], 16	; 00000010H
	mov	DWORD PTR _mask$3250[esp+80], 32	; 00000020H
	mov	DWORD PTR _mask$3250[esp+84], 64	; 00000040H
	mov	DWORD PTR _mask$3250[esp+88], 128	; 00000080H
	mov	DWORD PTR tv262[esp+60], edx
	sub	ebx, edi
	mov	DWORD PTR tv305[esp+60], ecx
$LL22@VGA_put_st:
	mov	ebp, DWORD PTR tv262[esp+60]
	xor	esi, esi
	npad	4
$LL23@VGA_put_st:
	mov	al, BYTE PTR [ebx+edi]
	test	BYTE PTR _mask$3250[esp+esi*4+60], al
	je	SHORT $LN13@VGA_put_st
	movsx	eax, BYTE PTR _col$[esp+56]
	jmp	SHORT $LN14@VGA_put_st
$LN13@VGA_put_st:
	xor	eax, eax
$LN14@VGA_put_st:
	push	eax
	push	edi
	push	ebp
	call	DWORD PTR ?mode@@3UVIDEO_MODE@@A+10
	inc	esi
	add	esp, 12					; 0000000cH
	dec	ebp
	cmp	esi, 8
	jl	SHORT $LL23@VGA_put_st
	inc	edi
	dec	DWORD PTR tv305[esp+60]
	jne	SHORT $LL22@VGA_put_st

; 746  : 		str++;

	mov	eax, DWORD PTR _str$[esp+56]

; 747  : 		i++;

	inc	BYTE PTR _i$[esp+60]
	inc	eax
	mov	DWORD PTR _str$[esp+56], eax
	mov	al, BYTE PTR [eax]
	test	al, al
	jne	$LL2@VGA_put_st
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN1@VGA_put_st:

; 748  : 	}
; 749  : }

	add	esp, 44					; 0000002cH
	ret	0
?VGA_put_string@@YAXHHPADD@Z ENDP			; VGA_put_string
_TEXT	ENDS
END
