; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\HardDrive.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
__drive	DD	01H DUP (?)
_BSS	ENDS
PUBLIC	?hdd_irq@@YAXXZ					; hdd_irq
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\harddrive.cpp
;	COMDAT ?hdd_irq@@YAXXZ
_TEXT	SEGMENT
?hdd_irq@@YAXXZ PROC					; hdd_irq, COMDAT

; 9    : 
; 10   : }

	ret	0
?hdd_irq@@YAXXZ ENDP					; hdd_irq
_TEXT	ENDS
PUBLIC	?hdd_set_working_drive@@YAXH@Z			; hdd_set_working_drive
; Function compile flags: /Ogtpy
;	COMDAT ?hdd_set_working_drive@@YAXH@Z
_TEXT	SEGMENT
_drive$ = 8						; size = 4
?hdd_set_working_drive@@YAXH@Z PROC			; hdd_set_working_drive, COMDAT

; 19   : 	_drive = drive;

	mov	eax, DWORD PTR _drive$[esp-4]
	mov	DWORD PTR __drive, eax

; 20   : }

	ret	0
?hdd_set_working_drive@@YAXH@Z ENDP			; hdd_set_working_drive
_TEXT	ENDS
PUBLIC	?hdd_read_sector@@YAPADH@Z			; hdd_read_sector
EXTRN	?inport@@YAEG@Z:PROC				; inport
EXTRN	?outport@@YAXGE@Z:PROC				; outport
EXTRN	?malloc@@YAPAXH@Z:PROC				; malloc
; Function compile flags: /Ogtpy
;	COMDAT ?hdd_read_sector@@YAPADH@Z
_TEXT	SEGMENT
_sectorLBA$ = 8						; size = 4
?hdd_read_sector@@YAPADH@Z PROC				; hdd_read_sector, COMDAT

; 23   : {

	push	esi
	push	edi

; 24   : 	char* buffer = (char*)malloc(512);

	push	512					; 00000200H
	call	?malloc@@YAPAXH@Z			; malloc
	mov	edi, eax

; 25   : 	outport(_drive + 1, 0); // send null byte

	mov	eax, DWORD PTR __drive
	inc	eax
	push	0
	push	eax
	call	?outport@@YAXGE@Z			; outport

; 26   : 	outport(_drive + 2, 1); // send sector count (1)

	mov	ecx, DWORD PTR __drive
	add	ecx, 2
	push	1
	push	ecx
	call	?outport@@YAXGE@Z			; outport

; 27   : 	outport(_drive + 3, (unsigned char)sectorLBA); // send sector number LOW

	mov	edx, DWORD PTR __drive
	mov	esi, DWORD PTR _sectorLBA$[esp+24]
	add	edx, 3
	push	esi
	push	edx
	call	?outport@@YAXGE@Z			; outport

; 28   : 	outport(_drive + 4, (unsigned char)(sectorLBA >> 8)); // send sector number MID

	mov	ecx, DWORD PTR __drive
	mov	eax, esi
	sar	eax, 8
	push	eax
	add	ecx, 4
	push	ecx
	call	?outport@@YAXGE@Z			; outport

; 29   : 	outport(_drive + 5, (unsigned char)(sectorLBA >> 16)); // send sector number HIGH

	mov	edx, DWORD PTR __drive
	sar	esi, 16					; 00000010H
	add	edx, 5
	push	esi
	push	edx
	call	?outport@@YAXGE@Z			; outport

; 30   : 	outport(_drive + 6, 0x40); // send LBA28 addressing mode flag

	mov	eax, DWORD PTR __drive
	add	eax, 6
	push	64					; 00000040H
	push	eax
	call	?outport@@YAXGE@Z			; outport

; 31   : 	outport(_drive + 7, 0x20); // send READ SECTORS command.

	mov	ecx, DWORD PTR __drive
	add	ecx, 7
	push	32					; 00000020H
	push	ecx
	call	?outport@@YAXGE@Z			; outport
	add	esp, 60					; 0000003cH

; 32   : 
; 33   : 	for (int i = 0; i < 256; i++)

	xor	esi, esi
	npad	1
$LL3@hdd_read_s:

; 34   : 	{
; 35   : 		short tmpword = inport(0x1F0);

	push	496					; 000001f0H
	call	?inport@@YAEG@Z				; inport
	movzx	eax, al

; 36   : 		buffer[i * 2] = (unsigned char)tmpword;

	mov	BYTE PTR [edi+esi*2], al

; 37   : 		buffer[i * 2 + 1] = (unsigned char)(tmpword >> 8);

	sar	eax, 8
	mov	BYTE PTR [edi+esi*2+1], al
	inc	esi
	add	esp, 4
	cmp	esi, 256				; 00000100H
	jl	SHORT $LL3@hdd_read_s

; 38   : 	}
; 39   : 	return buffer;

	mov	eax, edi
	pop	edi
	pop	esi

; 40   : }

	ret	0
?hdd_read_sector@@YAPADH@Z ENDP				; hdd_read_sector
_TEXT	ENDS
PUBLIC	?hdd_init@@YAXH@Z				; hdd_init
; Function compile flags: /Ogtpy
;	COMDAT ?hdd_init@@YAXH@Z
_TEXT	SEGMENT
_irq$ = 8						; size = 4
?hdd_init@@YAXH@Z PROC					; hdd_init, COMDAT

; 14   : 	hdd_set_working_drive(0x1F0);

	mov	DWORD PTR __drive, 496			; 000001f0H

; 15   : }

	ret	0
?hdd_init@@YAXH@Z ENDP					; hdd_init
_TEXT	ENDS
END
