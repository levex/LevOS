; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\HComm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?outport@@YAXGE@Z				; outport
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\hcomm.cpp
;	COMDAT ?outport@@YAXGE@Z
_TEXT	SEGMENT
_portid$ = 8						; size = 2
_value$ = 12						; size = 1
?outport@@YAXGE@Z PROC					; outport, COMDAT

; 12   : 	_asm {
; 13   : 		mov		al, byte ptr [value]

	mov	al, BYTE PTR _value$[esp-4]

; 14   : 		mov		dx, word ptr [portid]

	mov	dx, WORD PTR _portid$[esp-4]

; 15   : 		out		dx, al

	out	dx, al

; 16   : 	}
; 17   : }

	ret	0
?outport@@YAXGE@Z ENDP					; outport
_TEXT	ENDS
PUBLIC	?inport@@YAEG@Z					; inport
; Function compile flags: /Ogtpy
;	COMDAT ?inport@@YAEG@Z
_TEXT	SEGMENT
_portid$ = 8						; size = 2
?inport@@YAEG@Z PROC					; inport, COMDAT

; 20   : 	_asm {
; 21   : 		mov		dx, word ptr [portid]

	mov	dx, WORD PTR _portid$[esp-4]

; 22   : 		in		al, dx

	in	al, dx

; 23   : 		mov		byte ptr [portid], al

	mov	BYTE PTR _portid$[esp-4], al

; 24   : 	}
; 25   : 	return (unsigned char)portid;

	mov	al, BYTE PTR _portid$[esp-4]

; 26   : 
; 27   : }

	ret	0
?inport@@YAEG@Z ENDP					; inport
_TEXT	ENDS
PUBLIC	?outportW@@YAXGI@Z				; outportW
; Function compile flags: /Ogtpy
;	COMDAT ?outportW@@YAXGI@Z
_TEXT	SEGMENT
_portid$ = 8						; size = 2
_value$ = 12						; size = 4
?outportW@@YAXGI@Z PROC					; outportW, COMDAT

; 31   : 	_asm {
; 32   : 		push eax

	push	eax

; 33   : 		mov		eax, value

	mov	eax, DWORD PTR _value$[esp]

; 34   : 		mov		dx, word ptr [portid]

	mov	dx, WORD PTR _portid$[esp]

; 35   : 		out	dx, eax

	out	dx, eax

; 36   : 		pop eax

	pop	eax

; 37   : 	}
; 38   : }

	ret	0
?outportW@@YAXGI@Z ENDP					; outportW
_TEXT	ENDS
PUBLIC	?inportW@@YAIG@Z				; inportW
; Function compile flags: /Ogtpy
;	COMDAT ?inportW@@YAIG@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_portid$ = 8						; size = 2
?inportW@@YAIG@Z PROC					; inportW, COMDAT

; 40   : {

	push	ecx

; 41   : 	unsigned int ret = 0;

	mov	DWORD PTR _ret$[esp+4], 0

; 42   : 	_asm {
; 43   : 		mov		dx, word ptr [portid]

	mov	dx, WORD PTR _portid$[esp]

; 44   : 		in		eax, dx

	in	eax, dx

; 45   : 		mov		ret, eax

	mov	DWORD PTR _ret$[esp+4], eax

; 46   : 	}
; 47   : 	return ret;

	mov	eax, DWORD PTR _ret$[esp+4]

; 48   : 
; 49   : }

	pop	ecx
	ret	0
?inportW@@YAIG@Z ENDP					; inportW
_TEXT	ENDS
PUBLIC	?interruptdone@@YAXI@Z				; interruptdone
EXTRN	?pic_send_command@@YAXEE@Z:PROC			; pic_send_command
; Function compile flags: /Ogtpy
;	COMDAT ?interruptdone@@YAXI@Z
_TEXT	SEGMENT
_intno$ = 8						; size = 4
?interruptdone@@YAXI@Z PROC				; interruptdone, COMDAT

; 52   : 
; 53   : 	// insure its a valid hardware irq
; 54   : 	if (intno > 16)

	mov	eax, DWORD PTR _intno$[esp-4]
	cmp	eax, 16					; 00000010H
	ja	SHORT $LN3@interruptd

; 55   : 		return;
; 56   : 
; 57   : 	// test if we need to send end-of-interrupt to second pic
; 58   : 	if (intno >= 8)

	cmp	eax, 8
	jb	SHORT $LN1@interruptd

; 59   : 		pic_send_command (I86_PIC_OCW2_MASK_EOI, 1);

	push	1
	push	32					; 00000020H
	call	?pic_send_command@@YAXEE@Z		; pic_send_command
	add	esp, 8
$LN1@interruptd:

; 60   : 
; 61   : 	// always send end-of-interrupt to primary pic
; 62   : 	pic_send_command (I86_PIC_OCW2_MASK_EOI, 0);

	push	0
	push	32					; 00000020H
	call	?pic_send_command@@YAXEE@Z		; pic_send_command
	add	esp, 8
$LN3@interruptd:

; 63   : }

	ret	0
?interruptdone@@YAXI@Z ENDP				; interruptdone
_TEXT	ENDS
PUBLIC	?setint@@YAXHP6AXXZ@Z				; setint
EXTRN	?i86_install_ir@@YAHIGGP6AXXZ@Z:PROC		; i86_install_ir
; Function compile flags: /Ogtpy
;	COMDAT ?setint@@YAXHP6AXXZ@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_h$ = 12						; size = 4
?setint@@YAXHP6AXXZ@Z PROC				; setint, COMDAT

; 67   : 	i86_install_ir (i, I86_IDT_DESC_PRESENT | I86_IDT_DESC_BIT32, 0x8, h);

	mov	eax, DWORD PTR _h$[esp-4]
	mov	ecx, DWORD PTR _i$[esp-4]
	push	eax
	push	8
	push	142					; 0000008eH
	push	ecx
	call	?i86_install_ir@@YAHIGGP6AXXZ@Z		; i86_install_ir
	add	esp, 16					; 00000010H

; 68   : }

	ret	0
?setint@@YAXHP6AXXZ@Z ENDP				; setint
_TEXT	ENDS
PUBLIC	?sleep@@YAXH@Z					; sleep
EXTRN	?i86_pit_get_tick_count@@YAIXZ:PROC		; i86_pit_get_tick_count
;	COMDAT ?ticks@?1??sleep@@YAXH@Z@4HA
_BSS	SEGMENT
?ticks@?1??sleep@@YAXH@Z@4HA DD 01H DUP (?)		; `sleep'::`2'::ticks
_BSS	ENDS
;	COMDAT ?$S1@?1??sleep@@YAXH@Z@4IA
_BSS	SEGMENT
?$S1@?1??sleep@@YAXH@Z@4IA DD 01H DUP (?)		; `sleep'::`2'::$S1
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT ?sleep@@YAXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?sleep@@YAXH@Z PROC					; sleep, COMDAT

; 72   : 	static int ticks = i + i86_pit_get_tick_count ();

	mov	eax, 1
	test	BYTE PTR ?$S1@?1??sleep@@YAXH@Z@4IA, al
	jne	SHORT $LL2@sleep
	or	DWORD PTR ?$S1@?1??sleep@@YAXH@Z@4IA, eax
	call	?i86_pit_get_tick_count@@YAIXZ		; i86_pit_get_tick_count
	add	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR ?ticks@?1??sleep@@YAXH@Z@4HA, eax
$LL2@sleep:

; 73   : 	while (ticks > i86_pit_get_tick_count ())

	call	?i86_pit_get_tick_count@@YAIXZ		; i86_pit_get_tick_count
	cmp	DWORD PTR ?ticks@?1??sleep@@YAXH@Z@4HA, eax
	ja	SHORT $LL2@sleep

; 74   : 		;
; 75   : 
; 76   : }

	ret	0
?sleep@@YAXH@Z ENDP					; sleep
_TEXT	ENDS
PUBLIC	?getFileSize@@YAHPAD@Z				; getFileSize
EXTRN	?volOpenFile@@YA?AU_FILE@@PBD@Z:PROC		; volOpenFile
; Function compile flags: /Ogtpy
;	COMDAT ?getFileSize@@YAHPAD@Z
_TEXT	SEGMENT
_f$ = -120						; size = 60
$T3075 = -60						; size = 60
_file$ = 8						; size = 4
?getFileSize@@YAHPAD@Z PROC				; getFileSize, COMDAT

; 79   : {

	sub	esp, 120				; 00000078H

; 80   : 	FILE f = volOpenFile(file);

	mov	eax, DWORD PTR _file$[esp+116]
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR $T3075[esp+132]
	push	ecx
	call	?volOpenFile@@YA?AU_FILE@@PBD@Z		; volOpenFile
	mov	esi, eax
	mov	ecx, 15					; 0000000fH
	lea	edi, DWORD PTR _f$[esp+136]
	rep movsd

; 81   : 	if(f.flags&FS_INVALID == FS_INVALID) {return 0;};

	mov	dl, BYTE PTR _f$[esp+168]
	and	dl, 1
	add	esp, 8
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	not	eax
	and	eax, DWORD PTR _f$[esp+164]
	pop	edi
	pop	esi

; 82   : 	return f.fileLength;
; 83   : }

	add	esp, 120				; 00000078H
	ret	0
?getFileSize@@YAHPAD@Z ENDP				; getFileSize
_TEXT	ENDS
PUBLIC	?loadFileToLoc@@YADPADPAX@Z			; loadFileToLoc
EXTRN	?volCloseFile@@YAXPAU_FILE@@@Z:PROC		; volCloseFile
EXTRN	?volReadFile@@YAXPAU_FILE@@PAEI@Z:PROC		; volReadFile
; Function compile flags: /Ogtpy
;	COMDAT ?loadFileToLoc@@YADPADPAX@Z
_TEXT	SEGMENT
_f$ = -120						; size = 60
$T3080 = -60						; size = 60
_file$ = 8						; size = 4
_loc$ = 12						; size = 4
?loadFileToLoc@@YADPADPAX@Z PROC			; loadFileToLoc, COMDAT

; 86   : {

	sub	esp, 120				; 00000078H

; 87   : 	FILE f = volOpenFile(file);

	mov	eax, DWORD PTR _file$[esp+116]
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR $T3080[esp+132]
	push	ecx
	call	?volOpenFile@@YA?AU_FILE@@PBD@Z		; volOpenFile
	mov	ecx, 15					; 0000000fH
	mov	esi, eax
	lea	edi, DWORD PTR _f$[esp+136]
	add	esp, 8
	rep movsd

; 88   : 	if(f.flags == FS_INVALID) {return ERR_FILE_NOT_FOUND;};

	cmp	DWORD PTR _f$[esp+160], 2
	jne	SHORT $LN3@loadFileTo
	pop	edi
	xor	al, al
	pop	esi

; 104  : }

	add	esp, 120				; 00000078H
	ret	0
$LN3@loadFileTo:

; 91   : #ifdef DEBUG
; 92   : 	DebugPrintf("Filesize=%d", f.fileLength);
; 93   : #endif
; 94   : 	while(f.eof != 1)

	cmp	DWORD PTR _f$[esp+172], 1
	je	SHORT $LN1@loadFileTo

; 89   : 	unsigned char* buf = (unsigned char*)loc;
; 90   : 	int i = 0;

	mov	esi, DWORD PTR _loc$[esp+124]
$LL2@loadFileTo:

; 95   : 	{
; 96   : 		volReadFile(&f, buf + i*512, 512);

	push	512					; 00000200H
	lea	edx, DWORD PTR _f$[esp+132]
	push	esi
	push	edx
	call	?volReadFile@@YAXPAU_FILE@@PAEI@Z	; volReadFile
	add	esp, 12					; 0000000cH

; 97   : 		i++;

	add	esi, 512				; 00000200H
	cmp	DWORD PTR _f$[esp+172], 1
	jne	SHORT $LL2@loadFileTo
$LN1@loadFileTo:

; 98   : 	}
; 99   : #ifdef DEBUG
; 100  : 	DebugPrintf("\ni=%d=>size=%d", i+1, (i+1)*512);
; 101  : #endif
; 102  : 	volCloseFile(&f);

	lea	eax, DWORD PTR _f$[esp+128]
	push	eax
	call	?volCloseFile@@YAXPAU_FILE@@@Z		; volCloseFile
	add	esp, 4
	pop	edi

; 103  : 	return ERR_SUCCESS;

	mov	al, 1
	pop	esi

; 104  : }

	add	esp, 120				; 00000078H
	ret	0
?loadFileToLoc@@YADPADPAX@Z ENDP			; loadFileToLoc
_TEXT	ENDS
END
