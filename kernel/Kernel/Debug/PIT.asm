; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\PIT.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
__pit_ticks DD	01H DUP (?)
__pit_bIsInit DB 01H DUP (?)
	ALIGN	4

__eip	DD	01H DUP (?)
_BSS	ENDS
PUBLIC	?i86_pit_irq@@YAXXZ				; i86_pit_irq
EXTRN	?interruptdone@@YAXI@Z:PROC			; interruptdone
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\pit.cpp
;	COMDAT ?i86_pit_irq@@YAXXZ
_TEXT	SEGMENT
?i86_pit_irq@@YAXXZ PROC				; i86_pit_irq, COMDAT

; 34   : void _cdecl i86_pit_irq () {

	push	ebx
	push	esi
	push	edi

; 35   : 	//_asm pop eax
; 36   : 	//_asm mov _eip, eax
; 37   : 	//_asm push eax
; 38   : 	_asm add esp, 12

	add	esp, 12					; 0000000cH

; 39   : 	_asm pushad

	pushad

; 40   : 
; 41   : 	// increment tick count
; 42   : 	_pit_ticks++;

	inc	DWORD PTR __pit_ticks

; 43   : 	//switchTasks(_eip);
; 44   : 	// tell hal we are done
; 45   : 	interruptdone(0);

	push	0
	call	?interruptdone@@YAXI@Z			; interruptdone
	add	esp, 4

; 46   : 
; 47   : 	_asm popad

	popad

; 48   : 	_asm iretd

	iretd

; 49   : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?i86_pit_irq@@YAXXZ ENDP				; i86_pit_irq
_TEXT	ENDS
PUBLIC	?i86_pit_set_tick_count@@YAII@Z			; i86_pit_set_tick_count
; Function compile flags: /Ogtpy
;	COMDAT ?i86_pit_set_tick_count@@YAII@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?i86_pit_set_tick_count@@YAII@Z PROC			; i86_pit_set_tick_count, COMDAT

; 53   : 
; 54   : 	uint32_t ret = _pit_ticks;
; 55   : 	_pit_ticks = i;

	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR __pit_ticks
	mov	DWORD PTR __pit_ticks, ecx

; 56   : 	return ret;
; 57   : }

	ret	0
?i86_pit_set_tick_count@@YAII@Z ENDP			; i86_pit_set_tick_count
_TEXT	ENDS
PUBLIC	?i86_pit_get_tick_count@@YAIXZ			; i86_pit_get_tick_count
; Function compile flags: /Ogtpy
;	COMDAT ?i86_pit_get_tick_count@@YAIXZ
_TEXT	SEGMENT
?i86_pit_get_tick_count@@YAIXZ PROC			; i86_pit_get_tick_count, COMDAT

; 62   : 
; 63   : 	return _pit_ticks;

	mov	eax, DWORD PTR __pit_ticks

; 64   : }

	ret	0
?i86_pit_get_tick_count@@YAIXZ ENDP			; i86_pit_get_tick_count
_TEXT	ENDS
PUBLIC	?i86_pit_send_command@@YAXE@Z			; i86_pit_send_command
EXTRN	?outport@@YAXGE@Z:PROC				; outport
; Function compile flags: /Ogtpy
;	COMDAT ?i86_pit_send_command@@YAXE@Z
_TEXT	SEGMENT
_cmd$ = 8						; size = 1
?i86_pit_send_command@@YAXE@Z PROC			; i86_pit_send_command, COMDAT

; 69   : 
; 70   : 	outport (I86_PIT_REG_COMMAND, cmd);

	mov	eax, DWORD PTR _cmd$[esp-4]
	push	eax
	push	67					; 00000043H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 8

; 71   : }

	ret	0
?i86_pit_send_command@@YAXE@Z ENDP			; i86_pit_send_command
_TEXT	ENDS
PUBLIC	?i86_pit_send_data@@YAXGE@Z			; i86_pit_send_data
; Function compile flags: /Ogtpy
;	COMDAT ?i86_pit_send_data@@YAXGE@Z
_TEXT	SEGMENT
_data$ = 8						; size = 2
_counter$ = 12						; size = 1
?i86_pit_send_data@@YAXGE@Z PROC			; i86_pit_send_data, COMDAT

; 76   : 
; 77   : 	uint8_t	port= (counter==I86_PIT_OCW_COUNTER_0) ? I86_PIT_REG_COUNTER0 :
; 78   : 		((counter==I86_PIT_OCW_COUNTER_1) ? I86_PIT_REG_COUNTER1 : I86_PIT_REG_COUNTER2);

	mov	al, BYTE PTR _counter$[esp-4]
	test	al, al
	jne	SHORT $LN3@i86_pit_se

; 79   : 
; 80   : 	outport (port, (uint8_t)data);

	mov	ecx, DWORD PTR _data$[esp-4]
	mov	al, 64					; 00000040H
	movzx	eax, al
	mov	DWORD PTR _counter$[esp-4], ecx
	mov	DWORD PTR _data$[esp-4], eax
	jmp	?outport@@YAXGE@Z			; outport
$LN3@i86_pit_se:
	mov	ecx, DWORD PTR _data$[esp-4]
	cmp	al, 64					; 00000040H
	setne	al
	add	al, 65					; 00000041H
	movzx	eax, al
	mov	DWORD PTR _counter$[esp-4], ecx
	mov	DWORD PTR _data$[esp-4], eax
	jmp	?outport@@YAXGE@Z			; outport
?i86_pit_send_data@@YAXGE@Z ENDP			; i86_pit_send_data
_TEXT	ENDS
PUBLIC	?i86_pit_read_data@@YAEG@Z			; i86_pit_read_data
EXTRN	?inport@@YAEG@Z:PROC				; inport
; Function compile flags: /Ogtpy
;	COMDAT ?i86_pit_read_data@@YAEG@Z
_TEXT	SEGMENT
_counter$ = 8						; size = 2
?i86_pit_read_data@@YAEG@Z PROC				; i86_pit_read_data, COMDAT

; 86   : 
; 87   : 	uint8_t	port= (counter==I86_PIT_OCW_COUNTER_0) ? I86_PIT_REG_COUNTER0 :
; 88   : 		((counter==I86_PIT_OCW_COUNTER_1) ? I86_PIT_REG_COUNTER1 : I86_PIT_REG_COUNTER2);

	mov	ax, WORD PTR _counter$[esp-4]
	test	ax, ax
	jne	SHORT $LN3@i86_pit_re
	mov	al, 64					; 00000040H

; 89   : 
; 90   : 	return inport (port);

	movzx	eax, al
	mov	ecx, eax
	mov	DWORD PTR _counter$[esp-4], ecx
	jmp	?inport@@YAEG@Z				; inport
$LN3@i86_pit_re:

; 86   : 
; 87   : 	uint8_t	port= (counter==I86_PIT_OCW_COUNTER_0) ? I86_PIT_REG_COUNTER0 :
; 88   : 		((counter==I86_PIT_OCW_COUNTER_1) ? I86_PIT_REG_COUNTER1 : I86_PIT_REG_COUNTER2);

	cmp	ax, 64					; 00000040H
	setne	al
	add	al, 65					; 00000041H

; 89   : 
; 90   : 	return inport (port);

	movzx	eax, al
	mov	ecx, eax
	mov	DWORD PTR _counter$[esp-4], ecx
	jmp	?inport@@YAEG@Z				; inport
?i86_pit_read_data@@YAEG@Z ENDP				; i86_pit_read_data
_TEXT	ENDS
PUBLIC	?i86_pit_start_counter@@YAXIEE@Z		; i86_pit_start_counter
; Function compile flags: /Ogtpy
;	COMDAT ?i86_pit_start_counter@@YAXIEE@Z
_TEXT	SEGMENT
_freq$ = 8						; size = 4
_counter$ = 12						; size = 1
_mode$ = 16						; size = 1
?i86_pit_start_counter@@YAXIEE@Z PROC			; i86_pit_start_counter, COMDAT

; 96   : 
; 97   : 	if (freq==0)

	mov	eax, DWORD PTR _freq$[esp-4]
	test	eax, eax
	je	SHORT $LN2@i86_pit_st

; 98   : 		return;
; 99   : 
; 100  : 	uint16_t divisor = uint16_t(1193181 / (uint16_t)freq);

	movzx	ecx, ax
	mov	eax, 1193181				; 001234ddH
	cdq
	idiv	ecx
	mov	dl, BYTE PTR _mode$[esp-4]
	and	dl, 15					; 0000000fH

; 101  : 
; 102  : 	// send operational command
; 103  : 	uint8_t ocw=0;
; 104  : 	ocw = (ocw & ~I86_PIT_OCW_MASK_MODE) | mode;
; 105  : 	ocw = (ocw & ~I86_PIT_OCW_MASK_RL) | I86_PIT_OCW_RL_DATA;
; 106  : 	ocw = (ocw & ~I86_PIT_OCW_MASK_COUNTER) | counter;

	or	dl, BYTE PTR _counter$[esp-4]
	push	esi
	or	dl, 48					; 00000030H
	movzx	esi, ax

; 107  : 	i86_pit_send_command (ocw);

	movzx	eax, dl
	push	eax
	push	67					; 00000043H
	call	?outport@@YAXGE@Z			; outport

; 108  : 
; 109  : 	// set frequency rate
; 110  : 	i86_pit_send_data (divisor & 0xff, 0);

	push	esi
	push	64					; 00000040H
	call	?outport@@YAXGE@Z			; outport

; 111  : 	i86_pit_send_data ((divisor >> 8) & 0xff, 0);

	shr	esi, 8
	push	esi
	push	64					; 00000040H
	call	?outport@@YAXGE@Z			; outport
	add	esp, 24					; 00000018H

; 112  : 
; 113  : 	// reset tick count
; 114  : 	_pit_ticks=0;

	mov	DWORD PTR __pit_ticks, 0
	pop	esi
$LN2@i86_pit_st:

; 115  : }

	ret	0
?i86_pit_start_counter@@YAXIEE@Z ENDP			; i86_pit_start_counter
_TEXT	ENDS
PUBLIC	?i86_pit_initialize@@YA_NXZ			; i86_pit_initialize
EXTRN	?setint@@YAXHP6AXXZ@Z:PROC			; setint
; Function compile flags: /Ogtpy
;	COMDAT ?i86_pit_initialize@@YA_NXZ
_TEXT	SEGMENT
?i86_pit_initialize@@YA_NXZ PROC			; i86_pit_initialize, COMDAT

; 120  : 
; 121  : 	// Install our interrupt handler (irq 0 uses interrupt 32)
; 122  : 	setint(32, i86_pit_irq);

	push	OFFSET ?i86_pit_irq@@YAXXZ		; i86_pit_irq
	push	32					; 00000020H
	call	?setint@@YAXHP6AXXZ@Z			; setint

; 123  : 
; 124  : 	// we are initialized
; 125  : 	_pit_bIsInit = true;

	mov	al, 1
	add	esp, 8
	mov	BYTE PTR __pit_bIsInit, al

; 126  : 
; 127  : 	return true;
; 128  : }

	ret	0
?i86_pit_initialize@@YA_NXZ ENDP			; i86_pit_initialize
_TEXT	ENDS
PUBLIC	?i86_pit_is_initialized@@YA_NXZ			; i86_pit_is_initialized
; Function compile flags: /Ogtpy
;	COMDAT ?i86_pit_is_initialized@@YA_NXZ
_TEXT	SEGMENT
?i86_pit_is_initialized@@YA_NXZ PROC			; i86_pit_is_initialized, COMDAT

; 133  : 
; 134  : 	return _pit_bIsInit;

	mov	al, BYTE PTR __pit_bIsInit

; 135  : }

	ret	0
?i86_pit_is_initialized@@YA_NXZ ENDP			; i86_pit_is_initialized
_TEXT	ENDS
END
