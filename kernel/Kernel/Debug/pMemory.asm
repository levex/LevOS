; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\pMemory.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_HEAP	DD	01H DUP (?)
__last	DD	01H DUP (?)
_BSS	ENDS
PUBLIC	?memcpy@@YAXPAD0H@Z				; memcpy
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\pmemory.cpp
;	COMDAT ?memcpy@@YAXPAD0H@Z
_TEXT	SEGMENT
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_count$ = 16						; size = 4
?memcpy@@YAXPAD0H@Z PROC				; memcpy, COMDAT

; 8    :     while (count--) {

	mov	ecx, DWORD PTR _count$[esp-4]
	test	ecx, ecx
	je	SHORT $LN6@memcpy
	mov	eax, DWORD PTR _to$[esp-4]
	push	esi
	mov	esi, DWORD PTR _from$[esp]
	sub	esi, eax
$LL2@memcpy:

; 9    :         *to++ = *from++;

	mov	dl, BYTE PTR [esi+eax]
	mov	BYTE PTR [eax], dl
	inc	eax
	dec	ecx
	jne	SHORT $LL2@memcpy
	pop	esi
$LN6@memcpy:

; 10   :     }
; 11   : }

	ret	0
?memcpy@@YAXPAD0H@Z ENDP				; memcpy
_TEXT	ENDS
PUBLIC	?memcpyTF@@YAXPAD0H@Z				; memcpyTF
; Function compile flags: /Ogtpy
;	COMDAT ?memcpyTF@@YAXPAD0H@Z
_TEXT	SEGMENT
_to$ = 8						; size = 4
_from$ = 12						; size = 4
_count$ = 16						; size = 4
?memcpyTF@@YAXPAD0H@Z PROC				; memcpyTF, COMDAT

; 15   :     while (count--) {

	mov	ecx, DWORD PTR _count$[esp-4]
	test	ecx, ecx
	je	SHORT $LN6@memcpyTF
	mov	eax, DWORD PTR _from$[esp-4]
	push	esi
	mov	esi, DWORD PTR _to$[esp]
	sub	esi, eax
$LL2@memcpyTF:

; 16   :         *to++ = *from++;

	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [esi+eax], dl
	inc	eax
	dec	ecx
	jne	SHORT $LL2@memcpyTF
	pop	esi
$LN6@memcpyTF:

; 17   :     }
; 18   : }

	ret	0
?memcpyTF@@YAXPAD0H@Z ENDP				; memcpyTF
_TEXT	ENDS
PUBLIC	?memset@@YAPAXPAXDI@Z				; memset
; Function compile flags: /Ogtpy
;	COMDAT ?memset@@YAPAXPAXDI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_val$ = 12						; size = 1
_count$ = 16						; size = 4
?memset@@YAPAXPAXDI@Z PROC				; memset, COMDAT

; 23   :     unsigned char *temp = (unsigned char *)dest;
; 24   : 	for( ; count != 0; count--, temp[count] = val);

	mov	ecx, DWORD PTR _count$[esp-4]
	mov	eax, DWORD PTR _dest$[esp-4]
	test	ecx, ecx
	je	SHORT $LN1@memset
	mov	dl, BYTE PTR _val$[esp-4]
$LL3@memset:
	dec	ecx
	mov	BYTE PTR [eax+ecx], dl
	jne	SHORT $LL3@memset
$LN1@memset:

; 25   : 	return dest;
; 26   : }

	ret	0
?memset@@YAPAXPAXDI@Z ENDP				; memset
_TEXT	ENDS
PUBLIC	?memsetw@@YAPAGPAGGI@Z				; memsetw
; Function compile flags: /Ogtpy
;	COMDAT ?memsetw@@YAPAGPAGGI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_val$ = 12						; size = 2
_count$ = 16						; size = 4
?memsetw@@YAPAGPAGGI@Z PROC				; memsetw, COMDAT

; 32   :     for( ; count != 0; count--)

	mov	ecx, DWORD PTR _count$[esp-4]
	test	ecx, ecx
	je	SHORT $LN8@memsetw

; 31   :     unsigned short *temp = (unsigned short *)dest;

	mov	eax, DWORD PTR _val$[esp-4]
	mov	edx, DWORD PTR _dest$[esp-4]
	push	esi
	movzx	esi, ax
	mov	eax, esi
	shl	esi, 16					; 00000010H
	push	edi
	or	eax, esi
	shr	ecx, 1
	mov	edi, edx
	rep stosd
	adc	ecx, ecx
	rep stosw
	pop	edi

; 33   : 		*temp++ = val;
; 34   :     return dest;

	mov	eax, edx
	pop	esi

; 35   : }

	ret	0
$LN8@memsetw:

; 33   : 		*temp++ = val;
; 34   :     return dest;

	mov	eax, DWORD PTR _dest$[esp-4]

; 35   : }

	ret	0
?memsetw@@YAPAGPAGGI@Z ENDP				; memsetw
_TEXT	ENDS
PUBLIC	?pm_setup@@YA_NPAD@Z				; pm_setup
; Function compile flags: /Ogtpy
;	COMDAT ?pm_setup@@YA_NPAD@Z
_TEXT	SEGMENT
_heap$ = 8						; size = 4
?pm_setup@@YA_NPAD@Z PROC				; pm_setup, COMDAT

; 39   : 	HEAP = heap;

	mov	eax, DWORD PTR _heap$[esp-4]
	mov	DWORD PTR _HEAP, eax

; 40   : 	//_last = (unsigned int)&HEAP;
; 41   : 	return (heap == HEAP)?true:false;

	mov	al, 1

; 42   : }

	ret	0
?pm_setup@@YA_NPAD@Z ENDP				; pm_setup
_TEXT	ENDS
PUBLIC	?malloc@@YAPAXH@Z				; malloc
; Function compile flags: /Ogtpy
;	COMDAT ?malloc@@YAPAXH@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
?malloc@@YAPAXH@Z PROC					; malloc, COMDAT

; 46   : 	void* ret;
; 47   : 	ret = (void*)HEAP;

	mov	ecx, DWORD PTR _HEAP
	mov	eax, ecx

; 48   : 	HEAP += bytes;

	add	ecx, DWORD PTR _bytes$[esp-4]
	mov	DWORD PTR _HEAP, ecx

; 49   : 	return ret;
; 50   : }

	ret	0
?malloc@@YAPAXH@Z ENDP					; malloc
_TEXT	ENDS
PUBLIC	?malloc_p@@YAPAXH@Z				; malloc_p
; Function compile flags: /Ogtpy
;	COMDAT ?malloc_p@@YAPAXH@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
?malloc_p@@YAPAXH@Z PROC				; malloc_p, COMDAT

; 53   : 	void* ret;
; 54   : 	ret = (void*)(((int)HEAP + 0x1000)&0xFFFFF000);

	mov	eax, DWORD PTR _HEAP

; 55   : 	HEAP = (char*)((int)ret + bytes);

	mov	ecx, DWORD PTR _bytes$[esp-4]
	add	eax, 4096				; 00001000H
	and	eax, -4096				; fffff000H
	lea	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _HEAP, edx

; 56   : 	return ret;
; 57   : }

	ret	0
?malloc_p@@YAPAXH@Z ENDP				; malloc_p
_TEXT	ENDS
PUBLIC	?malloc_ps@@YAPAXPADH@Z				; malloc_ps
; Function compile flags: /Ogtpy
;	COMDAT ?malloc_ps@@YAPAXPADH@Z
_TEXT	SEGMENT
_start$ = 8						; size = 4
_bytes$ = 12						; size = 4
?malloc_ps@@YAPAXPADH@Z PROC				; malloc_ps, COMDAT

; 60   : 	return start;

	mov	eax, DWORD PTR _start$[esp-4]

; 61   : }

	ret	0
?malloc_ps@@YAPAXPADH@Z ENDP				; malloc_ps
_TEXT	ENDS
END
