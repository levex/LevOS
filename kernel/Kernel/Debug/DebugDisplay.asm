; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\DebugDisplay.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?tbuf@@3PADA					; tbuf
PUBLIC	?bchars@@3PADA					; bchars
_BSS	SEGMENT
?tbuf@@3PADA DB	020H DUP (?)				; tbuf
__xPos	DD	01H DUP (?)
__yPos	DD	01H DUP (?)
__startX DD	01H DUP (?)
__startY DD	01H DUP (?)
__color	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?bchars@@3PADA DB 030H					; bchars
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
_DATA	ENDS
PUBLIC	?DebugGetX@@YAHXZ				; DebugGetX
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\debugdisplay.cpp
;	COMDAT ?DebugGetX@@YAHXZ
_TEXT	SEGMENT
?DebugGetX@@YAHXZ PROC					; DebugGetX, COMDAT

; 22   : 	return _xPos/2;

	mov	eax, DWORD PTR __xPos
	shr	eax, 1

; 23   : }

	ret	0
?DebugGetX@@YAHXZ ENDP					; DebugGetX
_TEXT	ENDS
PUBLIC	?DebugGetY@@YAHXZ				; DebugGetY
; Function compile flags: /Ogtpy
;	COMDAT ?DebugGetY@@YAHXZ
_TEXT	SEGMENT
?DebugGetY@@YAHXZ PROC					; DebugGetY, COMDAT

; 27   : 	return _yPos/2;

	mov	eax, DWORD PTR __yPos
	shr	eax, 1

; 28   : }

	ret	0
?DebugGetY@@YAHXZ ENDP					; DebugGetY
_TEXT	ENDS
PUBLIC	?DebugGotoRXY@@YAXII@Z				; DebugGotoRXY
; Function compile flags: /Ogtpy
;	COMDAT ?DebugGotoRXY@@YAXII@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?DebugGotoRXY@@YAXII@Z PROC				; DebugGotoRXY, COMDAT

; 40   : 
; 41   : 	// reposition starting vectors for next text to follow
; 42   : 	// multiply by 2 do to the video modes 2byte per character layout
; 43   : 	_xPos = _xPos + x;

	mov	eax, DWORD PTR _x$[esp-4]

; 44   : 	_yPos = _yPos + y;

	mov	ecx, DWORD PTR _y$[esp-4]
	add	DWORD PTR __xPos, eax
	add	DWORD PTR __yPos, ecx

; 45   : }

	ret	0
?DebugGotoRXY@@YAXII@Z ENDP				; DebugGotoRXY
_TEXT	ENDS
PUBLIC	?DebugNextline@@YAXXZ				; DebugNextline
; Function compile flags: /Ogtpy
;	COMDAT ?DebugNextline@@YAXXZ
_TEXT	SEGMENT
?DebugNextline@@YAXXZ PROC				; DebugNextline, COMDAT

; 79   : 		_yPos+=2;
; 80   : 		_xPos=_startX;

	mov	eax, DWORD PTR __startX
	add	DWORD PTR __yPos, 2
	mov	DWORD PTR __xPos, eax

; 81   : 		return;
; 82   : }

	ret	0
?DebugNextline@@YAXXZ ENDP				; DebugNextline
_TEXT	ENDS
PUBLIC	?itoa@@YAXIIPAD@Z				; itoa
; Function compile flags: /Ogtpy
;	COMDAT ?itoa@@YAXIIPAD@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_buf$ = 16						; size = 4
?itoa@@YAXIIPAD@Z PROC					; itoa, COMDAT

; 88   :    int pos = 0;
; 89   :    int opos = 0;
; 90   :    int top = 0;
; 91   : 
; 92   :    if (i == 0 || base > 16) {

	mov	eax, DWORD PTR _i$[esp-4]
	xor	ecx, ecx
	push	esi
	test	eax, eax
	je	SHORT $LN6@itoa
	mov	esi, DWORD PTR _base$[esp]
	cmp	esi, 16					; 00000010H
	ja	SHORT $LN6@itoa
$LL5@itoa:

; 94   :       buf[1] = '\0';
; 95   :       return;
; 96   :    }
; 97   : 
; 98   :    while (i != 0) {
; 99   :       tbuf[pos] = bchars[i % base];

	xor	edx, edx
	div	esi

; 100  :       pos++;

	inc	ecx
	mov	dl, BYTE PTR ?bchars@@3PADA[edx]
	mov	BYTE PTR ?tbuf@@3PADA[ecx-1], dl
	test	eax, eax
	jne	SHORT $LL5@itoa

; 101  :       i /= base;
; 102  :    }
; 103  :    top=pos--;

	mov	esi, ecx
	push	edi

; 104  :    for (opos=0; opos<top; pos--,opos++) {

	mov	edi, DWORD PTR _buf$[esp+4]
	test	esi, esi
	jle	SHORT $LN1@itoa

; 101  :       i /= base;
; 102  :    }
; 103  :    top=pos--;

	lea	ecx, DWORD PTR ?tbuf@@3PADA[ecx-1]
	npad	6
$LL3@itoa:

; 105  :       buf[opos] = tbuf[pos];

	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edi], dl
	inc	eax
	dec	ecx
	cmp	eax, esi
	jl	SHORT $LL3@itoa
$LN1@itoa:

; 106  :    }
; 107  :    buf[opos] = 0;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi

; 108  : }

	ret	0
$LN6@itoa:

; 93   :       buf[0] = '0';

	mov	eax, DWORD PTR _buf$[esp]
	mov	WORD PTR [eax], 48			; 00000030H
	pop	esi

; 108  : }

	ret	0
?itoa@@YAXIIPAD@Z ENDP					; itoa
_TEXT	ENDS
PUBLIC	?itoa_s@@YAXHIPAD@Z				; itoa_s
; Function compile flags: /Ogtpy
;	COMDAT ?itoa_s@@YAXHIPAD@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_buf$ = 16						; size = 4
?itoa_s@@YAXHIPAD@Z PROC				; itoa_s, COMDAT

; 111  :    if (base > 16) return;

	mov	edx, DWORD PTR _base$[esp-4]
	cmp	edx, 16					; 00000010H
	ja	SHORT $LN3@itoa_s

; 112  :    if (i < 0) {

	mov	eax, DWORD PTR _i$[esp-4]

; 113  :       *buf++ = '-';

	mov	ecx, DWORD PTR _buf$[esp-4]
	test	eax, eax
	jns	SHORT $LN1@itoa_s
	mov	BYTE PTR [ecx], 45			; 0000002dH
	inc	ecx

; 114  :       i *= -1;

	neg	eax
$LN1@itoa_s:

; 115  :    }
; 116  :    itoa(i,base,buf);

	mov	DWORD PTR _buf$[esp-4], ecx
	mov	DWORD PTR _base$[esp-4], edx
	mov	DWORD PTR _i$[esp-4], eax
	jmp	?itoa@@YAXIIPAD@Z			; itoa
$LN3@itoa_s:

; 117  : }

	ret	0
?itoa_s@@YAXHIPAD@Z ENDP				; itoa_s
_TEXT	ENDS
PUBLIC	?DebugSetColor@@YAII@Z				; DebugSetColor
; Function compile flags: /Ogtpy
;	COMDAT ?DebugSetColor@@YAII@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?DebugSetColor@@YAII@Z PROC				; DebugSetColor, COMDAT

; 120  : 
; 121  : 	unsigned t=_color;
; 122  : 	_color=c;

	mov	ecx, DWORD PTR _c$[esp-4]
	mov	eax, DWORD PTR __color
	mov	DWORD PTR __color, ecx

; 123  : 	return t;
; 124  : }

	ret	0
?DebugSetColor@@YAII@Z ENDP				; DebugSetColor
_TEXT	ENDS
PUBLIC	?DebugGotoXY@@YAXII@Z				; DebugGotoXY
; Function compile flags: /Ogtpy
;	COMDAT ?DebugGotoXY@@YAXII@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?DebugGotoXY@@YAXII@Z PROC				; DebugGotoXY, COMDAT

; 127  : 
; 128  : 	// reposition starting vectors for next text to follow
; 129  : 	// multiply by 2 do to the video modes 2byte per character layout
; 130  : 	_xPos = x*2;

	mov	eax, DWORD PTR _x$[esp-4]

; 131  : 	_yPos = y*2;

	mov	ecx, DWORD PTR _y$[esp-4]
	add	eax, eax
	add	ecx, ecx
	mov	DWORD PTR __xPos, eax
	mov	DWORD PTR __yPos, ecx

; 132  : 	_startX=_xPos;

	mov	DWORD PTR __startX, eax

; 133  : 	_startY=_yPos;

	mov	DWORD PTR __startY, ecx

; 134  : }

	ret	0
?DebugGotoXY@@YAXII@Z ENDP				; DebugGotoXY
_TEXT	ENDS
PUBLIC	?DebugClrScr@@YAXG@Z				; DebugClrScr
; Function compile flags: /Ogtpy
;	COMDAT ?DebugClrScr@@YAXG@Z
_TEXT	SEGMENT
_c$ = 8							; size = 2
?DebugClrScr@@YAXG@Z PROC				; DebugClrScr, COMDAT

; 137  : 
; 138  : 	unsigned char* p = (unsigned char*)VID_MEMORY;
; 139  : 	//if(c == 0x00) c = _color;
; 140  : 
; 141  : 	for (int i=0; i<160*30; i+=2) {

	mov	dl, BYTE PTR _c$[esp-4]
	mov	eax, 753665				; 000b8001H
	mov	ecx, 2400				; 00000960H
	npad	2
$LL3@DebugClrSc:

; 142  : 
; 143  : 		p[i] = ' ';  /* Need to watch out for MSVC++ optomization memset() call */

	mov	BYTE PTR [eax-1], 32			; 00000020H

; 144  : 		p[i+1] = c;

	mov	BYTE PTR [eax], dl
	add	eax, 2
	dec	ecx
	jne	SHORT $LL3@DebugClrSc

; 145  : 	}
; 146  : 
; 147  : 	// go to start of previous set vector
; 148  : 	_xPos=_startX;_yPos=_startY;

	mov	eax, DWORD PTR __startX
	mov	ecx, DWORD PTR __startY
	mov	DWORD PTR __xPos, eax
	mov	DWORD PTR __yPos, ecx

; 149  : }

	ret	0
?DebugClrScr@@YAXG@Z ENDP				; DebugClrScr
_TEXT	ENDS
PUBLIC	?getPixel@@YADFF@Z				; getPixel
; Function compile flags: /Ogtpy
;	COMDAT ?getPixel@@YADFF@Z
_TEXT	SEGMENT
_x$ = 8							; size = 2
_y$ = 12						; size = 2
?getPixel@@YADFF@Z PROC					; getPixel, COMDAT

; 153  : 	volatile unsigned char* p = (unsigned char*)VID_MEMORY;
; 154  : 	int lin = x + y * COLS;

	movsx	eax, WORD PTR _y$[esp-4]
	movsx	ecx, WORD PTR _x$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	add	eax, ecx

; 155  : 	return p[lin*2];

	mov	al, BYTE PTR [eax+eax+753664]

; 156  : }

	ret	0
?getPixel@@YADFF@Z ENDP					; getPixel
_TEXT	ENDS
PUBLIC	?setPixel@@YAXFFD@Z				; setPixel
; Function compile flags: /Ogtpy
;	COMDAT ?setPixel@@YAXFFD@Z
_TEXT	SEGMENT
_x$ = 8							; size = 2
_y$ = 12						; size = 2
_c$ = 16						; size = 1
?setPixel@@YAXFFD@Z PROC				; setPixel, COMDAT

; 160  : 	volatile unsigned char* p = (unsigned char*)VID_MEMORY;
; 161  : 	int lin = x + y * COLS;
; 162  : 	p[lin*2] = c;

	movsx	eax, WORD PTR _y$[esp-4]
	movsx	ecx, WORD PTR _x$[esp-4]
	mov	dl, BYTE PTR _c$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	add	eax, ecx
	mov	BYTE PTR [eax*2+753664], dl

; 163  : }

	ret	0
?setPixel@@YAXFFD@Z ENDP				; setPixel
_TEXT	ENDS
PUBLIC	?DebugScrollUp@@YAXXZ				; DebugScrollUp
EXTRN	?memcpy@@YAXPAD0H@Z:PROC			; memcpy
; Function compile flags: /Ogtpy
;	COMDAT ?DebugScrollUp@@YAXXZ
_TEXT	SEGMENT
?DebugScrollUp@@YAXXZ PROC				; DebugScrollUp, COMDAT

; 166  : {

	push	esi

; 167  : 	volatile unsigned char* p = (unsigned char*)VID_MEMORY;
; 168  : 	for(int y = 0; y < LINE; y++)

	mov	esi, 753824				; 000b80a0H
	npad	10
$LL3@DebugScrol:

; 169  : 	{
; 170  : 		memcpy((char*)(VID_MEMORY + y*COLS*2+COLS*2), (char*)(VID_MEMORY + y*COLS*2), COLS*2);

	push	160					; 000000a0H
	lea	eax, DWORD PTR [esi-160]
	push	eax
	push	esi
	call	?memcpy@@YAXPAD0H@Z			; memcpy
	add	esi, 160				; 000000a0H
	add	esp, 12					; 0000000cH
	cmp	esi, 757824				; 000b9040H
	jl	SHORT $LL3@DebugScrol

; 171  : 		//memset((char*)(VID_MEMORY + y*COLS*2+COLS*2), COLS*2, ' ');
; 172  : 	}
; 173  : 	_yPos -= 2;

	sub	DWORD PTR __yPos, 2
	pop	esi

; 174  : 	//DebugGotoXY(_startX/2,_startY/2-1);
; 175  : }

	ret	0
?DebugScrollUp@@YAXXZ ENDP				; DebugScrollUp
_TEXT	ENDS
PUBLIC	?DebugReset@@YAXXZ				; DebugReset
; Function compile flags: /Ogtpy
;	COMDAT ?DebugReset@@YAXXZ
_TEXT	SEGMENT
?DebugReset@@YAXXZ PROC					; DebugReset, COMDAT

; 31   : {

	push	esi

; 32   : 	_xPos = 0;
; 33   : 	_yPos = 0;
; 34   : 	_startX = 0;

	xor	esi, esi
	mov	DWORD PTR __startX, esi

; 35   : 	_startY = 0;

	mov	DWORD PTR __startY, esi
	mov	eax, 753665				; 000b8001H
	mov	ecx, 2400				; 00000960H
	mov	dl, 32					; 00000020H
	npad	5

; 36   : 	DebugClrScr(0x17);

$LL5@DebugReset:
	mov	BYTE PTR [eax-1], dl
	mov	BYTE PTR [eax], 23			; 00000017H
	add	eax, 2
	dec	ecx
	jne	SHORT $LL5@DebugReset
	mov	DWORD PTR __xPos, esi
	mov	DWORD PTR __yPos, esi
	pop	esi

; 37   : }

	ret	0
?DebugReset@@YAXXZ ENDP					; DebugReset
_TEXT	ENDS
PUBLIC	?DebugPutc@@YAXE@Z				; DebugPutc
EXTRN	?VGA_put_char@@YAXHHDD@Z:PROC			; VGA_put_char
EXTRN	?isVGA@@YA_NXZ:PROC				; isVGA
; Function compile flags: /Ogtpy
;	COMDAT ?DebugPutc@@YAXE@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?DebugPutc@@YAXE@Z PROC					; DebugPutc, COMDAT

; 47   : void DebugPutc (unsigned char c) {

	push	ebx

; 48   : 
; 49   : 	if (c==0)

	mov	ebx, DWORD PTR _c$[esp]
	test	bl, bl
	je	$LN7@DebugPutc

; 50   : 		return;
; 51   : 
; 52   : 	if (c == '\n'||c=='\r') {	/* start new line */

	cmp	bl, 10					; 0000000aH
	je	$LN4@DebugPutc
	cmp	bl, 13					; 0000000dH
	je	$LN4@DebugPutc

; 55   : 		return;
; 56   : 	}
; 57   : 
; 58   : 	if (_xPos > 79) {			/* start new line */

	cmp	DWORD PTR __xPos, 79			; 0000004fH
	jbe	SHORT $LN3@DebugPutc

; 59   : 		_yPos+=2;
; 60   : 		_xPos=_startX;

	mov	eax, DWORD PTR __startX
	add	DWORD PTR __yPos, 2
	mov	DWORD PTR __xPos, eax
	pop	ebx

; 75   : }

	ret	0
$LN3@DebugPutc:

; 61   : 		return;
; 62   : 	}
; 63   : 	if(_yPos >= 49)

	cmp	DWORD PTR __yPos, 49			; 00000031H
	jb	SHORT $LN2@DebugPutc

; 64   : 	{
; 65   : 		DebugScrollUp();

	call	?DebugScrollUp@@YAXXZ			; DebugScrollUp
$LN2@DebugPutc:

; 66   : 	}
; 67   : 	if(isVGA()) {

	call	?isVGA@@YA_NXZ				; isVGA
	test	al, al
	je	SHORT $LN1@DebugPutc

; 68   : 		VGA_put_char(_xPos++ * 8, _yPos * 8, c, 1);

	mov	eax, DWORD PTR __xPos
	mov	edx, DWORD PTR __yPos
	lea	ecx, DWORD PTR [eax*8]
	inc	eax
	push	1
	mov	DWORD PTR __xPos, eax
	push	ebx
	lea	eax, DWORD PTR [edx*8]
	push	eax
	push	ecx
	call	?VGA_put_char@@YAXHHDD@Z		; VGA_put_char
	add	esp, 16					; 00000010H
	pop	ebx

; 75   : }

	ret	0
$LN1@DebugPutc:

; 69   : 		return;
; 70   : 	}
; 71   : 	/* draw the character */
; 72   : 	unsigned char* p = (unsigned char*)VID_MEMORY + (_xPos++)*2 + _yPos * 80;

	mov	eax, DWORD PTR __yPos
	mov	ecx, DWORD PTR __xPos
	lea	edx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	inc	ecx
	lea	eax, DWORD PTR [eax+eax+753664]
	mov	DWORD PTR __xPos, ecx

; 73   : 	*p++ = c;
; 74   : 	*p =_color;

	mov	cl, BYTE PTR __color
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [eax+1], cl
	pop	ebx

; 75   : }

	ret	0
$LN4@DebugPutc:

; 53   : 		_yPos+=2;
; 54   : 		_xPos=_startX;

	mov	edx, DWORD PTR __startX
	add	DWORD PTR __yPos, 2
	mov	DWORD PTR __xPos, edx
$LN7@DebugPutc:
	pop	ebx

; 75   : }

	ret	0
?DebugPutc@@YAXE@Z ENDP					; DebugPutc
_TEXT	ENDS
PUBLIC	?DebugPuts@@YAXPAD@Z				; DebugPuts
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
; Function compile flags: /Ogtpy
;	COMDAT ?DebugPuts@@YAXPAD@Z
_TEXT	SEGMENT
$T2954 = 8						; size = 1
_str$ = 8						; size = 4
?DebugPuts@@YAXPAD@Z PROC				; DebugPuts, COMDAT

; 177  : void DebugPuts (char* str) {

	push	edi

; 178  : 
; 179  : 	if (!str)

	mov	edi, DWORD PTR _str$[esp]
	test	edi, edi
	je	$LN1@DebugPuts

; 180  : 		return;
; 181  : 
; 182  : 	for (size_t i=0; i<strlen (str); i++)

	push	esi
	push	edi
	xor	esi, esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	test	eax, eax
	je	$LN18@DebugPuts
	push	ebx
$LL3@DebugPuts:

; 183  : 		DebugPutc (str[i]);

	mov	bl, BYTE PTR [esi+edi]
	mov	BYTE PTR $T2954[esp+8], bl
	test	bl, bl
	je	$LN2@DebugPuts
	cmp	bl, 10					; 0000000aH
	je	$LN10@DebugPuts
	cmp	bl, 13					; 0000000dH
	je	$LN10@DebugPuts
	cmp	DWORD PTR __xPos, 79			; 0000004fH
	jbe	SHORT $LN9@DebugPuts
	mov	eax, DWORD PTR __startX
	mov	DWORD PTR __xPos, eax
	jmp	$LN20@DebugPuts
$LN9@DebugPuts:
	cmp	DWORD PTR __yPos, 49			; 00000031H
	jb	SHORT $LN8@DebugPuts
	call	?DebugScrollUp@@YAXXZ			; DebugScrollUp
$LN8@DebugPuts:
	call	?isVGA@@YA_NXZ				; isVGA
	test	al, al
	je	SHORT $LN7@DebugPuts
	mov	eax, DWORD PTR __xPos
	mov	edx, DWORD PTR $T2954[esp+8]
	lea	ecx, DWORD PTR [eax*8]
	inc	eax
	push	1
	mov	DWORD PTR __xPos, eax
	mov	eax, DWORD PTR __yPos
	push	edx
	lea	edx, DWORD PTR [eax*8]
	push	edx
	push	ecx
	call	?VGA_put_char@@YAXHHDD@Z		; VGA_put_char
	add	esp, 16					; 00000010H
	jmp	SHORT $LN2@DebugPuts
$LN7@DebugPuts:
	mov	eax, DWORD PTR __yPos
	mov	ecx, DWORD PTR __xPos
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*8]
	inc	ecx
	lea	eax, DWORD PTR [eax+eax+753664]
	mov	DWORD PTR __xPos, ecx
	mov	cl, BYTE PTR __color
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [eax+1], cl
	jmp	SHORT $LN2@DebugPuts
$LN10@DebugPuts:
	mov	edx, DWORD PTR __startX
	mov	DWORD PTR __xPos, edx
$LN20@DebugPuts:
	add	DWORD PTR __yPos, 2
$LN2@DebugPuts:

; 180  : 		return;
; 181  : 
; 182  : 	for (size_t i=0; i<strlen (str); i++)

	push	edi
	inc	esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	esi, eax
	jb	$LL3@DebugPuts
	pop	ebx
$LN18@DebugPuts:
	pop	esi
$LN1@DebugPuts:
	pop	edi

; 184  : }

	ret	0
?DebugPuts@@YAXPAD@Z ENDP				; DebugPuts
_TEXT	ENDS
PUBLIC	?DebugPrintf@@YAHPBDZZ				; DebugPrintf
EXTRN	?strcpy@@YAPADPADPBD@Z:PROC			; strcpy
; Function compile flags: /Ogtpy
;	COMDAT ?DebugPrintf@@YAHPBDZZ
_TEXT	SEGMENT
_i$2790 = -164						; size = 4
_str$2854 = -160					; size = 32
_str$2844 = -160					; size = 32
_str$2822 = -160					; size = 32
_str$2833 = -128					; size = 128
_str$ = 8						; size = 4
?DebugPrintf@@YAHPBDZZ PROC				; DebugPrintf, COMDAT

; 186  : int DebugPrintf (const char* str, ...) {

	sub	esp, 164				; 000000a4H
	push	ebp

; 187  : 
; 188  : 	if(!str)

	mov	ebp, DWORD PTR _str$[esp+164]
	test	ebp, ebp
	jne	SHORT $LN16@DebugPrint

; 189  : 		return 0;

	xor	eax, eax
	pop	ebp

; 263  : 		}
; 264  : 
; 265  : 	}
; 266  : 
; 267  : 	va_end (args);
; 268  : }

	add	esp, 164				; 000000a4H
	ret	0
$LN16@DebugPrint:
	push	esi

; 193  : 
; 194  : 	for (size_t i=0; i<strlen(str);i++) {

	xor	esi, esi
	push	ebp
	mov	DWORD PTR _i$2790[esp+176], esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	test	eax, eax
	je	$LN83@DebugPrint

; 190  : 
; 191  : 	va_list		args;
; 192  : 	va_start (args, str);

	push	ebx
	lea	ebx, DWORD PTR _str$[esp+172]
	push	edi
	npad	3
$LL82@DebugPrint:

; 195  : 
; 196  : 		switch (str[i]) {

	movzx	eax, BYTE PTR [esi+ebp]
	cmp	al, 37					; 00000025H
	je	SHORT $LN10@DebugPrint

; 256  : 				}
; 257  : 
; 258  : 				break;
; 259  : 
; 260  : 			default:
; 261  : 				DebugPutc (str[i]);

	push	eax
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4

; 262  : 				break;

	jmp	$LN14@DebugPrint
$LN10@DebugPrint:

; 197  : 
; 198  : 			case '%':
; 199  : 
; 200  : 				switch (str[i+1]) {

	movsx	eax, BYTE PTR [esi+ebp+1]
	add	eax, -88				; ffffffa8H
	cmp	eax, 32					; 00000020H
	ja	$LN2@DebugPrint
	movzx	eax, BYTE PTR $LN81@DebugPrint[eax]
	jmp	DWORD PTR $LN88@DebugPrint[eax*4]
$LN7@DebugPrint:

; 201  : 
; 202  : 					/*** characters ***/
; 203  : 					case 'c': {
; 204  : 						char c = va_arg (args, char);
; 205  : 						DebugPutc (c);

	movzx	ecx, BYTE PTR [ebx+4]
	add	ebx, 4
	push	ecx
	call	?DebugPutc@@YAXE@Z			; DebugPutc

; 206  : 						i++;		// go to next character
; 207  : 						break;

	jmp	$LN86@DebugPrint
$LN6@DebugPrint:

; 208  : 					}
; 209  : 
; 210  : 					/*** address of ***/
; 211  : 					case 'a': {
; 212  : 						int c = (int&) va_arg (args, char);
; 213  : 						char str[32]={0};

	xor	eax, eax
	add	ebx, 4
	mov	DWORD PTR _str$2822[esp+181], eax
	mov	DWORD PTR _str$2822[esp+185], eax
	mov	DWORD PTR _str$2822[esp+189], eax
	mov	DWORD PTR _str$2822[esp+193], eax
	mov	DWORD PTR _str$2822[esp+197], eax
	mov	DWORD PTR _str$2822[esp+201], eax
	mov	DWORD PTR _str$2822[esp+205], eax
	mov	WORD PTR _str$2822[esp+209], ax
	mov	BYTE PTR _str$2822[esp+211], al

; 214  : 						itoa_s (c, 16, str);

	mov	eax, DWORD PTR [ebx]
	mov	BYTE PTR _str$2822[esp+180], 0
	lea	edi, DWORD PTR _str$2822[esp+180]
	test	eax, eax
	jns	SHORT $LN19@DebugPrint
	mov	BYTE PTR _str$2822[esp+180], 45		; 0000002dH
	lea	edi, DWORD PTR _str$2822[esp+181]
	neg	eax
$LN19@DebugPrint:
	xor	ecx, ecx
	test	eax, eax
	je	$LN54@DebugPrint
$LL27@DebugPrint:
	mov	edx, eax
	and	edx, 15					; 0000000fH
	mov	dl, BYTE PTR ?bchars@@3PADA[edx]
	mov	BYTE PTR ?tbuf@@3PADA[ecx], dl
	shr	eax, 4
	inc	ecx
	test	eax, eax
	jne	SHORT $LL27@DebugPrint
	mov	esi, ecx
	test	esi, esi
	jle	SHORT $LN23@DebugPrint
	lea	ecx, DWORD PTR ?tbuf@@3PADA[ecx-1]
	npad	6
$LL25@DebugPrint:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edi], dl
	inc	eax
	dec	ecx
	cmp	eax, esi
	jl	SHORT $LL25@DebugPrint
$LN23@DebugPrint:
	mov	ebp, DWORD PTR _str$[esp+176]
	mov	esi, DWORD PTR _i$2790[esp+180]
	mov	BYTE PTR [eax+edi], 0
	jmp	$LN56@DebugPrint
$LN5@DebugPrint:

; 215  : 						DebugPuts (str);
; 216  : 						i++;		// go to next character
; 217  : 						break;
; 218  : 					}
; 219  : 							   
; 220  : 					/*** string **/
; 221  : 					case 's': {
; 222  : 						int c = (int&) va_arg (args, char);
; 223  : 						char str[128];
; 224  : 						strcpy (str,(const char*)c);

	mov	ecx, DWORD PTR [ebx+4]
	add	ebx, 4
	push	ecx
	lea	edx, DWORD PTR _str$2833[esp+184]
	push	edx
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 225  : 						DebugPuts (str);

	lea	eax, DWORD PTR _str$2833[esp+188]
	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 12					; 0000000cH

; 226  : 						i++;		// go to next character
; 227  : 						break;

	jmp	$LN87@DebugPrint
$LN4@DebugPrint:

; 228  : 
; 229  : 					}
; 230  : 
; 231  : 					/*** integers ***/
; 232  : 					case 'd':
; 233  : 					case 'i': {
; 234  : 						int c = va_arg (args, int);
; 235  : 						char str[32]={0};
; 236  : 						itoa_s (c, 10, str);

	mov	ecx, DWORD PTR [ebx+4]
	xor	eax, eax
	add	ebx, 4
	mov	BYTE PTR _str$2844[esp+180], 0
	mov	DWORD PTR _str$2844[esp+181], eax
	mov	DWORD PTR _str$2844[esp+185], eax
	mov	DWORD PTR _str$2844[esp+189], eax
	mov	DWORD PTR _str$2844[esp+193], eax
	mov	DWORD PTR _str$2844[esp+197], eax
	mov	DWORD PTR _str$2844[esp+201], eax
	mov	DWORD PTR _str$2844[esp+205], eax
	mov	WORD PTR _str$2844[esp+209], ax
	mov	BYTE PTR _str$2844[esp+211], al
	lea	ebp, DWORD PTR _str$2844[esp+180]
	test	ecx, ecx
	jns	SHORT $LN32@DebugPrint
	mov	BYTE PTR _str$2844[esp+180], 45		; 0000002dH
	lea	ebp, DWORD PTR _str$2844[esp+181]
	neg	ecx
$LN32@DebugPrint:
	xor	esi, esi
	test	ecx, ecx
	je	SHORT $LN41@DebugPrint
	npad	3
$LL40@DebugPrint:
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax
	sub	ecx, eax
	mov	cl, BYTE PTR ?bchars@@3PADA[ecx]
	mov	BYTE PTR ?tbuf@@3PADA[esi], cl
	mov	ecx, edx
	inc	esi
	test	ecx, ecx
	jne	SHORT $LL40@DebugPrint
	mov	edi, esi
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN36@DebugPrint
	lea	ecx, DWORD PTR ?tbuf@@3PADA[esi-1]
$LL38@DebugPrint:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+ebp], dl
	inc	eax
	dec	ecx
	cmp	eax, edi
	jl	SHORT $LL38@DebugPrint
$LN36@DebugPrint:
	mov	BYTE PTR [eax+ebp], 0
	jmp	SHORT $LN43@DebugPrint
$LN41@DebugPrint:
	mov	WORD PTR [ebp], 48			; 00000030H
$LN43@DebugPrint:

; 237  : 						DebugPuts (str);

	lea	eax, DWORD PTR _str$2844[esp+180]
	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 238  : 						i++;		// go to next character
; 239  : 						break;

	mov	ebp, DWORD PTR _str$[esp+180]
	add	esp, 4
	inc	DWORD PTR _i$2790[esp+180]
	mov	esi, DWORD PTR _i$2790[esp+180]
	jmp	$LN14@DebugPrint
$LN3@DebugPrint:

; 240  : 					}
; 241  : 
; 242  : 					/*** display in hex ***/
; 243  : 					case 'X':
; 244  : 					case 'x': {
; 245  : 						int c = va_arg (args, int);
; 246  : 						char str[32]={0};

	xor	eax, eax
	add	ebx, 4
	mov	DWORD PTR _str$2854[esp+181], eax
	mov	DWORD PTR _str$2854[esp+185], eax
	mov	DWORD PTR _str$2854[esp+189], eax
	mov	DWORD PTR _str$2854[esp+193], eax
	mov	DWORD PTR _str$2854[esp+197], eax
	mov	DWORD PTR _str$2854[esp+201], eax
	mov	DWORD PTR _str$2854[esp+205], eax
	mov	WORD PTR _str$2854[esp+209], ax
	mov	BYTE PTR _str$2854[esp+211], al

; 247  : 						itoa_s (c,16,str);

	mov	eax, DWORD PTR [ebx]
	mov	BYTE PTR _str$2854[esp+180], 0
	lea	edi, DWORD PTR _str$2854[esp+180]
	test	eax, eax
	jns	SHORT $LN45@DebugPrint
	mov	BYTE PTR _str$2854[esp+180], 45		; 0000002dH
	lea	edi, DWORD PTR _str$2854[esp+181]
	neg	eax
$LN45@DebugPrint:
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN54@DebugPrint
$LL53@DebugPrint:
	mov	edx, eax
	and	edx, 15					; 0000000fH
	mov	dl, BYTE PTR ?bchars@@3PADA[edx]
	mov	BYTE PTR ?tbuf@@3PADA[ecx], dl
	shr	eax, 4
	inc	ecx
	test	eax, eax
	jne	SHORT $LL53@DebugPrint
	mov	esi, ecx
	test	esi, esi
	jle	SHORT $LN49@DebugPrint
	lea	ecx, DWORD PTR ?tbuf@@3PADA[ecx-1]
	npad	7
$LL51@DebugPrint:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edi], dl
	inc	eax
	dec	ecx
	cmp	eax, esi
	jl	SHORT $LL51@DebugPrint
$LN49@DebugPrint:
	mov	ebp, DWORD PTR _str$[esp+176]
	mov	esi, DWORD PTR _i$2790[esp+180]
	mov	BYTE PTR [eax+edi], 0
	jmp	SHORT $LN56@DebugPrint
$LN54@DebugPrint:
	mov	WORD PTR [edi], 48			; 00000030H
$LN56@DebugPrint:

; 248  : 						DebugPuts (str);

	lea	eax, DWORD PTR _str$2854[esp+180]
	push	eax
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
$LN86@DebugPrint:
	add	esp, 4
$LN87@DebugPrint:

; 249  : 						i++;		// go to next character

	inc	esi
$LN14@DebugPrint:

; 193  : 
; 194  : 	for (size_t i=0; i<strlen(str);i++) {

	inc	esi
	push	ebp
	mov	DWORD PTR _i$2790[esp+184], esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	esi, eax
	jb	$LL82@DebugPrint
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 263  : 		}
; 264  : 
; 265  : 	}
; 266  : 
; 267  : 	va_end (args);
; 268  : }

	add	esp, 164				; 000000a4H
	ret	0
$LN2@DebugPrint:
	pop	edi

; 250  : 						break;
; 251  : 					}
; 252  : 
; 253  : 					default:
; 254  : 						va_end (args);
; 255  : 						return 1;

	mov	eax, 1
	pop	ebx
$LN83@DebugPrint:
	pop	esi
	pop	ebp

; 263  : 		}
; 264  : 
; 265  : 	}
; 266  : 
; 267  : 	va_end (args);
; 268  : }

	add	esp, 164				; 000000a4H
	ret	0
$LN88@DebugPrint:
	DD	$LN3@DebugPrint
	DD	$LN6@DebugPrint
	DD	$LN7@DebugPrint
	DD	$LN4@DebugPrint
	DD	$LN5@DebugPrint
	DD	$LN2@DebugPrint
$LN81@DebugPrint:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	5
	DB	2
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	0
?DebugPrintf@@YAHPBDZZ ENDP				; DebugPrintf
_TEXT	ENDS
END
