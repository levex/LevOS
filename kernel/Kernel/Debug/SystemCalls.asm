; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\SystemCalls.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?regs@@3Uregs_t@@A				; regs
PUBLIC	?string@@3PADA					; string
PUBLIC	?c@@3DA						; c
PUBLIC	?id@@3HA					; id
PUBLIC	?a@@3HA						; a
PUBLIC	?b@@3HA						; b
PUBLIC	?d@@3HA						; d
PUBLIC	?e@@3HA						; e
PUBLIC	?_ebx@@3HA					; _ebx
PUBLIC	?vgacol@@3DA					; vgacol
PUBLIC	?_b@@3_NA					; _b
PUBLIC	?data@@3PAU___RTC__STRUCT@@A			; data
_BSS	SEGMENT
?regs@@3Uregs_t@@A DW 01H DUP (?)			; regs
	ALIGN	4

?string@@3PADA DD 01H DUP (?)				; string
?c@@3DA	DB	01H DUP (?)				; c
	ALIGN	4

?id@@3HA DD	01H DUP (?)				; id
?a@@3HA	DD	01H DUP (?)				; a
?b@@3HA	DD	01H DUP (?)				; b
?d@@3HA	DD	01H DUP (?)				; d
?e@@3HA	DD	01H DUP (?)				; e
?_ebx@@3HA DD	01H DUP (?)				; _ebx
?vgacol@@3DA DB	01H DUP (?)				; vgacol
	ALIGN	4

?_b@@3_NA DB	01H DUP (?)				; _b
	ALIGN	4

?data@@3PAU___RTC__STRUCT@@A DD 01H DUP (?)		; data
_BSS	ENDS
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	?handleSysCall@@YAXXZ				; handleSysCall
EXTRN	?fillMouseState@@YAXPAUMOUSE_STATE@@@Z:PROC	; fillMouseState
EXTRN	?VGA_put_rectangle@@YAXHHHHD@Z:PROC		; VGA_put_rectangle
EXTRN	?VGA_put_line@@YAXHHHHD@Z:PROC			; VGA_put_line
EXTRN	?VGA_put_char@@YAXHHD@Z:PROC			; VGA_put_char
EXTRN	?VGA_put_string@@YAXHHPAD@Z:PROC		; VGA_put_string
EXTRN	?VGA_deinit@@YAXXZ:PROC				; VGA_deinit
EXTRN	?VGA_put_image@@YAXHHPAD@Z:PROC			; VGA_put_image
EXTRN	?VGA_clear_screen@@YAXXZ:PROC			; VGA_clear_screen
EXTRN	?VGA_put_pixel@@YAXHHD@Z:PROC			; VGA_put_pixel
EXTRN	?VGA_init@@YAXHHH@Z:PROC			; VGA_init
EXTRN	?fsysFatGetFilesInRoot@@YAXPAD@Z:PROC		; fsysFatGetFilesInRoot
EXTRN	?fsysFatGetNumberOfFilesInRoot@@YADXZ:PROC	; fsysFatGetNumberOfFilesInRoot
EXTRN	?rtc_getYear@@YAHXZ:PROC			; rtc_getYear
EXTRN	?rtc_getWeekday@@YAHXZ:PROC			; rtc_getWeekday
EXTRN	?rtc_getSecond@@YAHXZ:PROC			; rtc_getSecond
EXTRN	?rtc_getMonth@@YAHXZ:PROC			; rtc_getMonth
EXTRN	?rtc_getMinute@@YAHXZ:PROC			; rtc_getMinute
EXTRN	?rtc_getHour@@YAHXZ:PROC			; rtc_getHour
EXTRN	?rtc_getDayOfMonth@@YAHXZ:PROC			; rtc_getDayOfMonth
EXTRN	?PE_mapApp@@YA_NPADH@Z:PROC			; PE_mapApp
EXTRN	?PE_dumpApp@@YA_NPADH@Z:PROC			; PE_dumpApp
EXTRN	?DebugGotoRXY@@YAXII@Z:PROC			; DebugGotoRXY
EXTRN	?DebugClrScr@@YAXG@Z:PROC			; DebugClrScr
EXTRN	?loadFileToLoc@@YA_NPADPAX@Z:PROC		; loadFileToLoc
EXTRN	?kkybrd_key_to_ascii@@YADW4KEYCODE@@@Z:PROC	; kkybrd_key_to_ascii
EXTRN	?kkybrd_discard_last_key@@YAXXZ:PROC		; kkybrd_discard_last_key
EXTRN	?kkybrd_get_last_key@@YA?AW4KEYCODE@@XZ:PROC	; kkybrd_get_last_key
EXTRN	?DebugPutc@@YAXE@Z:PROC				; DebugPutc
EXTRN	?DebugPrintf@@YAHPBDZZ:PROC			; DebugPrintf
EXTRN	?doRealModeInterrupt@@YAXDDD@Z:PROC		; doRealModeInterrupt
EXTRN	?PCI_test@@YAXXZ:PROC				; PCI_test
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
; File c:\dev\levos\kernel\kernel\systemcalls.cpp
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi?$AA@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi?$AA@ DB '%i', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?handleSysCall@@YAXXZ
_TEXT	SEGMENT
_dey$3322 = -18						; size = 1
_dex$3321 = -17						; size = 1
_filename$3312 = -16					; size = 4
_i$3334 = -12						; size = 4
__i$3337 = -8						; size = 4
_address$3313 = -4					; size = 4
?handleSysCall@@YAXXZ PROC				; handleSysCall, COMDAT

; 24   : {

	sub	esp, 20					; 00000014H

; 25   : 	_asm sti

	sti

; 26   : 	_asm {
; 27   : 		mov id, eax

	mov	DWORD PTR ?id@@3HA, eax			; id

; 28   : 	}
; 29   : 	KEYCODE key = KEY_UNKNOWN;
; 30   : 	switch(id)

	mov	eax, DWORD PTR ?id@@3HA			; id
	dec	eax
	cmp	eax, 12					; 0000000cH
	ja	$LN50@handleSysC
	push	esi
	jmp	DWORD PTR $LN61@handleSysC[eax*4]
$LN49@handleSysC:

; 31   : 	{
; 32   : 		case 0x01: // test
; 33   : 			_asm mov _ebx, ebx

	mov	DWORD PTR ?_ebx@@3HA, ebx		; _ebx

; 34   : 			switch(_ebx)

	mov	eax, DWORD PTR ?_ebx@@3HA		; _ebx
	sub	eax, 0
	je	SHORT $LL45@handleSysC
	dec	eax
	je	SHORT $LN43@handleSysC
	dec	eax
	jne	$LN57@handleSysC
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H

; 43   : 					break;
; 44   : 				case 2:
; 45   : 					PCI_test();

	jmp	?PCI_test@@YAXXZ			; PCI_test
$LN43@handleSysC:

; 38   : 					break;
; 39   : 				case 1:
; 40   : 					regs.ah = 0x00;
; 41   : 					regs.al = 0x00;
; 42   : 					doRealModeInterrupt(0x16, 0,0);

	push	0
	push	0
	push	22					; 00000016H
	mov	WORD PTR ?regs@@3Uregs_t@@A, 0		; regs
	call	?doRealModeInterrupt@@YAXDDD@Z		; doRealModeInterrupt
	add	esp, 12					; 0000000cH
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
	npad	1
$LL45@handleSysC:

; 35   : 			{
; 36   : 				case 0:
; 37   : 					for(;;);

	jmp	SHORT $LL45@handleSysC
$LN41@handleSysC:

; 46   : 					break;
; 47   : 			}
; 48   : 			break;
; 49   : 		case 0x02: // PrintString
; 50   : 			/*
; 51   : 				Prints a string
; 52   : 				EDX = address of string (char*)
; 53   : 			*/
; 54   : 			string = (char*)0;

	mov	DWORD PTR ?string@@3PADA, 0		; string

; 55   : 			_asm
; 56   : 			{
; 57   : 				mov string, edx;

	mov	DWORD PTR ?string@@3PADA, edx		; string

; 58   : 			}
; 59   : 			DebugPrintf("%s", string, string);

	mov	eax, DWORD PTR ?string@@3PADA		; string
	push	eax
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 12					; 0000000cH
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN40@handleSysC:

; 60   : 			break;
; 61   : 		case 0x03: // PrintChar
; 62   : 			/*
; 63   : 				Prints a character
; 64   : 				BL = character to print
; 65   : 			*/
; 66   : 			_asm
; 67   : 			{
; 68   : 				mov c, bl

	mov	BYTE PTR ?c@@3DA, bl			; c

; 69   : 			}
; 70   : 			DebugPutc(c);

	movzx	eax, BYTE PTR ?c@@3DA			; c
	push	eax
	call	?DebugPutc@@YAXE@Z			; DebugPutc

; 356  : 			//MOUSE_STATE* m = (MOUSE_STATE*)a;
; 357  : 			fillMouseState((MOUSE_STATE*)a);

	add	esp, 4
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN39@handleSysC:

; 71   : 			break;
; 72   : 		case 0x04: // Wait for keypress
; 73   : 			/*
; 74   : 				Waits for a keypress and returns it in DH
; 75   : 				RET -> DH (character retrieved)
; 76   : 			*/
; 77   : 			_asm xor dh, dh

	xor	dh, dh

; 78   : 			c = 0;

	mov	BYTE PTR ?c@@3DA, 0			; c

; 79   : 			key = KEY_UNKNOWN;
; 80   : 			/*while(key == KEY_UNKNOWN)*/ key = kkybrd_get_last_key();

	call	?kkybrd_get_last_key@@YA?AW4KEYCODE@@XZ	; kkybrd_get_last_key
	mov	esi, eax

; 81   : 			kkybrd_discard_last_key();

	call	?kkybrd_discard_last_key@@YAXXZ		; kkybrd_discard_last_key

; 82   : 			c = kkybrd_key_to_ascii(key);

	push	esi
	call	?kkybrd_key_to_ascii@@YADW4KEYCODE@@@Z	; kkybrd_key_to_ascii
	add	esp, 4
	mov	BYTE PTR ?c@@3DA, al			; c

; 83   : 			//if(key == KEY_UNKNOWN) c=0;
; 84   : 			if(c==0x2) c = 0;

	cmp	al, 2
	jne	SHORT $LN38@handleSysC
	mov	BYTE PTR ?c@@3DA, 0			; c
$LN38@handleSysC:

; 85   : 			_asm mov dh, c

	mov	dh, BYTE PTR ?c@@3DA			; c
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN37@handleSysC:

; 86   : 			break;
; 87   : 		case 0x05: // load file to specified address
; 88   : 			/*
; 89   : 				Load file to specified address
; 90   : 				EBX = address
; 91   : 				EDX = filename (char*)
; 92   : 
; 93   : 				RET -> EDX (1=success,0=failure)
; 94   : 			*/
; 95   : 			char* filename;
; 96   : 			char* address;
; 97   : 			_asm {
; 98   : 				mov filename, edx

	mov	DWORD PTR _filename$3312[esp+24], edx

; 99   : 				mov address, ebx

	mov	DWORD PTR _address$3313[esp+24], ebx

; 100  : 			}
; 101  : 			if(!loadFileToLoc(filename, address)) {_asm {xor edx, edx}break;}

	mov	ecx, DWORD PTR _address$3313[esp+24]
	mov	edx, DWORD PTR _filename$3312[esp+24]
	push	ecx
	push	edx
	call	?loadFileToLoc@@YA_NPADPAX@Z		; loadFileToLoc
	add	esp, 8
	test	al, al
	jne	SHORT $LN36@handleSysC
	xor	edx, edx
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN36@handleSysC:

; 102  : 			_asm {
; 103  : 				mov edx, 0x01

	mov	edx, 1
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN35@handleSysC:

; 104  : 			}
; 105  : 			break;
; 106  : 		case 0x06: // display utilites
; 107  : 			/*
; 108  : 				Display utilities
; 109  : 				EBX = Function
; 110  : 					EBX == 0x01
; 111  : 						Move cursor
; 112  : 						DL = Y coordinate change
; 113  : 						DH = X coordinate change
; 114  : 					EBX == 0x02
; 115  : 						Clear screen
; 116  : 			*/
; 117  : 			_ebx = 0;

	mov	DWORD PTR ?_ebx@@3HA, 0			; _ebx

; 118  : 			_asm mov _ebx, ebx

	mov	DWORD PTR ?_ebx@@3HA, ebx		; _ebx

; 119  : 			switch(_ebx)

	mov	eax, DWORD PTR ?_ebx@@3HA		; _ebx
	dec	eax
	je	SHORT $LN32@handleSysC
	dec	eax
	jne	$LN57@handleSysC

; 130  : 					break;
; 131  : 				case 0x02:
; 132  : 					DebugClrScr(0x17);

	push	23					; 00000017H
	call	?DebugClrScr@@YAXG@Z			; DebugClrScr

; 356  : 			//MOUSE_STATE* m = (MOUSE_STATE*)a;
; 357  : 			fillMouseState((MOUSE_STATE*)a);

	add	esp, 4
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN32@handleSysC:

; 120  : 			{
; 121  : 				case 0x01:
; 122  : 					signed char dex;
; 123  : 					signed char dey;
; 124  : 					_asm
; 125  : 					{
; 126  : 						mov dex, dh

	mov	BYTE PTR _dex$3321[esp+24], dh

; 127  : 						mov dey, dl

	mov	BYTE PTR _dey$3322[esp+24], dl

; 128  : 					}
; 129  : 					DebugGotoRXY(dex, dey);

	movsx	eax, BYTE PTR _dey$3322[esp+24]
	movsx	ecx, BYTE PTR _dex$3321[esp+24]
	push	eax
	push	ecx
	call	?DebugGotoRXY@@YAXII@Z			; DebugGotoRXY
	add	esp, 8
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN30@handleSysC:

; 133  : 					break;
; 134  : 			}
; 135  : 			break;
; 136  : 		case 0x07: //execute application
; 137  : 			/*
; 138  : 				EBX == 0x01
; 139  : 					Executes the PE executable at the given address
; 140  : 					EDX = address of filename
; 141  : 						Returns:
; 142  : 							EDX
; 143  : 								1 = SUCCESS
; 144  : 								0 = FILE NOT FOUND
; 145  : 								2 = OTHER FAILURE
; 146  : 				EBX == 0x02
; 147  : 					Dumps the PE executable at the given address
; 148  : 					EDX = adress of filename
; 149  : 						Returns:
; 150  : 							EDX
; 151  : 								1 = SUCCESS
; 152  : 								0 = FILE NOT FOUND
; 153  : 								2 = OTHER FAILURE
; 154  : 			*/
; 155  : 			_asm mov _ebx, ebx

	mov	DWORD PTR ?_ebx@@3HA, ebx		; _ebx

; 156  : 			switch(_ebx)

	mov	eax, DWORD PTR ?_ebx@@3HA		; _ebx
	dec	eax
	je	SHORT $LN27@handleSysC
	dec	eax
	jne	$LN57@handleSysC

; 163  : 					break;
; 164  : 				case 0x02:
; 165  : 					_asm mov filename, edx

	mov	DWORD PTR _filename$3312[esp+24], edx

; 166  : 					_b = PE_dumpApp(filename,0x1000000);

	mov	edx, DWORD PTR _filename$3312[esp+24]
	push	16777216				; 01000000H
	push	edx
	call	?PE_dumpApp@@YA_NPADH@Z			; PE_dumpApp
	add	esp, 8
	mov	BYTE PTR ?_b@@3_NA, al			; _b

; 167  : 					if(_b){ _asm { mov edx, 1} break;}

	test	al, al
	je	SHORT $LN24@handleSysC
	mov	edx, 1
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN24@handleSysC:

; 168  : 					_asm xor edx, edx

	xor	edx, edx
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN27@handleSysC:

; 157  : 			{
; 158  : 				case 0x01:
; 159  : 					_asm mov filename, edx

	mov	DWORD PTR _filename$3312[esp+24], edx

; 160  : 					_b = PE_mapApp(filename, 0x1000000);

	mov	eax, DWORD PTR _filename$3312[esp+24]
	push	16777216				; 01000000H
	push	eax
	call	?PE_mapApp@@YA_NPADH@Z			; PE_mapApp
	add	esp, 8
	mov	BYTE PTR ?_b@@3_NA, al			; _b

; 161  : 					if(_b){ _asm { mov edx, 1} break;}

	test	al, al
	je	SHORT $LN26@handleSysC
	mov	edx, 1
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@handleSysC:

; 162  : 					_asm xor edx, edx

	xor	edx, edx
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN23@handleSysC:

; 169  : 					break;
; 170  : 			}
; 171  : 			break;
; 172  : 		case 0x08: // printNumber
; 173  : 			/*
; 174  : 				Prints a number
; 175  : 				EDX = number to print
; 176  : 			*/
; 177  : 			int i;
; 178  : 			_asm mov i, edx

	mov	DWORD PTR _i$3334[esp+24], edx

; 179  : 			DebugPrintf("%i", i);

	mov	ecx, DWORD PTR _i$3334[esp+24]
	push	ecx
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 8
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN22@handleSysC:

; 180  : 			break;
; 181  : 		case 0x09: // get RTC struct
; 182  : 			/*
; 183  : 				Queries an RTC struct at a give address
; 184  : 				EDX = address to write RTC_STRUCT to. (Refer to RTC.h)
; 185  : 			*/
; 186  : 			int _i;
; 187  : 			_asm mov _i, edx

	mov	DWORD PTR __i$3337[esp+24], edx

; 188  : 			data = (RTC_DATA*) _i;

	mov	edx, DWORD PTR __i$3337[esp+24]
	mov	DWORD PTR ?data@@3PAU___RTC__STRUCT@@A, edx ; data

; 189  : 			//DebugPrintf("---->0x%X<----", data);
; 190  : 			data->DayOfMonth = rtc_getDayOfMonth();

	call	?rtc_getDayOfMonth@@YAHXZ		; rtc_getDayOfMonth
	mov	ecx, DWORD PTR ?data@@3PAU___RTC__STRUCT@@A ; data
	mov	DWORD PTR [ecx+8], eax

; 191  : 			data->Hour = rtc_getHour();

	call	?rtc_getHour@@YAHXZ			; rtc_getHour
	mov	edx, DWORD PTR ?data@@3PAU___RTC__STRUCT@@A ; data
	mov	DWORD PTR [edx+16], eax

; 192  : 			data->Minute = rtc_getMinute();

	call	?rtc_getMinute@@YAHXZ			; rtc_getMinute
	mov	ecx, DWORD PTR ?data@@3PAU___RTC__STRUCT@@A ; data
	mov	DWORD PTR [ecx+20], eax

; 193  : 			data->Month = rtc_getMonth();

	call	?rtc_getMonth@@YAHXZ			; rtc_getMonth
	mov	edx, DWORD PTR ?data@@3PAU___RTC__STRUCT@@A ; data
	mov	DWORD PTR [edx+4], eax

; 194  : 			data->Second = rtc_getSecond();

	call	?rtc_getSecond@@YAHXZ			; rtc_getSecond
	mov	ecx, DWORD PTR ?data@@3PAU___RTC__STRUCT@@A ; data
	mov	DWORD PTR [ecx+24], eax

; 195  : 			data->WeekDay = rtc_getWeekday();

	call	?rtc_getWeekday@@YAHXZ			; rtc_getWeekday
	mov	edx, DWORD PTR ?data@@3PAU___RTC__STRUCT@@A ; data
	mov	DWORD PTR [edx+12], eax

; 196  : 			data->Year = rtc_getYear();

	call	?rtc_getYear@@YAHXZ			; rtc_getYear
	mov	ecx, DWORD PTR ?data@@3PAU___RTC__STRUCT@@A ; data
	mov	DWORD PTR [ecx], eax
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN21@handleSysC:

; 197  : 			break;
; 198  : 		case 0x0A: // print hexadecimal
; 199  : 			/*
; 200  : 				Prints a number in base 16
; 201  : 				EDX = number to print
; 202  : 			*/
; 203  : 			_asm mov _ebx, edx

	mov	DWORD PTR ?_ebx@@3HA, edx		; _ebx

; 204  : 			DebugPrintf("%x", _ebx);

	mov	edx, DWORD PTR ?_ebx@@3HA		; _ebx
	push	edx
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 8
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN20@handleSysC:

; 205  : 			break;
; 206  : 		case 0x0B: // fsys utils
; 207  : 			/*
; 208  : 				Provides an interface to the FAT12 filesystem!
; 209  : 				EBX = function
; 210  : 					EBX = 0x01
; 211  : 						Returns filenames in ROOT directory
; 212  : 						EDX = pointer to filenames (terminates with \0)
; 213  : 					EBX = 0x02
; 214  : 						Returns the number of files in ROOT directory
; 215  : 						EDX = number of files
; 216  : 			*/
; 217  : 			_asm mov _ebx, ebx

	mov	DWORD PTR ?_ebx@@3HA, ebx		; _ebx

; 218  : 			switch(_ebx)

	mov	eax, DWORD PTR ?_ebx@@3HA		; _ebx
	dec	eax
	je	SHORT $LN17@handleSysC
	dec	eax
	jne	SHORT $LN18@handleSysC

; 223  : 					return;
; 224  : 				case 0x02: // get # of files
; 225  : 					id = fsysFatGetNumberOfFilesInRoot();

	call	?fsysFatGetNumberOfFilesInRoot@@YADXZ	; fsysFatGetNumberOfFilesInRoot
	movsx	eax, al
	mov	DWORD PTR ?id@@3HA, eax			; id

; 226  : 					_asm mov edx, id

	mov	edx, DWORD PTR ?id@@3HA			; id
$LN18@handleSysC:

; 227  : 			}
; 228  : 		case 0x0C: //vga utils
; 229  : 			/*
; 230  : 				VGA utilities
; 231  : 				EBX = function
; 232  : 					EBX = 0x01
; 233  : 						Switches on VGA(320x200x1Byte)
; 234  : 					EBX = 0x02
; 235  : 						ECX = X coordinate
; 236  : 						ESI = Y coordinate
; 237  : 						DL = color
; 238  : 							Puts a pixel at (ECX, ESI) = DL
; 239  : 					EBX = 0x03
; 240  : 						Clears the screen
; 241  : 					EBX = 0x04
; 242  : 						EDX = pointer to filename
; 243  : 						ESI = X coordinate
; 244  : 						EDI = Y coordinate
; 245  : 						Loads a .BMP file and displays at given coordinates ( ESI, EDI )
; 246  : 					EBX = 0x05
; 247  : 						Deinitializes VGA and returns to text mode
; 248  : 					EBX = 0x06
; 249  : 						ESI = char* to string
; 250  : 						ECX = X coordinate
; 251  : 						EDX = Y coordinate
; 252  : 						Prints a string at (ECX, EDX)
; 253  : 					EBX = 0x07
; 254  : 						ESI = X coordinate
; 255  : 						EDI = Y coordinate
; 256  : 						CL = character
; 257  : 						Print a character at (ESI, EDI)=CL
; 258  : 					EBX = 0x08
; 259  : 						ESI = X0 coordinate
; 260  : 						EDI = Y0 coordinate
; 261  : 						ECX = X1 coordinate
; 262  : 						EDX = Y1 coordinate
; 263  : 						Draws a line from (ESI, EDI) to (ECX, EDX)
; 264  : 					EBX = 0x09
; 265  : 						ESI = X0 coordinate
; 266  : 						EDI = Y0 coordinate
; 267  : 						ECX = X1 coordinate
; 268  : 						EDX = Y1 coordinate
; 269  : 						Draws a rectangle from (ESI, EDI) to (ECX, EDX)
; 270  : 					EBX = 0x0A
; 271  : 						CL = color
; 272  : 						Sets the draw color to CL
; 273  : 					EBX = 0x0B
; 274  : 						Returns the color in CL
; 275  : 						
; 276  : 			*/
; 277  : 			_asm mov _ebx, ebx

	mov	DWORD PTR ?_ebx@@3HA, ebx		; _ebx

; 278  : 			switch(_ebx)

	mov	eax, DWORD PTR ?_ebx@@3HA		; _ebx
	dec	eax
	cmp	eax, 10					; 0000000aH
	ja	$LN13@handleSysC
	jmp	DWORD PTR $LN62@handleSysC[eax*4]
$LN17@handleSysC:

; 219  : 			{
; 220  : 				case 0x01: // get filenames
; 221  : 					fsysFatGetFilesInRoot(string);

	mov	ecx, DWORD PTR ?string@@3PADA		; string
	push	ecx
	call	?fsysFatGetFilesInRoot@@YAXPAD@Z	; fsysFatGetFilesInRoot
	add	esp, 4

; 222  : 					_asm mov edx, string

	mov	edx, DWORD PTR ?string@@3PADA		; string
	pop	esi

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN12@handleSysC:

; 279  : 			{	
; 280  : 				case 0x01: // switch on VGA
; 281  : 					VGA_init(320, 200, 256);

	push	256					; 00000100H
	push	200					; 000000c8H
	push	320					; 00000140H
	call	?VGA_init@@YAXHHH@Z			; VGA_init
	add	esp, 12					; 0000000cH

; 282  : 					break;

	jmp	$LN13@handleSysC
$LN11@handleSysC:

; 283  : 				case 0x02: // put pixel (cx,dx)
; 284  : 					_asm {
; 285  : 						mov a, ecx

	mov	DWORD PTR ?a@@3HA, ecx			; a

; 286  : 						mov b, esi

	mov	DWORD PTR ?b@@3HA, esi			; b

; 287  : 						mov c, dl

	mov	BYTE PTR ?c@@3DA, dl			; c

; 288  : 					}
; 289  : 					VGA_put_pixel(a, b, c);

	movzx	edx, BYTE PTR ?c@@3DA			; c
	mov	eax, DWORD PTR ?b@@3HA			; b
	mov	ecx, DWORD PTR ?a@@3HA			; a
	push	edx
	push	eax
	push	ecx
	call	?VGA_put_pixel@@YAXHHD@Z		; VGA_put_pixel
	add	esp, 12					; 0000000cH

; 290  : 					break;

	jmp	$LN13@handleSysC
$LN10@handleSysC:

; 291  : 				case 0x03: // clear screen
; 292  : 					VGA_clear_screen();

	call	?VGA_clear_screen@@YAXXZ		; VGA_clear_screen

; 293  : 					break;

	jmp	$LN13@handleSysC
$LN9@handleSysC:

; 294  : 				case 0x04: // load bmp file
; 295  : 					_asm {
; 296  : 						mov filename, edx

	mov	DWORD PTR _filename$3312[esp+24], edx

; 297  : 						mov a, esi

	mov	DWORD PTR ?a@@3HA, esi			; a

; 298  : 						mov b, edi

	mov	DWORD PTR ?b@@3HA, edi			; b

; 299  : 					}
; 300  : 					VGA_put_image(a, b, filename);

	mov	edx, DWORD PTR _filename$3312[esp+24]
	mov	eax, DWORD PTR ?b@@3HA			; b
	mov	ecx, DWORD PTR ?a@@3HA			; a
	push	edx
	push	eax
	push	ecx
	call	?VGA_put_image@@YAXHHPAD@Z		; VGA_put_image
	add	esp, 12					; 0000000cH

; 301  : 					break;

	jmp	$LN13@handleSysC
$LN8@handleSysC:

; 302  : 				case 0x05: //vga deinit
; 303  : 					VGA_deinit();

	call	?VGA_deinit@@YAXXZ			; VGA_deinit

; 304  : 					break;

	jmp	$LN13@handleSysC
$LN7@handleSysC:

; 305  : 				case 0x06: // vga putStr
; 306  : 					_asm {
; 307  : 						mov filename, esi

	mov	DWORD PTR _filename$3312[esp+24], esi

; 308  : 						mov a, ecx

	mov	DWORD PTR ?a@@3HA, ecx			; a

; 309  : 						mov b, edx

	mov	DWORD PTR ?b@@3HA, edx			; b

; 310  : 					}
; 311  : 					VGA_put_string(a,b,filename);

	mov	edx, DWORD PTR _filename$3312[esp+24]
	mov	eax, DWORD PTR ?b@@3HA			; b
	mov	ecx, DWORD PTR ?a@@3HA			; a
	push	edx
	push	eax
	push	ecx
	call	?VGA_put_string@@YAXHHPAD@Z		; VGA_put_string
	add	esp, 12					; 0000000cH

; 312  : 					break;

	jmp	$LN13@handleSysC
$LN6@handleSysC:

; 313  : 				case 0x07: // vga putchar
; 314  : 					_asm {
; 315  : 						mov a, esi

	mov	DWORD PTR ?a@@3HA, esi			; a

; 316  : 						mov b, edi

	mov	DWORD PTR ?b@@3HA, edi			; b

; 317  : 						mov c, cl

	mov	BYTE PTR ?c@@3DA, cl			; c

; 318  : 					}
; 319  : 					VGA_put_char(a, b, c);

	movzx	edx, BYTE PTR ?c@@3DA			; c
	mov	eax, DWORD PTR ?b@@3HA			; b
	mov	ecx, DWORD PTR ?a@@3HA			; a
	push	edx
	push	eax
	push	ecx
	call	?VGA_put_char@@YAXHHD@Z			; VGA_put_char
	add	esp, 12					; 0000000cH

; 320  : 					break;

	jmp	$LN13@handleSysC
$LN5@handleSysC:

; 321  : 				case 0x08: //vga putline
; 322  : 					_asm {
; 323  : 						mov a, esi

	mov	DWORD PTR ?a@@3HA, esi			; a

; 324  : 						mov b, edi

	mov	DWORD PTR ?b@@3HA, edi			; b

; 325  : 						mov d, ecx

	mov	DWORD PTR ?d@@3HA, ecx			; d

; 326  : 						mov e, edx

	mov	DWORD PTR ?e@@3HA, edx			; e

; 327  : 					}
; 328  : 					VGA_put_line(a, b, d, e, vgacol);

	movzx	edx, BYTE PTR ?vgacol@@3DA		; vgacol
	mov	eax, DWORD PTR ?e@@3HA			; e
	mov	ecx, DWORD PTR ?d@@3HA			; d
	push	edx
	mov	edx, DWORD PTR ?b@@3HA			; b
	push	eax
	mov	eax, DWORD PTR ?a@@3HA			; a
	push	ecx
	push	edx
	push	eax
	call	?VGA_put_line@@YAXHHHHD@Z		; VGA_put_line
	add	esp, 20					; 00000014H

; 329  : 					break;

	jmp	SHORT $LN13@handleSysC
$LN4@handleSysC:

; 330  : 				case 0x09: //vga putrect
; 331  : 					_asm {
; 332  : 						mov a, esi

	mov	DWORD PTR ?a@@3HA, esi			; a

; 333  : 						mov b, edi

	mov	DWORD PTR ?b@@3HA, edi			; b

; 334  : 						mov d, ecx

	mov	DWORD PTR ?d@@3HA, ecx			; d

; 335  : 						mov e, edx

	mov	DWORD PTR ?e@@3HA, edx			; e

; 336  : 					}
; 337  : 					VGA_put_rectangle(a, b, d, e, vgacol);

	movzx	ecx, BYTE PTR ?vgacol@@3DA		; vgacol
	mov	edx, DWORD PTR ?e@@3HA			; e
	mov	eax, DWORD PTR ?d@@3HA			; d
	push	ecx
	mov	ecx, DWORD PTR ?b@@3HA			; b
	push	edx
	mov	edx, DWORD PTR ?a@@3HA			; a
	push	eax
	push	ecx
	push	edx
	call	?VGA_put_rectangle@@YAXHHHHD@Z		; VGA_put_rectangle
	add	esp, 20					; 00000014H

; 338  : 					break;

	jmp	SHORT $LN13@handleSysC
$LN3@handleSysC:

; 339  : 				case 0x0A: // vga setcolor
; 340  : 					_asm {
; 341  : 						mov vgacol, cl

	mov	BYTE PTR ?vgacol@@3DA, cl		; vgacol

; 342  : 					}
; 343  : 					break;

	jmp	SHORT $LN13@handleSysC
$LN2@handleSysC:

; 344  : 				case 0x0B:
; 345  : 					_asm {
; 346  : 						mov cl, vgacol

	mov	cl, BYTE PTR ?vgacol@@3DA		; vgacol
$LN13@handleSysC:

; 347  : 					}
; 348  : 					break;
; 349  : 			}
; 350  : 		case 0x0D: // fill mouse info
; 351  : 			/*
; 352  : 			EDX = pointer to MOUSE_STATE structure
; 353  : 			Fill the (EDX) with mouse data
; 354  : 			*/
; 355  : 			_asm mov a, edx

	mov	DWORD PTR ?a@@3HA, edx			; a

; 356  : 			//MOUSE_STATE* m = (MOUSE_STATE*)a;
; 357  : 			fillMouseState((MOUSE_STATE*)a);

	mov	eax, DWORD PTR ?a@@3HA			; a
	push	eax
	call	?fillMouseState@@YAXPAUMOUSE_STATE@@@Z	; fillMouseState
	add	esp, 4
$LN57@handleSysC:
	pop	esi
$LN50@handleSysC:

; 358  : 			break;
; 359  : 	}
; 360  : }

	add	esp, 20					; 00000014H
	ret	0
$LN61@handleSysC:
	DD	$LN49@handleSysC
	DD	$LN41@handleSysC
	DD	$LN40@handleSysC
	DD	$LN39@handleSysC
	DD	$LN37@handleSysC
	DD	$LN35@handleSysC
	DD	$LN30@handleSysC
	DD	$LN23@handleSysC
	DD	$LN22@handleSysC
	DD	$LN21@handleSysC
	DD	$LN20@handleSysC
	DD	$LN18@handleSysC
	DD	$LN13@handleSysC
$LN62@handleSysC:
	DD	$LN12@handleSysC
	DD	$LN11@handleSysC
	DD	$LN10@handleSysC
	DD	$LN9@handleSysC
	DD	$LN8@handleSysC
	DD	$LN7@handleSysC
	DD	$LN6@handleSysC
	DD	$LN5@handleSysC
	DD	$LN4@handleSysC
	DD	$LN3@handleSysC
	DD	$LN2@handleSysC
?handleSysCall@@YAXXZ ENDP				; handleSysCall
_TEXT	ENDS
END
