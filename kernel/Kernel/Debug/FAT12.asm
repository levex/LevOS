; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\FAT12.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?FAT@@3PAEA					; FAT
PUBLIC	?_FSysFat@@3U_FILE_SYSTEM@@A			; _FSysFat
PUBLIC	?_MountInfo@@3U_MOUNT_INFO@@A			; _MountInfo
_BSS	SEGMENT
?FAT@@3PAEA DB	0400H DUP (?)				; FAT
?_FSysFat@@3U_FILE_SYSTEM@@A DB 020H DUP (?)		; _FSysFat
?_MountInfo@@3U_MOUNT_INFO@@A DB 01cH DUP (?)		; _MountInfo
_BSS	ENDS
PUBLIC	?ToDosFileName@@YAXPBDPADI@Z			; ToDosFileName
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\fat12.cpp
;	COMDAT ?ToDosFileName@@YAXPBDPADI@Z
_TEXT	SEGMENT
tv622 = -4						; size = 4
_filename$ = 8						; size = 4
_fname$ = 12						; size = 4
_FNameLength$ = 16					; size = 4
?ToDosFileName@@YAXPBDPADI@Z PROC			; ToDosFileName, COMDAT

; 26   :             unsigned int FNameLength) {

	push	ecx

; 27   : 
; 28   : 	unsigned int  i=0;
; 29   : 
; 30   : 	if (FNameLength > 11)

	mov	eax, DWORD PTR _FNameLength$[esp]
	cmp	eax, 11					; 0000000bH
	ja	$LN37@ToDosFileN

; 31   : 		return;
; 32   : 
; 33   : 	if (!fname || !filename)

	push	ebp
	mov	ebp, DWORD PTR _fname$[esp+4]
	test	ebp, ebp
	je	$LN50@ToDosFileN
	push	edi
	mov	edi, DWORD PTR _filename$[esp+8]
	test	edi, edi
	je	$LN51@ToDosFileN

; 34   : 		return;
; 35   : 
; 36   : 	//set all characters in output name to spaces
; 37   : 	memset (fname, ' ', FNameLength);

	push	esi
	push	eax
	push	32					; 00000020H
	push	ebp
	call	?memset@@YAPAXPAXDI@Z			; memset

; 38   : 
; 39   : 	//8.3 filename
; 40   : 	for (i=0; i < strlen(filename)-1 && i < FNameLength; i++) {

	push	edi
	xor	esi, esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 16					; 00000010H
	dec	eax
	je	SHORT $LN48@ToDosFileN
	mov	edx, ebp
	sub	edx, edi
	push	ebx
	mov	ebx, edi
	mov	DWORD PTR tv622[esp+20], edx
	jmp	SHORT $LN13@ToDosFileN
	npad	3
$LL47@ToDosFileN:
	mov	edx, DWORD PTR tv622[esp+20]
$LN13@ToDosFileN:
	cmp	esi, DWORD PTR _FNameLength$[esp+16]
	jae	SHORT $LN52@ToDosFileN

; 41   : 
; 42   : 		if (filename[i] == '.' || i==8 )

	mov	al, BYTE PTR [ebx]
	cmp	al, 46					; 0000002eH
	je	SHORT $LN52@ToDosFileN
	cmp	esi, 8
	je	SHORT $LN52@ToDosFileN

; 43   : 			break;
; 44   : 
; 45   : 		//capitalize character and copy it over (we dont handle LFN format)
; 46   : 		fname[i] = toupper (filename[i] );

	cmp	al, 97					; 00000061H
	jl	SHORT $LN19@ToDosFileN
	cmp	al, 122					; 0000007aH
	jg	SHORT $LN19@ToDosFileN
	mov	ecx, 1
	jmp	SHORT $LN20@ToDosFileN
$LN19@ToDosFileN:
	xor	ecx, ecx
$LN20@ToDosFileN:
	shl	cl, 5
	sub	al, cl
	mov	BYTE PTR [edx+ebx], al
	push	edi
	inc	esi
	inc	ebx
	call	?strlen@@YAIPBD@Z			; strlen
	dec	eax
	add	esp, 4
	cmp	esi, eax
	jb	SHORT $LL47@ToDosFileN
$LN52@ToDosFileN:
	pop	ebx
$LN48@ToDosFileN:

; 47   : 	}
; 48   : 
; 49   : 	//add extension if needed
; 50   : 	if (filename[i]=='.') {

	cmp	BYTE PTR [esi+edi], 46			; 0000002eH
	jne	SHORT $LN36@ToDosFileN

; 51   : 
; 52   : 		//note: cant just copy over-extension might not be 3 chars
; 53   : 		for (int k=0; k<3; k++) {
; 54   : 
; 55   : 			++i;
; 56   : 			if ( filename[i] )

	mov	al, BYTE PTR [esi+edi+1]
	test	al, al
	je	SHORT $LN6@ToDosFileN

; 57   : 				fname[8+k] = filename[i];

	mov	BYTE PTR [ebp+8], al
$LN6@ToDosFileN:

; 51   : 
; 52   : 		//note: cant just copy over-extension might not be 3 chars
; 53   : 		for (int k=0; k<3; k++) {
; 54   : 
; 55   : 			++i;
; 56   : 			if ( filename[i] )

	mov	al, BYTE PTR [esi+edi+2]
	test	al, al
	je	SHORT $LN34@ToDosFileN

; 57   : 				fname[8+k] = filename[i];

	mov	BYTE PTR [ebp+9], al
$LN34@ToDosFileN:

; 51   : 
; 52   : 		//note: cant just copy over-extension might not be 3 chars
; 53   : 		for (int k=0; k<3; k++) {
; 54   : 
; 55   : 			++i;
; 56   : 			if ( filename[i] )

	mov	al, BYTE PTR [esi+edi+3]
	test	al, al
	je	SHORT $LN36@ToDosFileN

; 57   : 				fname[8+k] = filename[i];

	mov	BYTE PTR [ebp+10], al
$LN36@ToDosFileN:

; 58   : 		}
; 59   : 	}
; 60   : 
; 61   : 	//extension must be uppercase (we dont handle LFNs)
; 62   : 	for (i = 0; i < 3; i++)
; 63   : 		fname[8+i] = toupper (fname[8+i]);

	mov	al, BYTE PTR [ebp+8]
	pop	esi
	cmp	al, 97					; 00000061H
	jl	SHORT $LN21@ToDosFileN
	cmp	al, 122					; 0000007aH
	jg	SHORT $LN21@ToDosFileN
	mov	ecx, 1
	jmp	SHORT $LN22@ToDosFileN
$LN21@ToDosFileN:
	xor	ecx, ecx
$LN22@ToDosFileN:
	shl	cl, 5
	sub	al, cl
	mov	BYTE PTR [ebp+8], al
	mov	al, BYTE PTR [ebp+9]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN42@ToDosFileN
	cmp	al, 122					; 0000007aH
	jg	SHORT $LN42@ToDosFileN
	mov	ecx, 1
	jmp	SHORT $LN43@ToDosFileN
$LN42@ToDosFileN:
	xor	ecx, ecx
$LN43@ToDosFileN:
	shl	cl, 5
	sub	al, cl
	mov	BYTE PTR [ebp+9], al
	mov	al, BYTE PTR [ebp+10]
	cmp	al, 97					; 00000061H
	jl	SHORT $LN45@ToDosFileN
	cmp	al, 122					; 0000007aH
	jg	SHORT $LN45@ToDosFileN
	mov	ecx, 1
	shl	cl, 5
	sub	al, cl
	pop	edi
	mov	BYTE PTR [ebp+10], al
	pop	ebp

; 64   : }

	pop	ecx
	ret	0
$LN45@ToDosFileN:

; 58   : 		}
; 59   : 	}
; 60   : 
; 61   : 	//extension must be uppercase (we dont handle LFNs)
; 62   : 	for (i = 0; i < 3; i++)
; 63   : 		fname[8+i] = toupper (fname[8+i]);

	xor	ecx, ecx
	shl	cl, 5
	sub	al, cl
	mov	BYTE PTR [ebp+10], al
$LN51@ToDosFileN:
	pop	edi
$LN50@ToDosFileN:
	pop	ebp
$LN37@ToDosFileN:

; 64   : }

	pop	ecx
	ret	0
?ToDosFileName@@YAXPBDPADI@Z ENDP			; ToDosFileName
_TEXT	ENDS
PUBLIC	?fsysFatGetFilesInRoot@@YAXPAD@Z		; fsysFatGetFilesInRoot
EXTRN	?memcpy@@YAXPAD0H@Z:PROC			; memcpy
EXTRN	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ:PROC ; vd_getCurrentDataDevice
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatGetFilesInRoot@@YAXPAD@Z
_TEXT	SEGMENT
$T3088 = -64						; size = 32
$T3089 = -32						; size = 32
_ret$ = 8						; size = 4
?fsysFatGetFilesInRoot@@YAXPAD@Z PROC			; fsysFatGetFilesInRoot, COMDAT

; 67   : {

	sub	esp, 64					; 00000040H
	push	esi

; 68   : 	char* _ret = ret;
; 69   : 	char j = 0;
; 70   : 	unsigned char* buf;
; 71   : 	buf = (unsigned char*) vd_getCurrentDataDevice().read_sector(_MountInfo.rootOffset);

	lea	eax, DWORD PTR $T3089[esp+68]
	push	edi
	push	eax
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	mov	ecx, 8
	lea	edi, DWORD PTR $T3088[esp+76]
	rep movsd
	mov	ecx, DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+12
	push	ecx
	call	DWORD PTR $T3088[esp+88]
	mov	esi, eax
	add	esp, 8

; 72   : 	while(*buf != 0)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN1@fsysFatGet
	mov	edi, DWORD PTR _ret$[esp+68]
$LL2@fsysFatGet:

; 73   : 	{
; 74   : 		DIRECTORY* dir = (DIRECTORY*)(buf);
; 75   : 		memcpy((char*)dir->Filename, ret, 11);

	push	11					; 0000000bH
	push	edi
	push	esi
	call	?memcpy@@YAXPAD0H@Z			; memcpy

; 76   : 		buf += sizeof(dir);

	add	esi, 4
	add	esp, 12					; 0000000cH
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL2@fsysFatGet
$LN1@fsysFatGet:
	pop	edi
	pop	esi

; 77   : 		j++;
; 78   : 	}
; 79   : 
; 80   : 	return;
; 81   : }

	add	esp, 64					; 00000040H
	ret	0
?fsysFatGetFilesInRoot@@YAXPAD@Z ENDP			; fsysFatGetFilesInRoot
_TEXT	ENDS
PUBLIC	?fsysFatGetNumberOfFilesInRoot@@YADXZ		; fsysFatGetNumberOfFilesInRoot
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatGetNumberOfFilesInRoot@@YADXZ
_TEXT	SEGMENT
$T3095 = -64						; size = 32
$T3096 = -32						; size = 32
?fsysFatGetNumberOfFilesInRoot@@YADXZ PROC		; fsysFatGetNumberOfFilesInRoot, COMDAT

; 84   : {

	sub	esp, 64					; 00000040H
	push	ebx
	push	esi

; 85   : 	char* ret;
; 86   : 	char j = 0;
; 87   : 	unsigned char* buf;
; 88   : 	buf = (unsigned char*) vd_getCurrentDataDevice().read_sector(_MountInfo.rootOffset);

	lea	eax, DWORD PTR $T3096[esp+72]
	push	edi
	push	eax
	xor	bl, bl
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	mov	ecx, 8
	lea	edi, DWORD PTR $T3095[esp+80]
	rep movsd
	mov	ecx, DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+12
	push	ecx
	call	DWORD PTR $T3095[esp+92]
	add	esp, 8

; 89   : 	while(*buf != 0)

	cmp	BYTE PTR [eax], bl
	je	SHORT $LN1@fsysFatGet@2
$LL2@fsysFatGet@2:

; 90   : 	{
; 91   : 		j++;
; 92   : 		buf += 0x20;

	add	eax, 32					; 00000020H
	inc	bl
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL2@fsysFatGet@2
$LN1@fsysFatGet@2:
	pop	edi
	pop	esi

; 93   : 	}
; 94   : 
; 95   : 	return ++j;

	lea	eax, DWORD PTR [ebx+1]
	pop	ebx

; 96   : }

	add	esp, 64					; 00000040H
	ret	0
?fsysFatGetNumberOfFilesInRoot@@YADXZ ENDP		; fsysFatGetNumberOfFilesInRoot
_TEXT	ENDS
PUBLIC	?fsysFatDirectory@@YA?AU_FILE@@PBD@Z		; fsysFatDirectory
EXTRN	?strcpy@@YAPADPADPBD@Z:PROC			; strcpy
EXTRN	?strcmp@@YAHPBD0@Z:PROC				; strcmp
EXTRN	?memcpyTF@@YAXPAD0H@Z:PROC			; memcpyTF
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatDirectory@@YA?AU_FILE@@PBD@Z
_TEXT	SEGMENT
_name$2913 = -88					; size = 11
_DosFileName$ = -76					; size = 11
$T3103 = -64						; size = 32
$T3104 = -32						; size = 32
$T3102 = 8						; size = 4
_DirectoryName$ = 12					; size = 4
?fsysFatDirectory@@YA?AU_FILE@@PBD@Z PROC		; fsysFatDirectory, COMDAT

; 101  : FILE fsysFatDirectory (const char* DirectoryName) {

	sub	esp, 88					; 00000058H

; 102  : 
; 103  : 	FILE file;
; 104  : 	unsigned char* buf;
; 105  : 	PDIRECTORY directory;
; 106  : 
; 107  : 	//get 8.3 directory name
; 108  : 	char DosFileName[11];
; 109  : 	ToDosFileName (DirectoryName, DosFileName, 11);

	mov	ecx, DWORD PTR _DirectoryName$[esp+84]
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	11					; 0000000bH
	lea	eax, DWORD PTR _DosFileName$[esp+108]
	push	eax
	push	ecx
	call	?ToDosFileName@@YAXPBDPADI@Z		; ToDosFileName

; 110  : 	DosFileName[11]=0;

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _DosFileName$[esp+115], bl

; 111  : 
; 112  : 	//14 sectors per directory
; 113  : 	/*
; 114  : 		The root directory contains, at most, 224 DIRECTORY entries.
; 115  : 		A DIRECTORY entry is 32 bytes, 224*32=7168 bytes, 7168 bytes / 512 bytes (512 bytes in a cluster) = 14. 
; 116  : 		This means the root directory consists of 14 clusters.
; 117  : 	*/
; 118  : 	for (int sector=0; sector<14; sector++) {

	xor	ebp, ebp
$LL9@fsysFatDir:

; 119  : 
; 120  : 		//read in sector of root directory
; 121  : 		buf = (unsigned char*) vd_getCurrentDataDevice().read_sector(_MountInfo.rootOffset + sector );

	lea	edx, DWORD PTR $T3104[esp+104]
	push	edx
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	mov	eax, DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+12
	add	eax, ebp
	mov	ecx, 8
	lea	edi, DWORD PTR $T3103[esp+108]
	push	eax
	rep movsd
	call	DWORD PTR $T3103[esp+120]
	add	esp, 8

; 122  : 
; 123  : 		//get directory info
; 124  : 		directory = (PDIRECTORY) buf;

	mov	esi, eax

; 125  : 
; 126  : 		//16 entries per sector
; 127  : 		/*
; 128  : 			512 (one sector) = 32*16
; 129  : 		*/
; 130  : 		for (int i=0; i<16; i++) {

	xor	edi, edi
	npad	3
$LL6@fsysFatDir:

; 131  : 
; 132  : 			//get current filename
; 133  : 			char name[11];
; 134  : 			memcpyTF (name, (char*)(directory->Filename), 11);

	push	11					; 0000000bH
	lea	ecx, DWORD PTR _name$2913[esp+108]
	push	esi
	push	ecx
	call	?memcpyTF@@YAXPAD0H@Z			; memcpyTF

; 135  : 			name[11]=0;
; 136  : 
; 137  : 			//find a match?
; 138  : 			if (strcmp (DosFileName, name) == 0) {

	lea	edx, DWORD PTR _name$2913[esp+116]
	push	edx
	lea	eax, DWORD PTR _DosFileName$[esp+120]
	push	eax
	mov	BYTE PTR _name$2913[esp+135], bl
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN14@fsysFatDir

; 156  : 			}
; 157  : 
; 158  : 			//go to next directory
; 159  : 			directory++;

	inc	edi
	add	esi, 32					; 00000020H
	cmp	edi, 16					; 00000010H
	jl	SHORT $LL6@fsysFatDir

; 111  : 
; 112  : 	//14 sectors per directory
; 113  : 	/*
; 114  : 		The root directory contains, at most, 224 DIRECTORY entries.
; 115  : 		A DIRECTORY entry is 32 bytes, 224*32=7168 bytes, 7168 bytes / 512 bytes (512 bytes in a cluster) = 14. 
; 116  : 		This means the root directory consists of 14 clusters.
; 117  : 	*/
; 118  : 	for (int sector=0; sector<14; sector++) {

	inc	ebp
	cmp	ebp, 14					; 0000000eH
	jl	SHORT $LL9@fsysFatDir

; 160  : 		}
; 161  : 	}
; 162  : 
; 163  : 	//unable to find file
; 164  : 	file.flags = FS_INVALID;

	mov	eax, DWORD PTR $T3102[esp+100]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+32], 2
	pop	ebx

; 165  : 	return file;
; 166  : }

	add	esp, 88					; 00000058H
	ret	0
$LN14@fsysFatDir:

; 139  : 
; 140  : 				//found it, set up file info
; 141  : 				strcpy (file.name, DirectoryName);

	mov	ecx, DWORD PTR _DirectoryName$[esp+100]
	mov	edi, DWORD PTR $T3102[esp+100]
	push	ecx
	push	edi
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 142  : 				file.id             = 0;

	mov	DWORD PTR [edi+40], ebx

; 143  : 				file.currentCluster = directory->FirstCluster;

	movzx	edx, WORD PTR [esi+26]
	mov	DWORD PTR [edi+52], edx

; 144  : 				file.fileLength     = directory->FileSize;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+36], eax

; 145  : 				file.eof            = 0;

	mov	DWORD PTR [edi+44], ebx

; 146  : 				file.fileLength     = directory->FileSize;

	mov	ecx, DWORD PTR [esi+28]
	add	esp, 8

; 147  : 
; 148  : 				//set file type
; 149  : 				if (directory->Attrib == 0x10)

	xor	edx, edx
	mov	DWORD PTR [edi+36], ecx
	cmp	BYTE PTR [esi+11], 16			; 00000010H

; 150  : 					file.flags = FS_DIRECTORY;
; 151  : 				else
; 152  : 					file.flags = FS_FILE;
; 153  : 
; 154  : 				//return file
; 155  : 				return file;

	mov	eax, edi
	sete	dl
	mov	DWORD PTR [edi+32], edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 165  : 	return file;
; 166  : }

	add	esp, 88					; 00000058H
	ret	0
?fsysFatDirectory@@YA?AU_FILE@@PBD@Z ENDP		; fsysFatDirectory
_TEXT	ENDS
PUBLIC	?fsysFatWrite@@YAXPAU_FILE@@PAEI@Z		; fsysFatWrite
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatWrite@@YAXPAU_FILE@@PAEI@Z
_TEXT	SEGMENT
$T3115 = -64						; size = 32
$T3113 = -64						; size = 32
$T3116 = -32						; size = 32
$T3114 = -32						; size = 32
_file$ = 8						; size = 4
_Buffer$ = 12						; size = 4
_Length$ = 16						; size = 4
?fsysFatWrite@@YAXPAU_FILE@@PAEI@Z PROC			; fsysFatWrite, COMDAT

; 169  : {

	sub	esp, 64					; 00000040H

; 170  : 	if(!file) return;

	cmp	DWORD PTR _file$[esp+60], 0
	je	SHORT $LN1@fsysFatWri

; 171  : 	if(Length == 0) return;

	cmp	DWORD PTR _Length$[esp+60], 0
	je	SHORT $LN1@fsysFatWri

; 172  : 	if(Buffer == 0) return;

	cmp	DWORD PTR _Buffer$[esp+60], 0
	je	SHORT $LN1@fsysFatWri

; 173  : 	/*
; 174  : 	Writing a file:
; 175  : 		Find an empty cluster
; 176  : 		Create a root directory entry
; 177  : 		Create a FAT entry for the cluster
; 178  : 		Repeat until filesize is accomplished.
; 179  : 	*/
; 180  : 	int StartSectorOfDataOnDisk = _MountInfo.rootOffset + _MountInfo.rootSize; // skip reserved, bpb, rootdir
; 181  : 
; 182  : 	/* STEP: find free spot in root directory */
; 183  : 	// The root directory consists of 14 sectors AT MOST
; 184  : 	unsigned char* sector = (unsigned char*)(vd_getCurrentDataDevice().read_sector(_MountInfo.rootOffset));

	push	ebx
	push	esi
	lea	eax, DWORD PTR $T3114[esp+72]
	push	edi
	push	eax
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	mov	ecx, 8
	lea	edi, DWORD PTR $T3113[esp+80]
	rep movsd
	mov	ecx, DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+12
	push	ecx
	call	DWORD PTR $T3113[esp+92]
	add	esp, 8

; 185  : 	for(int i = 0; i < 14; i++) // do for each sector

	xor	ebx, ebx
$LL3@fsysFatWri:

; 186  : 	{
; 187  : 		sector = (unsigned char*)(vd_getCurrentDataDevice().read_sector(_MountInfo.rootOffset + i));

	lea	edx, DWORD PTR $T3116[esp+76]
	push	edx
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	mov	eax, DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+12
	add	eax, ebx
	mov	ecx, 8
	lea	edi, DWORD PTR $T3115[esp+80]
	push	eax
	rep movsd
	call	DWORD PTR $T3115[esp+92]
	inc	ebx
	add	esp, 8
	cmp	ebx, 14					; 0000000eH
	jl	SHORT $LL3@fsysFatWri
	pop	edi
	pop	esi
	pop	ebx
$LN1@fsysFatWri:

; 188  : 		DIRECTORY* entry = (DIRECTORY*)sector;
; 189  : 		
; 190  : 	}
; 191  : }

	add	esp, 64					; 00000040H
	ret	0
?fsysFatWrite@@YAXPAU_FILE@@PAEI@Z ENDP			; fsysFatWrite
_TEXT	ENDS
PUBLIC	?fsysFatRead@@YAXPAU_FILE@@PAEI@Z		; fsysFatRead
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatRead@@YAXPAU_FILE@@PAEI@Z
_TEXT	SEGMENT
_nextCluster$2961 = -68					; size = 2
$T3126 = -64						; size = 32
$T3124 = -64						; size = 32
$T3122 = -64						; size = 32
$T3127 = -32						; size = 32
$T3125 = -32						; size = 32
$T3123 = -32						; size = 32
_file$ = 8						; size = 4
_Buffer$ = 12						; size = 4
_Length$ = 16						; size = 4
?fsysFatRead@@YAXPAU_FILE@@PAEI@Z PROC			; fsysFatRead, COMDAT

; 196  : void fsysFatRead(PFILE file, unsigned char* Buffer, unsigned int Length) {

	sub	esp, 68					; 00000044H
	push	ebp

; 197  : 
; 198  : 	if (file) {

	mov	ebp, DWORD PTR _file$[esp+68]
	test	ebp, ebp
	je	$LN5@fsysFatRea

; 199  : 
; 200  : 		//starting physical sector
; 201  : 		unsigned int physSector = 32 + (file->currentCluster - 1);

	push	ebx
	mov	ebx, DWORD PTR [ebp+52]
	push	esi

; 202  : 
; 203  : 		//read in sector
; 204  : 		unsigned char* sector = (unsigned char*) vd_getCurrentDataDevice().read_sector ( physSector );

	lea	eax, DWORD PTR $T3123[esp+80]
	push	edi
	push	eax
	add	ebx, 31					; 0000001fH
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	mov	ecx, 8
	lea	edi, DWORD PTR $T3122[esp+88]
	push	ebx
	rep movsd
	call	DWORD PTR $T3122[esp+100]

; 205  : 
; 206  : 		//copy block of memory
; 207  : 		memcpyTF ((char*)Buffer, (char*)sector, 512);

	mov	ecx, DWORD PTR _Buffer$[esp+88]
	push	512					; 00000200H
	push	eax
	push	ecx
	call	?memcpyTF@@YAXPAD0H@Z			; memcpyTF

; 208  : 
; 209  : 		//locate FAT sector
; 210  : 		unsigned int FAT_Offset = file->currentCluster + (file->currentCluster / 2); //multiply by 1.5

	mov	eax, DWORD PTR [ebp+52]
	mov	ebp, eax
	shr	ebp, 1
	add	ebp, eax

; 211  : 		unsigned int FAT_Sector = 1 + (FAT_Offset / SECTOR_SIZE);

	mov	ebx, ebp

; 212  : 		unsigned int entryOffset = FAT_Offset % SECTOR_SIZE;
; 213  : 
; 214  : 		//read 1st FAT sector
; 215  : 		sector = (unsigned char*) vd_getCurrentDataDevice().read_sector ( FAT_Sector );

	lea	edx, DWORD PTR $T3125[esp+104]
	shr	ebx, 9
	push	edx
	inc	ebx
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	mov	ecx, 8
	lea	edi, DWORD PTR $T3124[esp+108]
	push	ebx
	rep movsd
	call	DWORD PTR $T3124[esp+120]

; 216  : 		memcpyTF ((char*)FAT, (char*)sector, 512);

	push	512					; 00000200H
	push	eax
	push	OFFSET ?FAT@@3PAEA			; FAT
	call	?memcpyTF@@YAXPAD0H@Z			; memcpyTF

; 217  : 
; 218  : 		//read 2nd FAT sector
; 219  : 		sector = (unsigned char*) vd_getCurrentDataDevice().read_sector ( FAT_Sector + 1 );

	lea	eax, DWORD PTR $T3127[esp+124]
	push	eax
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	inc	ebx
	mov	ecx, 8
	lea	edi, DWORD PTR $T3126[esp+128]
	push	ebx
	rep movsd
	call	DWORD PTR $T3126[esp+140]

; 220  : 		memcpyTF ((char*)(FAT + SECTOR_SIZE), (char*)sector, 512);

	push	512					; 00000200H
	push	eax
	push	OFFSET ?FAT@@3PAEA+512
	call	?memcpyTF@@YAXPAD0H@Z			; memcpyTF

; 221  : 
; 222  : 		//read entry for next cluster
; 223  : 		uint16_t nextCluster = *( uint16_t*) &FAT [entryOffset];
; 224  : 
; 225  : 		//test if entry is odd or even
; 226  : 		if( file->currentCluster & 0x0001 )

	mov	eax, DWORD PTR _file$[esp+140]
	add	esp, 60					; 0000003cH
	and	ebp, 511				; 000001ffH
	test	BYTE PTR [eax+52], 1
	movzx	ecx, WORD PTR ?FAT@@3PAEA[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR _nextCluster$2961[esp+76], ecx
	pop	ebx
	je	SHORT $LN4@fsysFatRea

; 227  : 			nextCluster >>= 4;      //grab high 12 bits

	shr	cx, 4

; 228  : 		else

	jmp	SHORT $LN3@fsysFatRea
$LN4@fsysFatRea:

; 229  : 			nextCluster &= 0x0FFF;   //grab low 12 bits

	and	DWORD PTR _nextCluster$2961[esp+72], 4095 ; 00000fffH
	mov	cx, WORD PTR _nextCluster$2961[esp+72]
$LN3@fsysFatRea:

; 230  : 
; 231  : 		//test for end of file
; 232  : 		if ( nextCluster >= 0xff8) {

	mov	edx, 4088				; 00000ff8H
	cmp	cx, dx
	jb	SHORT $LN2@fsysFatRea
$LN8@fsysFatRea:

; 233  : 
; 234  : 			file->eof = 1;

	mov	DWORD PTR [eax+44], 1
	pop	ebp

; 247  : 	}
; 248  : }

	add	esp, 68					; 00000044H
	ret	0
$LN2@fsysFatRea:

; 235  : 			return;
; 236  : 		}
; 237  : 
; 238  : 		//test for file corruption
; 239  : 		if ( nextCluster == 0 ) {

	test	cx, cx

; 240  : 
; 241  : 			file->eof = 1;
; 242  : 			return;

	je	SHORT $LN8@fsysFatRea

; 243  : 		}
; 244  : 
; 245  : 		//set next cluster
; 246  : 		file->currentCluster = nextCluster;

	movzx	ecx, cx
	mov	DWORD PTR [eax+52], ecx
$LN5@fsysFatRea:
	pop	ebp

; 247  : 	}
; 248  : }

	add	esp, 68					; 00000044H
	ret	0
?fsysFatRead@@YAXPAU_FILE@@PAEI@Z ENDP			; fsysFatRead
_TEXT	ENDS
PUBLIC	?fsysFatClose@@YAXPAU_FILE@@@Z			; fsysFatClose
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatClose@@YAXPAU_FILE@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?fsysFatClose@@YAXPAU_FILE@@@Z PROC			; fsysFatClose, COMDAT

; 254  : 
; 255  : 	if (file)

	mov	eax, DWORD PTR _file$[esp-4]
	test	eax, eax
	je	SHORT $LN1@fsysFatClo

; 256  : 		file->flags = FS_INVALID;

	mov	DWORD PTR [eax+32], 2
$LN1@fsysFatClo:

; 257  : }

	ret	0
?fsysFatClose@@YAXPAU_FILE@@@Z ENDP			; fsysFatClose
_TEXT	ENDS
PUBLIC	?fsysFatOpenSubDir@@YA?AU_FILE@@U1@PBD@Z	; fsysFatOpenSubDir
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatOpenSubDir@@YA?AU_FILE@@U1@PBD@Z
_TEXT	SEGMENT
_name$2987 = -536					; size = 11
_DosFileName$ = -524					; size = 11
_buf$2980 = -512					; size = 512
$T3135 = 8						; size = 4
_kFile$ = 12						; size = 60
_filename$ = 72						; size = 4
?fsysFatOpenSubDir@@YA?AU_FILE@@U1@PBD@Z PROC		; fsysFatOpenSubDir, COMDAT

; 263  : 						const char* filename) {

	sub	esp, 536				; 00000218H

; 264  : 
; 265  : 	FILE file;
; 266  : 
; 267  : 	//get 8.3 directory name
; 268  : 	char DosFileName[11];
; 269  : 	ToDosFileName (filename, DosFileName, 11);

	mov	ecx, DWORD PTR _filename$[esp+532]
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	11					; 0000000bH
	lea	eax, DWORD PTR _DosFileName$[esp+556]
	push	eax
	push	ecx
	call	?ToDosFileName@@YAXPBDPADI@Z		; ToDosFileName

; 270  : 	DosFileName[11]=0;
; 271  : 
; 272  : 	//read directory
; 273  : 	while (! kFile.eof ) {

	mov	ebp, DWORD PTR $T3135[esp+560]
	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _DosFileName$[esp+563], bl
	cmp	DWORD PTR _kFile$[esp+592], ebx
	jne	SHORT $LN7@fsysFatOpe
	npad	9
$LL8@fsysFatOpe:

; 274  : 
; 275  : 		//read directory
; 276  : 		unsigned char buf[512];
; 277  : 		fsysFatRead (&file, buf, 512);

	push	512					; 00000200H
	lea	edx, DWORD PTR _buf$2980[esp+556]
	push	edx
	push	ebp
	call	?fsysFatRead@@YAXPAU_FILE@@PAEI@Z	; fsysFatRead
	add	esp, 12					; 0000000cH

; 278  : 
; 279  : 		//set directort
; 280  : 		PDIRECTORY pkDir = (PDIRECTORY) buf;

	lea	esi, DWORD PTR _buf$2980[esp+552]

; 281  : 
; 282  : 		//16 entries in buffer
; 283  : 		for (unsigned int i = 0; i < 16; i++) {

	xor	edi, edi
	npad	7
$LL6@fsysFatOpe:

; 284  : 
; 285  : 			//get current filename
; 286  : 			char name[11];
; 287  : 			memcpyTF (name, (char*)(pkDir->Filename), 11);

	push	11					; 0000000bH
	lea	eax, DWORD PTR _name$2987[esp+556]
	push	esi
	push	eax
	call	?memcpyTF@@YAXPAD0H@Z			; memcpyTF

; 288  : 			name[11]=0;
; 289  : 
; 290  : 			//match?
; 291  : 			if (strcmp (name, DosFileName) == 0) {

	lea	ecx, DWORD PTR _DosFileName$[esp+564]
	push	ecx
	lea	edx, DWORD PTR _name$2987[esp+568]
	push	edx
	mov	BYTE PTR _name$2987[esp+583], bl
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN13@fsysFatOpe

; 303  : 					file.flags = FS_DIRECTORY;
; 304  : 				else
; 305  : 					file.flags = FS_FILE;
; 306  : 
; 307  : 				//return file
; 308  : 				return file;
; 309  : 			}
; 310  : 
; 311  : 			//go to next entry
; 312  : 			pkDir++;

	inc	edi
	add	esi, 32					; 00000020H
	cmp	edi, 16					; 00000010H
	jb	SHORT $LL6@fsysFatOpe

; 270  : 	DosFileName[11]=0;
; 271  : 
; 272  : 	//read directory
; 273  : 	while (! kFile.eof ) {

	cmp	DWORD PTR _kFile$[esp+592], ebx
	je	SHORT $LL8@fsysFatOpe
$LN7@fsysFatOpe:
	pop	edi
	pop	esi

; 313  : 		}
; 314  : 	}
; 315  : 
; 316  : 	//unable to find file
; 317  : 	file.flags = FS_INVALID;

	mov	DWORD PTR [ebp+32], 2

; 318  : 	return file;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 319  : }

	add	esp, 536				; 00000218H
	ret	0
$LN13@fsysFatOpe:

; 292  : 
; 293  : 				//found it, set up file info
; 294  : 				strcpy (file.name, filename);

	mov	eax, DWORD PTR _filename$[esp+548]
	push	eax
	push	ebp
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 295  : 				file.id             = 0;
; 296  : 				file.currentCluster = pkDir->FirstCluster;

	movzx	ecx, WORD PTR [esi+26]

; 297  : 				file.fileLength     = pkDir->FileSize;
; 298  : 				file.eof            = 0;
; 299  : 				file.fileLength     = pkDir->FileSize;

	mov	edx, DWORD PTR [esi+28]
	add	esp, 8

; 300  : 
; 301  : 				//set file type
; 302  : 				if (pkDir->Attrib == 0x10)

	xor	eax, eax
	cmp	BYTE PTR [esi+11], 16			; 00000010H
	pop	edi
	sete	al
	pop	esi
	mov	DWORD PTR [ebp+40], ebx
	mov	DWORD PTR [ebp+44], ebx
	mov	DWORD PTR [ebp+52], ecx
	mov	DWORD PTR [ebp+36], edx
	mov	DWORD PTR [ebp+32], eax

; 318  : 	return file;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 319  : }

	add	esp, 536				; 00000218H
	ret	0
?fsysFatOpenSubDir@@YA?AU_FILE@@U1@PBD@Z ENDP		; fsysFatOpenSubDir
_TEXT	ENDS
PUBLIC	?fsysFatOpen@@YA?AU_FILE@@PBD@Z			; fsysFatOpen
EXTRN	?strchr@@YAPADPADH@Z:PROC			; strchr
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatOpen@@YA?AU_FILE@@PBD@Z
_TEXT	SEGMENT
_rootDir$ = -145					; size = 1
tv412 = -144						; size = 4
tv410 = -140						; size = 4
_pathname$3007 = -136					; size = 16
_ret$ = -120						; size = 60
_curDirectory$ = -120					; size = 60
$T3150 = -60						; size = 60
$T3148 = -60						; size = 60
$T3146 = -60						; size = 60
$T3144 = 8						; size = 4
_FileName$ = 12						; size = 4
?fsysFatOpen@@YA?AU_FILE@@PBD@Z PROC			; fsysFatOpen, COMDAT

; 324  : FILE fsysFatOpen (const char* FileName) {

	sub	esp, 148				; 00000094H
	push	ebx
	push	ebp
	push	esi

; 325  : 
; 326  : 	FILE curDirectory;
; 327  : 	char* p = 0;
; 328  : 	bool rootDir=true;
; 329  : 	char* path = (char*) FileName;
; 330  : 
; 331  : 	//any '\'s in path?
; 332  : 	p = strchr (path, '\\');

	mov	esi, DWORD PTR _FileName$[esp+156]
	push	edi
	push	92					; 0000005cH
	push	esi
	mov	BYTE PTR _rootDir$[esp+172], 1
	call	?strchr@@YAPADPADH@Z			; strchr
	mov	ebp, eax

; 333  : 	if (!p) {

	xor	ebx, ebx
	add	esp, 8
	cmp	ebp, ebx
	jne	SHORT $LN14@fsysFatOpe@2

; 334  : 
; 335  : 		//nope, must be in root directory, search it
; 336  : 		curDirectory = fsysFatDirectory (path);

	lea	eax, DWORD PTR $T3146[esp+164]
	push	esi
	push	eax
	call	?fsysFatDirectory@@YA?AU_FILE@@PBD@Z	; fsysFatDirectory
	mov	ecx, 15					; 0000000fH
	mov	esi, eax
	lea	edi, DWORD PTR _curDirectory$[esp+172]
	rep movsd
	add	esp, 8

; 337  : 
; 338  : 		//found file?
; 339  : 		if (curDirectory.flags == FS_FILE)
; 340  : 			return curDirectory;

	lea	ecx, DWORD PTR [ebx+15]
	cmp	DWORD PTR _curDirectory$[esp+196], ebx
	jne	$LN13@fsysFatOpe@2
	mov	esi, eax

; 396  : 	return ret;

	mov	eax, DWORD PTR $T3144[esp+160]
	mov	edi, eax
	rep movsd

; 397  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 148				; 00000094H
	ret	0
$LN14@fsysFatOpe@2:

; 341  : 		//unable to find
; 342  : 		FILE ret;
; 343  : 		ret.flags = FS_INVALID;
; 344  : 		return ret;
; 345  : 	}
; 346  : 
; 347  : 	//go to next character after first '\'
; 348  : 	p++;

	inc	ebp

; 349  : 
; 350  : 	while ( p ) {

	je	$LN31@fsysFatOpe@2
$LL12@fsysFatOpe@2:

; 351  : 
; 352  : 		//get pathname
; 353  : 		char pathname[16];
; 354  : 		int i=0;
; 355  : 		for (i=0; i<16; i++) {

	mov	ecx, ebp
	xor	eax, eax
	neg	ecx
	lea	edx, DWORD PTR _pathname$3007[esp+ecx+166]
	lea	esi, DWORD PTR _pathname$3007[esp+ecx+164]
	lea	edi, DWORD PTR _pathname$3007[esp+ecx+165]
	lea	ecx, DWORD PTR _pathname$3007[esp+ecx+167]
	mov	DWORD PTR tv410[esp+164], edx
	mov	DWORD PTR tv412[esp+164], ecx
	npad	2
$LL30@fsysFatOpe@2:

; 356  : 
; 357  : 			//if another '\' or end of line is reached, we are done
; 358  : 			if (p[i]=='\\' || p[i]=='\0')

	mov	dl, BYTE PTR [eax+ebp]
	lea	ecx, DWORD PTR [eax+ebp]
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN19@fsysFatOpe@2
	test	dl, dl
	je	SHORT $LN19@fsysFatOpe@2

; 359  : 				break;
; 360  : 
; 361  : 			//copy character
; 362  : 			pathname[i]=p[i];

	mov	BYTE PTR [esi+ecx], dl
	mov	dl, BYTE PTR [eax+ebp+1]
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN23@fsysFatOpe@2

; 356  : 
; 357  : 			//if another '\' or end of line is reached, we are done
; 358  : 			if (p[i]=='\\' || p[i]=='\0')

	test	dl, dl
	je	SHORT $LN23@fsysFatOpe@2

; 359  : 				break;
; 360  : 
; 361  : 			//copy character
; 362  : 			pathname[i]=p[i];

	mov	BYTE PTR [edi+ecx], dl
	mov	dl, BYTE PTR [eax+ebp+2]
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN25@fsysFatOpe@2

; 356  : 
; 357  : 			//if another '\' or end of line is reached, we are done
; 358  : 			if (p[i]=='\\' || p[i]=='\0')

	test	dl, dl
	je	SHORT $LN25@fsysFatOpe@2

; 359  : 				break;
; 360  : 
; 361  : 			//copy character
; 362  : 			pathname[i]=p[i];

	mov	ebx, DWORD PTR tv410[esp+164]
	mov	BYTE PTR [ebx+ecx], dl
	mov	dl, BYTE PTR [eax+ebp+3]
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN28@fsysFatOpe@2

; 356  : 
; 357  : 			//if another '\' or end of line is reached, we are done
; 358  : 			if (p[i]=='\\' || p[i]=='\0')

	test	dl, dl
	je	SHORT $LN28@fsysFatOpe@2

; 359  : 				break;
; 360  : 
; 361  : 			//copy character
; 362  : 			pathname[i]=p[i];

	mov	ebx, DWORD PTR tv412[esp+164]
	add	eax, 4
	mov	BYTE PTR [ebx+ecx], dl
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL30@fsysFatOpe@2
	jmp	SHORT $LN19@fsysFatOpe@2
$LN23@fsysFatOpe@2:

; 356  : 
; 357  : 			//if another '\' or end of line is reached, we are done
; 358  : 			if (p[i]=='\\' || p[i]=='\0')

	inc	eax
	jmp	SHORT $LN19@fsysFatOpe@2
$LN25@fsysFatOpe@2:
	add	eax, 2
	jmp	SHORT $LN19@fsysFatOpe@2
$LN28@fsysFatOpe@2:
	add	eax, 3
$LN19@fsysFatOpe@2:

; 363  : 		}
; 364  : 		pathname[i]=0; //null terminate

	xor	ebx, ebx
	mov	BYTE PTR _pathname$3007[esp+eax+164], bl

; 365  : 
; 366  : 		//open subdirectory or file
; 367  : 		if (rootDir) {

	cmp	BYTE PTR _rootDir$[esp+164], bl
	je	SHORT $LN5@fsysFatOpe@2

; 368  : 
; 369  : 			//search root directory - open pathname
; 370  : 			curDirectory = fsysFatDirectory (pathname);

	lea	edx, DWORD PTR _pathname$3007[esp+164]
	push	edx
	lea	eax, DWORD PTR $T3148[esp+168]
	push	eax
	call	?fsysFatDirectory@@YA?AU_FILE@@PBD@Z	; fsysFatDirectory
	add	esp, 8

; 371  : 			rootDir=false;

	mov	BYTE PTR _rootDir$[esp+164], bl

; 372  : 		}
; 373  : 		else {

	jmp	SHORT $LN33@fsysFatOpe@2
$LN5@fsysFatOpe@2:

; 374  : 
; 375  : 			//search a subdirectory instead for pathname
; 376  : 			curDirectory = fsysFatOpenSubDir (curDirectory, pathname);

	lea	ecx, DWORD PTR _pathname$3007[esp+164]
	push	ecx
	sub	esp, 60					; 0000003cH
	lea	edx, DWORD PTR $T3150[esp+228]
	mov	edi, esp
	mov	ecx, 15					; 0000000fH
	lea	esi, DWORD PTR _curDirectory$[esp+228]
	push	edx
	rep movsd
	call	?fsysFatOpenSubDir@@YA?AU_FILE@@U1@PBD@Z ; fsysFatOpenSubDir
	add	esp, 68					; 00000044H
$LN33@fsysFatOpe@2:
	mov	esi, eax
	mov	ecx, 15					; 0000000fH
	lea	edi, DWORD PTR _curDirectory$[esp+164]
	rep movsd

; 377  : 		}
; 378  : 
; 379  : 		//found directory or file?
; 380  : 		if (curDirectory.flags == FS_INVALID)

	mov	eax, DWORD PTR _curDirectory$[esp+196]
	cmp	eax, 2
	je	SHORT $LN31@fsysFatOpe@2

; 381  : 			break;
; 382  : 
; 383  : 		//found file?
; 384  : 		if (curDirectory.flags == FS_FILE)

	cmp	eax, ebx
	je	SHORT $LN21@fsysFatOpe@2

; 386  : 
; 387  : 		//find next '\'
; 388  : 		p=strchr (p+1, '\\');

	push	92					; 0000005cH
	inc	ebp
	push	ebp
	call	?strchr@@YAPADPADH@Z			; strchr
	mov	ebp, eax
	add	esp, 8

; 389  : 		if (p)

	cmp	ebp, ebx
	je	SHORT $LN31@fsysFatOpe@2

; 390  : 			p++;

	inc	ebp

; 349  : 
; 350  : 	while ( p ) {

	jne	$LL12@fsysFatOpe@2
$LN31@fsysFatOpe@2:

; 396  : 	return ret;

	mov	ecx, 15					; 0000000fH
$LN13@fsysFatOpe@2:

; 391  : 	}
; 392  : 
; 393  : 	//unable to find
; 394  : 	FILE ret;
; 395  : 	ret.flags = FS_INVALID;

	mov	DWORD PTR _ret$[esp+196], 2
$LN34@fsysFatOpe@2:

; 396  : 	return ret;

	mov	eax, DWORD PTR $T3144[esp+160]
	lea	esi, DWORD PTR _ret$[esp+164]
	mov	edi, eax
	rep movsd

; 397  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 148				; 00000094H
	ret	0
$LN21@fsysFatOpe@2:

; 385  : 			return curDirectory;

	mov	ecx, 15					; 0000000fH
	jmp	SHORT $LN34@fsysFatOpe@2
?fsysFatOpen@@YA?AU_FILE@@PBD@Z ENDP			; fsysFatOpen
_TEXT	ENDS
PUBLIC	?fsysFatMount@@YAXXZ				; fsysFatMount
; Function compile flags: /Ogtpy
;	COMDAT ?fsysFatMount@@YAXXZ
_TEXT	SEGMENT
$T3172 = -64						; size = 32
$T3173 = -32						; size = 32
?fsysFatMount@@YAXXZ PROC				; fsysFatMount, COMDAT

; 402  : void fsysFatMount () {

	sub	esp, 64					; 00000040H
	push	esi

; 403  : 
; 404  : 	//Boot sector info
; 405  : 	PBOOTSECTOR bootsector;
; 406  : 
; 407  : 	//read boot sector
; 408  : 	bootsector = (PBOOTSECTOR) vd_getCurrentDataDevice().read_sector (0);

	lea	eax, DWORD PTR $T3173[esp+68]
	push	edi
	push	eax
	call	?vd_getCurrentDataDevice@@YA?AU__DATA_DEVICE@@XZ ; vd_getCurrentDataDevice
	mov	esi, eax
	mov	ecx, 8
	lea	edi, DWORD PTR $T3172[esp+76]
	push	0
	rep movsd
	call	DWORD PTR $T3172[esp+88]
	mov	ecx, eax

; 409  : 
; 410  : 	//store mount info
; 411  : 	_MountInfo.numSectors     = bootsector->Bpb.NumSectors;

	movzx	edx, WORD PTR [ecx+19]
	mov	DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A, edx

; 412  : 	_MountInfo.fatOffset      = 1;

	mov	DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+4, 1

; 413  : 	_MountInfo.fatSize        = bootsector->Bpb.SectorsPerFat;

	movzx	eax, WORD PTR [ecx+22]
	mov	DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+20, eax

; 414  : 	_MountInfo.fatEntrySize   = 8;

	mov	DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+24, 8

; 415  : 	_MountInfo.numRootEntries = bootsector->Bpb.NumDirEntries;

	movzx	edx, WORD PTR [ecx+17]
	mov	DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+8, edx

; 416  : 	_MountInfo.rootOffset     = (bootsector->Bpb.NumberOfFats * bootsector->Bpb.SectorsPerFat) + 1;

	movzx	edx, WORD PTR [ecx+22]
	movzx	eax, BYTE PTR [ecx+16]
	imul	eax, edx
	inc	eax
	mov	DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+12, eax

; 417  : 	_MountInfo.rootSize       = ( bootsector->Bpb.NumDirEntries * 32 ) / bootsector->Bpb.BytesPerSector;

	movzx	eax, WORD PTR [ecx+17]
	movzx	ecx, WORD PTR [ecx+11]
	shl	eax, 5
	add	esp, 8
	cdq
	idiv	ecx
	pop	edi
	pop	esi
	mov	DWORD PTR ?_MountInfo@@3U_MOUNT_INFO@@A+16, eax

; 418  : }

	add	esp, 64					; 00000040H
	ret	0
?fsysFatMount@@YAXXZ ENDP				; fsysFatMount
_TEXT	ENDS
PUBLIC	??_C@_05HOBJIFPH@FAT12?$AA@			; `string'
PUBLIC	?fsysFatInitialize@@YAXU__DATA_DEVICE@@@Z	; fsysFatInitialize
EXTRN	?volRegisterFileSystem@@YAXPAU_FILE_SYSTEM@@I@Z:PROC ; volRegisterFileSystem
;	COMDAT ??_C@_05HOBJIFPH@FAT12?$AA@
CONST	SEGMENT
??_C@_05HOBJIFPH@FAT12?$AA@ DB 'FAT12', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?fsysFatInitialize@@YAXU__DATA_DEVICE@@@Z
_TEXT	SEGMENT
_datadev$ = 8						; size = 32
?fsysFatInitialize@@YAXU__DATA_DEVICE@@@Z PROC		; fsysFatInitialize, COMDAT

; 424  : 
; 425  : 	//initialize filesystem struct
; 426  : 	strcpy (_FSysFat.Name, "FAT12");

	push	OFFSET ??_C@_05HOBJIFPH@FAT12?$AA@
	push	OFFSET ?_FSysFat@@3U_FILE_SYSTEM@@A	; _FSysFat
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 427  : 	_FSysFat.Directory = fsysFatDirectory;
; 428  : 	_FSysFat.Mount     = fsysFatMount;
; 429  : 	_FSysFat.Open      = fsysFatOpen;
; 430  : 	_FSysFat.Read      = fsysFatRead;
; 431  : 	_FSysFat.Close     = fsysFatClose;
; 432  : 
; 433  : 	//register ourself to volume manager
; 434  : 	volRegisterFileSystem ( &_FSysFat, datadev.uniqueID );

	mov	eax, DWORD PTR _datadev$[esp+8]
	push	eax
	push	OFFSET ?_FSysFat@@3U_FILE_SYSTEM@@A	; _FSysFat
	mov	DWORD PTR ?_FSysFat@@3U_FILE_SYSTEM@@A+8, OFFSET ?fsysFatDirectory@@YA?AU_FILE@@PBD@Z ; fsysFatDirectory
	mov	DWORD PTR ?_FSysFat@@3U_FILE_SYSTEM@@A+12, OFFSET ?fsysFatMount@@YAXXZ ; fsysFatMount
	mov	DWORD PTR ?_FSysFat@@3U_FILE_SYSTEM@@A+28, OFFSET ?fsysFatOpen@@YA?AU_FILE@@PBD@Z ; fsysFatOpen
	mov	DWORD PTR ?_FSysFat@@3U_FILE_SYSTEM@@A+16, OFFSET ?fsysFatRead@@YAXPAU_FILE@@PAEI@Z ; fsysFatRead
	mov	DWORD PTR ?_FSysFat@@3U_FILE_SYSTEM@@A+24, OFFSET ?fsysFatClose@@YAXPAU_FILE@@@Z ; fsysFatClose
	call	?volRegisterFileSystem@@YAXPAU_FILE_SYSTEM@@I@Z ; volRegisterFileSystem
	add	esp, 16					; 00000010H

; 435  : 
; 436  : 	//mounr filesystem
; 437  : 	fsysFatMount ();

	jmp	?fsysFatMount@@YAXXZ			; fsysFatMount
?fsysFatInitialize@@YAXU__DATA_DEVICE@@@Z ENDP		; fsysFatInitialize
_TEXT	ENDS
END
