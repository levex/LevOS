; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\Kernel\GDT.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
__gdt	DD	0ffffffffH
_DATA	ENDS
_BSS	SEGMENT
__gdtr	DF	01H DUP (?)
; Function compile flags: /Ogtpy
; File c:\dev\levos\kernel\kernel\gdt.cpp
_BSS	ENDS
;	COMDAT ?gdt_install@@YAXXZ
_TEXT	SEGMENT
?gdt_install@@YAXXZ PROC				; gdt_install, COMDAT

; 39   : 	_asm lgdt [_gdtr]

	lgdt	FWORD PTR __gdtr

; 40   : }

	ret	0
?gdt_install@@YAXXZ ENDP				; gdt_install
_TEXT	ENDS
PUBLIC	?gdt_set_descriptor@@YAXI_K0EE@Z		; gdt_set_descriptor
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
;	COMDAT ?gdt_set_descriptor@@YAXI_K0EE@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 8
_limit$ = 20						; size = 8
_access$ = 28						; size = 1
_grand$ = 32						; size = 1
?gdt_set_descriptor@@YAXI_K0EE@Z PROC			; gdt_set_descriptor, COMDAT

; 44   : {

	push	esi

; 45   : 	if (i > MAX_DESCRIPTORS)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, 5
	ja	SHORT $LN2@gdt_set_de

; 46   : 		return;
; 47   : 
; 48   : 	// null out the descriptor
; 49   : 	memset ((void*)&_gdt[i], 0, sizeof (gdt_descriptor));

	mov	eax, DWORD PTR __gdt
	push	ebx
	push	edi
	push	8
	lea	ecx, DWORD PTR [eax+esi*8]
	push	0
	push	ecx
	call	?memset@@YAPAXPAXDI@Z			; memset

; 50   : 
; 51   : 	// set limit and base addresses
; 52   : 	_gdt[i].baseLo	= uint16_t(base & 0xffff);

	mov	edi, DWORD PTR _base$[esp+20]

; 53   : 	_gdt[i].baseMid	= unsigned char((base >> 16) & 0xff);

	mov	ecx, DWORD PTR _base$[esp+24]
	mov	eax, DWORD PTR __gdt
	mov	ebx, ecx
	mov	edx, edi
	shrd	edx, ebx, 16
	mov	BYTE PTR [eax+esi*8+4], dl

; 54   : 	_gdt[i].baseHi	= unsigned char((base >> 24) & 0xff);

	mov	edx, edi
	shrd	edx, ecx, 24
	mov	BYTE PTR [eax+esi*8+7], dl

; 55   : 	_gdt[i].limit	= uint16_t(limit & 0xffff);
; 56   : 
; 57   : 	// set flags and grandularity bytes
; 58   : 	_gdt[i].flags = access;

	mov	dl, BYTE PTR _access$[esp+20]
	shr	ecx, 24					; 00000018H
	mov	ecx, DWORD PTR _limit$[esp+20]
	mov	BYTE PTR [eax+esi*8+5], dl

; 59   : 	_gdt[i].grand = unsigned char((limit >> 16) & 0x0f);

	mov	edx, DWORD PTR _limit$[esp+24]
	mov	WORD PTR [eax+esi*8], cx
	shrd	ecx, edx, 16
	shr	ebx, 16					; 00000010H

; 60   : 	_gdt[i].grand |= grand & 0xf0;

	mov	bl, cl
	mov	cl, BYTE PTR _grand$[esp+20]
	xor	bl, cl
	add	esp, 12					; 0000000cH
	and	bl, 15					; 0000000fH
	shr	edx, 16					; 00000010H
	xor	bl, cl
	mov	WORD PTR [eax+esi*8+2], di
	pop	edi
	mov	BYTE PTR [eax+esi*8+6], bl
	pop	ebx
$LN2@gdt_set_de:
	pop	esi

; 61   : }

	ret	0
?gdt_set_descriptor@@YAXI_K0EE@Z ENDP			; gdt_set_descriptor
_TEXT	ENDS
PUBLIC	?i86_gdt_get_descriptor@@YAPAUgdt_descriptor@@H@Z ; i86_gdt_get_descriptor
; Function compile flags: /Ogtpy
;	COMDAT ?i86_gdt_get_descriptor@@YAPAUgdt_descriptor@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?i86_gdt_get_descriptor@@YAPAUgdt_descriptor@@H@Z PROC	; i86_gdt_get_descriptor, COMDAT

; 66   : 
; 67   : 	if (i > MAX_DESCRIPTORS)

	mov	eax, DWORD PTR _i$[esp-4]
	cmp	eax, 5
	jle	SHORT $LN1@i86_gdt_ge

; 68   : 		return 0;

	xor	eax, eax

; 71   : }

	ret	0
$LN1@i86_gdt_ge:

; 69   : 
; 70   : 	return &_gdt[i];

	mov	ecx, DWORD PTR __gdt
	lea	eax, DWORD PTR [ecx+eax*8]

; 71   : }

	ret	0
?i86_gdt_get_descriptor@@YAPAUgdt_descriptor@@H@Z ENDP	; i86_gdt_get_descriptor
_TEXT	ENDS
PUBLIC	?i86_gdt_initialize@@YAHXZ			; i86_gdt_initialize
; Function compile flags: /Ogtpy
;	COMDAT ?i86_gdt_initialize@@YAHXZ
_TEXT	SEGMENT
?i86_gdt_initialize@@YAHXZ PROC				; i86_gdt_initialize, COMDAT

; 75   : int i86_gdt_initialize () {

	push	ebx

; 76   : 
; 77   : 	// set up gdtr
; 78   : 	_gdtr.m_limit = (sizeof (struct gdt_descriptor) * MAX_DESCRIPTORS)-1;

	mov	eax, 39					; 00000027H

; 79   : 	_gdtr.m_base = (uint32_t)&_gdt[0];
; 80   : 
; 81   : 	// set null descriptor
; 82   : 	gdt_set_descriptor(0, 0, 0, 0, 0);

	push	8
	mov	WORD PTR __gdtr, ax
	mov	eax, DWORD PTR __gdt
	xor	ebx, ebx
	push	ebx
	push	eax
	mov	DWORD PTR __gdtr+2, eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	mov	eax, DWORD PTR __gdt
	xor	ecx, ecx

; 83   : 
; 84   : 	// set default code descriptor
; 85   : 	gdt_set_descriptor (1,0,0xffffffff,
; 86   : 		I86_GDT_DESC_READWRITE|I86_GDT_DESC_EXEC_CODE|I86_GDT_DESC_CODEDATA|I86_GDT_DESC_MEMORY,
; 87   : 		I86_GDT_GRAND_4K | I86_GDT_GRAND_32BIT | I86_GDT_GRAND_LIMITHI_MASK);

	push	8
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebx
	add	eax, 8
	push	ebx
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	mov	eax, DWORD PTR __gdt

; 88   : 
; 89   : 	// set default data descriptor
; 90   : 	gdt_set_descriptor (2,0,0xffffffff,
; 91   : 		I86_GDT_DESC_READWRITE|I86_GDT_DESC_CODEDATA|I86_GDT_DESC_MEMORY,
; 92   : 		I86_GDT_GRAND_4K | I86_GDT_GRAND_32BIT | I86_GDT_GRAND_LIMITHI_MASK);

	push	8
	mov	DWORD PTR [eax+8], 65535		; 0000ffffH
	mov	DWORD PTR [eax+12], 13605376		; 00cf9a00H
	add	eax, 16					; 00000010H
	push	ebx
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	mov	eax, DWORD PTR __gdt

; 93   : 	// set real mode code desc
; 94   : 	gdt_set_descriptor (3,0,0xfffff,
; 95   : 		I86_GDT_DESC_READWRITE|I86_GDT_DESC_EXEC_CODE|I86_GDT_DESC_CODEDATA|I86_GDT_DESC_MEMORY,
; 96   : 		0);

	push	8
	mov	DWORD PTR [eax+16], 65535		; 0000ffffH
	mov	DWORD PTR [eax+20], 13603328		; 00cf9200H
	add	eax, 24					; 00000018H
	push	ebx
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	mov	eax, DWORD PTR __gdt

; 97   : 	// set real mode data desc
; 98   : 	gdt_set_descriptor (4,0,0xfffff,
; 99   : 		I86_GDT_DESC_READWRITE|I86_GDT_DESC_CODEDATA|I86_GDT_DESC_MEMORY,
; 100  : 		0);

	push	8
	mov	DWORD PTR [eax+24], 65535		; 0000ffffH
	mov	DWORD PTR [eax+28], 1022464		; 000f9a00H
	add	eax, 32					; 00000020H
	push	ebx
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	mov	eax, DWORD PTR __gdt
	add	esp, 60					; 0000003cH
	mov	DWORD PTR [eax+32], 65535		; 0000ffffH
	mov	DWORD PTR [eax+36], 1020416		; 000f9200H

; 101  : 
; 102  : 	// install gdtr
; 103  : 	gdt_install ();

	lgdt	FWORD PTR __gdtr

; 104  : 
; 105  : 	return 0;

	xor	eax, eax
	pop	ebx

; 106  : }

	ret	0
?i86_gdt_initialize@@YAHXZ ENDP				; i86_gdt_initialize
_TEXT	ENDS
PUBLIC	?i86_gdt_setup@@YA_NH@Z				; i86_gdt_setup
; Function compile flags: /Ogtpy
;	COMDAT ?i86_gdt_setup@@YA_NH@Z
_TEXT	SEGMENT
_loc$ = 8						; size = 4
?i86_gdt_setup@@YA_NH@Z PROC				; i86_gdt_setup, COMDAT

; 31   : {

	push	esi

; 32   : 	_gdt = (gdt_descriptor*)loc;

	mov	esi, DWORD PTR _loc$[esp]
	mov	DWORD PTR __gdt, esi

; 33   : 	i86_gdt_initialize();

	call	?i86_gdt_initialize@@YAHXZ		; i86_gdt_initialize

; 34   : 	return ((int)_gdt==loc);

	xor	eax, eax
	cmp	DWORD PTR __gdt, esi
	pop	esi
	sete	al

; 35   : }

	ret	0
?i86_gdt_setup@@YA_NH@Z ENDP				; i86_gdt_setup
_TEXT	ENDS
END
