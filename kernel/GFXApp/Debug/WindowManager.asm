; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\GFXApp\WindowManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?findFirstFreeSlot@@YAHXZ			; findFirstFreeSlot
_BSS	SEGMENT
_wList	DB	0220H DUP (?)
; Function compile flags: /Odtp /ZI
; File c:\dev\levos\kernel\gfxapp\windowmanager.cpp
_BSS	ENDS
;	COMDAT ?findFirstFreeSlot@@YAHXZ
_TEXT	SEGMENT
_i$2557 = -4						; size = 4
?findFirstFreeSlot@@YAHXZ PROC				; findFirstFreeSlot, COMDAT

; 8    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 9    : 	for(int i = 0; i < 16; i++)

	mov	DWORD PTR _i$2557[ebp], 0
	jmp	SHORT $LN4@findFirstF
$LN3@findFirstF:
	mov	eax, DWORD PTR _i$2557[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2557[ebp], eax
$LN4@findFirstF:
	cmp	DWORD PTR _i$2557[ebp], 16		; 00000010H
	jge	SHORT $LN2@findFirstF

; 10   : 	{
; 11   : 		if(!wList[i].isValid) return i;

	mov	eax, DWORD PTR _i$2557[ebp]
	imul	eax, 34					; 00000022H
	movzx	ecx, BYTE PTR _wList[eax+12]
	test	ecx, ecx
	jne	SHORT $LN1@findFirstF
	mov	eax, DWORD PTR _i$2557[ebp]
	jmp	SHORT $LN5@findFirstF
$LN1@findFirstF:

; 12   : 	}

	jmp	SHORT $LN3@findFirstF
$LN2@findFirstF:

; 13   : 	return -1;

	or	eax, -1
$LN5@findFirstF:

; 14   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?findFirstFreeSlot@@YAHXZ ENDP				; findFirstFreeSlot
_TEXT	ENDS
PUBLIC	?addWindow@@YAHUWINDOW@@@Z			; addWindow
; Function compile flags: /Odtp /ZI
;	COMDAT ?addWindow@@YAHUWINDOW@@@Z
_TEXT	SEGMENT
_w$ = 8							; size = 34
?addWindow@@YAHUWINDOW@@@Z PROC				; addWindow, COMDAT

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 18   : 	if(!w.isValid) return -1;

	movzx	eax, BYTE PTR _w$[ebp+12]
	test	eax, eax
	jne	SHORT $LN2@addWindow
	or	eax, -1
	jmp	SHORT $LN3@addWindow
$LN2@addWindow:

; 19   : 	w.windowId = findFirstFreeSlot();

	call	?findFirstFreeSlot@@YAHXZ		; findFirstFreeSlot
	mov	BYTE PTR _w$[ebp+29], al

; 20   : 	if(w.windowId == -1) return -1;

	movsx	eax, BYTE PTR _w$[ebp+29]
	cmp	eax, -1
	jne	SHORT $LN1@addWindow
	or	eax, -1
	jmp	SHORT $LN3@addWindow
$LN1@addWindow:

; 21   : 	wList[w.windowId] = w;

	movsx	edi, BYTE PTR _w$[ebp+29]
	imul	edi, 34					; 00000022H
	add	edi, OFFSET _wList
	mov	ecx, 8
	lea	esi, DWORD PTR _w$[ebp]
	rep movsd
	movsw

; 22   : 	return w.windowId;

	movsx	eax, BYTE PTR _w$[ebp+29]
$LN3@addWindow:

; 23   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?addWindow@@YAHUWINDOW@@@Z ENDP				; addWindow
_TEXT	ENDS
PUBLIC	?repaintScreen@@YAXXZ				; repaintScreen
; Function compile flags: /Odtp /ZI
;	COMDAT ?repaintScreen@@YAXXZ
_TEXT	SEGMENT
_i$2569 = -4						; size = 4
?repaintScreen@@YAXXZ PROC				; repaintScreen, COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 27   : 	for(int i = 0; i < 16; i++)

	mov	DWORD PTR _i$2569[ebp], 0
	jmp	SHORT $LN4@repaintScr
$LN3@repaintScr:
	mov	eax, DWORD PTR _i$2569[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2569[ebp], eax
$LN4@repaintScr:
	cmp	DWORD PTR _i$2569[ebp], 16		; 00000010H
	jge	SHORT $LN5@repaintScr

; 28   : 	{
; 29   : 		if(!wList[i].isValid) continue;

	mov	eax, DWORD PTR _i$2569[ebp]
	imul	eax, 34					; 00000022H
	movzx	ecx, BYTE PTR _wList[eax+12]
	test	ecx, ecx
	jne	SHORT $LN1@repaintScr
	jmp	SHORT $LN3@repaintScr
$LN1@repaintScr:

; 30   : 			wList[i].paint(&wList[i]);

	mov	eax, DWORD PTR _i$2569[ebp]
	imul	eax, 34					; 00000022H
	add	eax, OFFSET _wList
	push	eax
	mov	ecx, DWORD PTR _i$2569[ebp]
	imul	ecx, 34					; 00000022H
	mov	edx, DWORD PTR _wList[ecx]
	call	edx
	add	esp, 4

; 31   : 	}

	jmp	SHORT $LN3@repaintScr
$LN5@repaintScr:

; 32   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?repaintScreen@@YAXXZ ENDP				; repaintScreen
_TEXT	ENDS
PUBLIC	?getWindowById@@YAPAUWINDOW@@D@Z		; getWindowById
; Function compile flags: /Odtp /ZI
;	COMDAT ?getWindowById@@YAPAUWINDOW@@D@Z
_TEXT	SEGMENT
_id$ = 8						; size = 1
?getWindowById@@YAPAUWINDOW@@D@Z PROC			; getWindowById, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 36   : 	return &wList[id];

	movsx	eax, BYTE PTR _id$[ebp]
	imul	eax, 34					; 00000022H
	add	eax, OFFSET _wList

; 37   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getWindowById@@YAPAUWINDOW@@D@Z ENDP			; getWindowById
_TEXT	ENDS
PUBLIC	?removeWindow@@YAXD@Z				; removeWindow
; Function compile flags: /Odtp /ZI
;	COMDAT ?removeWindow@@YAXD@Z
_TEXT	SEGMENT
_id$ = 8						; size = 1
?removeWindow@@YAXD@Z PROC				; removeWindow, COMDAT

; 40   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 41   : 	wList[id].isValid = false;

	movsx	eax, BYTE PTR _id$[ebp]
	imul	eax, 34					; 00000022H
	mov	BYTE PTR _wList[eax+12], 0

; 42   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeWindow@@YAXD@Z ENDP				; removeWindow
_TEXT	ENDS
END
