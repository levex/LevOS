; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Dev\LevOS\kernel\SimpleGameApp\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?rtc_data@@3U__RTC__DATA@@A			; rtc_data
PUBLIC	?random_seed@@3HA				; random_seed
_BSS	SEGMENT
?rtc_data@@3U__RTC__DATA@@A DB 01cH DUP (?)		; rtc_data
?random_seed@@3HA DD 01H DUP (?)			; random_seed
_BSS	ENDS
PUBLIC	?random@@YAHHH@Z				; random
; Function compile flags: /Odtp /ZI
; File c:\dev\levos\kernel\simplegameapp\main.cpp
;	COMDAT ?random@@YAHHH@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
_max$ = 12						; size = 4
?random@@YAHHH@Z PROC					; random, COMDAT

; 11   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 12   : 	random_seed = random_seed+seed * 1103515245 + 12345;

	mov	eax, DWORD PTR _seed$[ebp]
	imul	eax, 1103515245				; 41c64e6dH
	mov	ecx, DWORD PTR ?random_seed@@3HA	; random_seed
	lea	edx, DWORD PTR [ecx+eax+12345]
	mov	DWORD PTR ?random_seed@@3HA, edx	; random_seed

; 13   : 	return (unsigned int)(random_seed / 65536) % (max+1); 

	mov	eax, DWORD PTR ?random_seed@@3HA	; random_seed
	cdq
	and	edx, 65535				; 0000ffffH
	add	eax, edx
	sar	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _max$[ebp]
	add	ecx, 1
	xor	edx, edx
	div	ecx
	mov	eax, edx

; 14   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?random@@YAHHH@Z ENDP					; random
_TEXT	ENDS
PUBLIC	?parseInt@@YAHPAD@Z				; parseInt
; Function compile flags: /Odtp /ZI
;	COMDAT ?parseInt@@YAHPAD@Z
_TEXT	SEGMENT
_r$ = -4						; size = 4
_string$ = 8						; size = 4
?parseInt@@YAHPAD@Z PROC				; parseInt, COMDAT

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 18   : 	int r = 0;

	mov	DWORD PTR _r$[ebp], 0
$LN2@parseInt:

; 19   : 	while(*string != '\0') {

	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@parseInt

; 20   : 		r *= 10;

	mov	eax, DWORD PTR _r$[ebp]
	imul	eax, 10					; 0000000aH
	mov	DWORD PTR _r$[ebp], eax

; 21   : 		r += (*string++ - 48);

	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _r$[ebp]
	lea	eax, DWORD PTR [edx+ecx-48]
	mov	DWORD PTR _r$[ebp], eax
	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, 1
	mov	DWORD PTR _string$[ebp], ecx

; 22   : 	}

	jmp	SHORT $LN2@parseInt
$LN1@parseInt:

; 23   : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 24   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?parseInt@@YAHPAD@Z ENDP				; parseInt
_TEXT	ENDS
PUBLIC	??_C@_0BK@ONAOAEKM@?6Your?5number?5is?5too?5much?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MCLOPNHF@?6Your?5number?5is?5too?5low?$CB?$AA@ ; `string'
PUBLIC	??_C@_0CJ@CJILKOFE@?6Correct?$CB?5Thanks?5for?5playing?$CB?5?3?$CJ@ ; `string'
PUBLIC	??_C@_0GF@CNMIMHML@?6I?5have?5thought?5of?5a?5number?$CB?6Typ@ ; `string'
PUBLIC	??_C@_0DH@PNIGGDEN@?6Guess?9the?9Number?5v1?40?5by?5Levex?$CB@ ; `string'
PUBLIC	_main
EXTRN	?printNumber@@YAXH@Z:PROC			; printNumber
EXTRN	?printchar@@YAXD@Z:PROC				; printchar
EXTRN	?fillRTC@@YAXH@Z:PROC				; fillRTC
EXTRN	?getInputChar@@YADXZ:PROC			; getInputChar
EXTRN	?print@@YAXPAD@Z:PROC				; print
;	COMDAT ??_C@_0BK@ONAOAEKM@?6Your?5number?5is?5too?5much?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@ONAOAEKM@?6Your?5number?5is?5too?5much?$CB?$AA@ DB 0aH, 'Your n'
	DB	'umber is too much!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MCLOPNHF@?6Your?5number?5is?5too?5low?$CB?$AA@
CONST	SEGMENT
??_C@_0BJ@MCLOPNHF@?6Your?5number?5is?5too?5low?$CB?$AA@ DB 0aH, 'Your nu'
	DB	'mber is too low!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CJILKOFE@?6Correct?$CB?5Thanks?5for?5playing?$CB?5?3?$CJ@
CONST	SEGMENT
??_C@_0CJ@CJILKOFE@?6Correct?$CB?5Thanks?5for?5playing?$CB?5?3?$CJ@ DB 0aH
	DB	'Correct! Thanks for playing! :) Tries: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@CNMIMHML@?6I?5have?5thought?5of?5a?5number?$CB?6Typ@
CONST	SEGMENT
??_C@_0GF@CNMIMHML@?6I?5have?5thought?5of?5a?5number?$CB?6Typ@ DB 0aH, 'I'
	DB	' have thought of a number!', 0aH, 'Type in your number and I '
	DB	'shall reply whether it is bigger or smaller!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PNIGGDEN@?6Guess?9the?9Number?5v1?40?5by?5Levex?$CB@
CONST	SEGMENT
??_C@_0DH@PNIGGDEN@?6Guess?9the?9Number?5v1?40?5by?5Levex?$CB@ DB 0aH, 'G'
	DB	'uess-the-Number v1.0 by Levex!', 0aH, 'Press a key to start!', 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_guess$2604 = -84					; size = 4
_c$2601 = -77						; size = 1
_i$2597 = -76						; size = 4
_buf$ = -72						; size = 64
_tries$ = -8						; size = 4
_num$ = -4						; size = 4
_main	PROC						; COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi

; 28   : 	print("\nGuess-the-Number v1.0 by Levex!\nPress a key to start!");

	push	OFFSET ??_C@_0DH@PNIGGDEN@?6Guess?9the?9Number?5v1?40?5by?5Levex?$CB@
	call	?print@@YAXPAD@Z			; print
	add	esp, 4

; 29   : 	getInputChar();

	call	?getInputChar@@YADXZ			; getInputChar

; 30   : 	fillRTC((unsigned int)&rtc_data);

	push	OFFSET ?rtc_data@@3U__RTC__DATA@@A	; rtc_data
	call	?fillRTC@@YAXH@Z			; fillRTC
	add	esp, 4

; 31   : 	int num = random(rtc_data.Second + rtc_data.Minute + rtc_data.DayOfMonth + rtc_data.Hour, 100);

	push	100					; 00000064H
	mov	eax, DWORD PTR ?rtc_data@@3U__RTC__DATA@@A+24
	add	eax, DWORD PTR ?rtc_data@@3U__RTC__DATA@@A+20
	add	eax, DWORD PTR ?rtc_data@@3U__RTC__DATA@@A+8
	add	eax, DWORD PTR ?rtc_data@@3U__RTC__DATA@@A+16
	push	eax
	call	?random@@YAHHH@Z			; random
	add	esp, 8
	mov	DWORD PTR _num$[ebp], eax

; 32   : 	int tries = 0;

	mov	DWORD PTR _tries$[ebp], 0

; 33   : 	//printNumber(parseInt("1234"));
; 34   : 	//printNumber(num);
; 35   : 	print("\nI have thought of a number!\nType in your number and I shall reply whether it is bigger or smaller!\n");

	push	OFFSET ??_C@_0GF@CNMIMHML@?6I?5have?5thought?5of?5a?5number?$CB?6Typ@
	call	?print@@YAXPAD@Z			; print
	add	esp, 4
$getinput$2595:

; 36   : getinput:
; 37   : 	char buf[64];
; 38   : 	for(int i = 0;; i++)

	mov	DWORD PTR _i$2597[ebp], 0
	jmp	SHORT $LN13@main
$LN12@main:
	mov	eax, DWORD PTR _i$2597[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2597[ebp], eax
$LN13@main:

; 39   : 	{
; 40   : 		char c = getInputChar();

	call	?getInputChar@@YADXZ			; getInputChar
	mov	BYTE PTR _c$2601[ebp], al

; 41   : 		if(c == 0xD) {

	movsx	eax, BYTE PTR _c$2601[ebp]
	cmp	eax, 13					; 0000000dH
	jne	$LN10@main

; 42   : 			if(i == 0) {printchar('\n'); i--; continue;}

	cmp	DWORD PTR _i$2597[ebp], 0
	jne	SHORT $LN9@main
	push	10					; 0000000aH
	call	?printchar@@YAXD@Z			; printchar
	add	esp, 4
	mov	eax, DWORD PTR _i$2597[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$2597[ebp], eax
	jmp	SHORT $LN12@main
$LN9@main:

; 43   : 			buf[i]='\0';

	mov	eax, DWORD PTR _i$2597[ebp]
	mov	BYTE PTR _buf$[ebp+eax], 0

; 44   : 			int guess = parseInt(buf);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?parseInt@@YAHPAD@Z			; parseInt
	add	esp, 4
	mov	DWORD PTR _guess$2604[ebp], eax

; 45   : 			if(guess == num)

	mov	eax, DWORD PTR _guess$2604[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jne	SHORT $LN8@main

; 46   : 			{
; 47   : 				print("\nCorrect! Thanks for playing! :) Tries: ");

	push	OFFSET ??_C@_0CJ@CJILKOFE@?6Correct?$CB?5Thanks?5for?5playing?$CB?5?3?$CJ@
	call	?print@@YAXPAD@Z			; print
	add	esp, 4

; 48   : 				printNumber(tries);

	mov	eax, DWORD PTR _tries$[ebp]
	push	eax
	call	?printNumber@@YAXH@Z			; printNumber
	add	esp, 4

; 49   : 				return;

	jmp	$LN14@main
	jmp	SHORT $LN7@main
$LN8@main:

; 50   : 			} else if(guess < num)

	mov	eax, DWORD PTR _guess$2604[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jge	SHORT $LN6@main

; 51   : 			{
; 52   : 				print("\nYour number is too low!");

	push	OFFSET ??_C@_0BJ@MCLOPNHF@?6Your?5number?5is?5too?5low?$CB?$AA@
	call	?print@@YAXPAD@Z			; print
	add	esp, 4

; 53   : 				tries++;

	mov	eax, DWORD PTR _tries$[ebp]
	add	eax, 1
	mov	DWORD PTR _tries$[ebp], eax
	jmp	SHORT $LN7@main
$LN6@main:

; 54   : 			} else if(guess > num)

	mov	eax, DWORD PTR _guess$2604[ebp]
	cmp	eax, DWORD PTR _num$[ebp]
	jle	SHORT $LN7@main

; 55   : 			{
; 56   : 				print("\nYour number is too much!");

	push	OFFSET ??_C@_0BK@ONAOAEKM@?6Your?5number?5is?5too?5much?$CB?$AA@
	call	?print@@YAXPAD@Z			; print
	add	esp, 4

; 57   : 				tries++;

	mov	eax, DWORD PTR _tries$[ebp]
	add	eax, 1
	mov	DWORD PTR _tries$[ebp], eax
$LN7@main:

; 58   : 			}
; 59   : 			printchar('\n');

	push	10					; 0000000aH
	call	?printchar@@YAXD@Z			; printchar
	add	esp, 4

; 60   : 			goto getinput;

	jmp	$getinput$2595
$LN10@main:

; 61   : 		}
; 62   : 		if(c == '\0') continue;

	movsx	eax, BYTE PTR _c$2601[ebp]
	test	eax, eax
	jne	SHORT $LN3@main
	jmp	$LN12@main
$LN3@main:

; 63   : 		if(c < 48 || c > 57) continue; // skip non numbers

	movsx	eax, BYTE PTR _c$2601[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN1@main
	movsx	eax, BYTE PTR _c$2601[ebp]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN2@main
$LN1@main:
	jmp	$LN12@main
$LN2@main:

; 64   : 		printchar(c);

	movzx	eax, BYTE PTR _c$2601[ebp]
	push	eax
	call	?printchar@@YAXD@Z			; printchar
	add	esp, 4

; 65   : 		buf[i] = c;

	mov	eax, DWORD PTR _i$2597[ebp]
	mov	cl, BYTE PTR _c$2601[ebp]
	mov	BYTE PTR _buf$[ebp+eax], cl

; 66   : 	}

	jmp	$LN12@main
$LN14@main:

; 67   : 	return;
; 68   : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END
